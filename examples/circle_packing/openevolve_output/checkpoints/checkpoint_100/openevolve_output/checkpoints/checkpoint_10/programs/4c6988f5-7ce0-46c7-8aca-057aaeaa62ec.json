{"id": "4c6988f5-7ce0-46c7-8aca-057aaeaa62ec", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing algorithm for n=26 circles in a unit square\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Initialize with a hybrid arrangement that combines corner, edge and interior placements\n    # with variable sized circles\n    centers, radii = initialize_strategic_packing(n)\n    \n    # Apply physics-based optimization with variable force parameters\n    centers, radii = optimize_packing(centers, radii, iterations=500)\n    \n    # Final refinement to maximize radii without overlaps\n    radii = compute_max_radii(centers)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef initialize_strategic_packing(n):\n    \"\"\"\n    Initialize circles with a strategic arrangement that combines:\n    - Corner circles\n    - Edge circles\n    - Interior circles with a modified hexagonal pattern\n    \n    This hybrid approach is known to produce better packings than uniform grids.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place 4 circles in corners with specific offsets\n    corner_offset = 0.09  # Optimized offset for corners\n    corners = [(corner_offset, corner_offset), \n               (corner_offset, 1-corner_offset),\n               (1-corner_offset, corner_offset),\n               (1-corner_offset, 1-corner_offset)]\n    \n    for i, (x, y) in enumerate(corners):\n        centers[i] = [x, y]\n        radii[i] = corner_offset  # Initial estimate\n    \n    # Place circles along edges\n    edge_count = 8\n    edge_circles = []\n    \n    # Top and bottom edges\n    for i in range(edge_count // 4):\n        x = (i + 1) * (1.0 / (edge_count // 4 + 1))\n        edge_circles.append((x, corner_offset))\n        edge_circles.append((x, 1 - corner_offset))\n    \n    # Left and right edges\n    for i in range(edge_count // 4):\n        y = (i + 1) * (1.0 / (edge_count // 4 + 1))\n        edge_circles.append((corner_offset, y))\n        edge_circles.append((1 - corner_offset, y))\n    \n    for i, (x, y) in enumerate(edge_circles[:edge_count]):\n        centers[i+4] = [x, y]\n        radii[i+4] = corner_offset  # Initial estimate\n    \n    # Place remaining circles in interior with a hexagonal-inspired pattern\n    interior_count = n - 4 - edge_count\n    \n    # Create a hexagonal grid with slight adjustments\n    interior_positions = []\n    rows = 3  # For interior circles\n    \n    for row in range(rows):\n        y = 0.25 + row * 0.25\n        # Offset even rows for hexagonal packing\n        offset = 0.125 if row % 2 == 1 else 0\n        cols = 4 if row % 2 == 1 else 5\n        \n        for col in range(cols):\n            x = 0.125 + offset + col * 0.2\n            if len(interior_positions) < interior_count:\n                interior_positions.append((x, y))\n    \n    # Add central circle if needed\n    if len(interior_positions) < interior_count:\n        interior_positions.append((0.5, 0.5))\n    \n    # Fill any remaining positions with strategic placements\n    while len(interior_positions) < interior_count:\n        x = np.random.uniform(0.2, 0.8)\n        y = np.random.uniform(0.2, 0.8)\n        interior_positions.append((x, y))\n    \n    for i, (x, y) in enumerate(interior_positions[:interior_count]):\n        centers[i+4+edge_count] = [x, y]\n        radii[i+4+edge_count] = 0.1  # Initial estimate\n    \n    # Initial radius computation\n    radii = compute_max_radii(centers)\n    \n    return centers, radii\n\n\ndef optimize_packing(centers, radii, iterations=500):\n    \"\"\"\n    Optimize circle packing using a physics-based approach with\n    adaptive parameters and simulated annealing.\n    \"\"\"\n    n = centers.shape[0]\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # Parameters for optimization\n    repulsion_strength = 0.05\n    attraction_strength = 0.01\n    temperature = 1.0\n    cooling_rate = 0.995\n    \n    for iter in range(iterations):\n        # Adjust temperature\n        temperature *= cooling_rate\n        \n        # Calculate forces between circles\n        forces = np.zeros_like(centers)\n        \n        # Repulsive forces to prevent overlap\n        for i in range(n):\n            for j in range(i+1, n):\n                vec = centers[i] - centers[j]\n                dist = np.linalg.norm(vec)\n                if dist == 0:  # Avoid division by zero\n                    vec = np.random.uniform(-0.01, 0.01, 2)\n                    dist = np.linalg.norm(vec)\n                \n                # Normalized direction vector\n                direction = vec / dist\n                \n                # Calculate overlap\n                overlap = radii[i] + radii[j] - dist\n                \n                if overlap > 0:  # Circles overlap\n                    # Apply stronger repulsion for overlapping circles\n                    force_mag = repulsion_strength * overlap * (1 + temperature)\n                    forces[i] += direction * force_mag\n                    forces[j] -= direction * force_mag\n                else:  # Circles don't overlap\n                    # Apply weak attraction if circles are far apart\n                    gap = -overlap\n                    if gap > 0.1:  # Only attract if gap is significant\n                        force_mag = attraction_strength * min(gap, 0.05) * temperature\n                        forces[i] -= direction * force_mag\n                        forces[j] += direction * force_mag\n        \n        # Apply boundary forces to keep circles inside the unit square\n        for i in range(n):\n            # Left boundary\n            if centers[i, 0] - radii[i] < 0:\n                forces[i, 0] += repulsion_strength * (0 - (centers[i, 0] - radii[i]))\n            \n            # Right boundary\n            if centers[i, 0] + radii[i] > 1:\n                forces[i, 0] -= repulsion_strength * ((centers[i, 0] + radii[i]) - 1)\n            \n            # Bottom boundary\n            if centers[i, 1] - radii[i] < 0:\n                forces[i, 1] += repulsion_strength * (0 - (centers[i, 1] - radii[i]))\n            \n            # Top boundary\n            if centers[i, 1] + radii[i] > 1:\n                forces[i, 1] -= repulsion_strength * ((centers[i, 1] + radii[i]) - 1)\n        \n        # Apply forces to update positions\n        # Scale by temperature to reduce movement as optimization progresses\n        centers += forces * temperature\n        \n        # Ensure centers stay within bounds\n        centers = np.clip(centers, 0, 1)\n        \n        # Update radii based on new positions\n        radii = compute_max_radii(centers)\n        \n        # Track best solution\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n        \n        # Periodically inject some randomness to escape local optima\n        if iter % 50 == 0 and temperature > 0.2:\n            # Randomly perturb some circles\n            perturb_indices = np.random.choice(n, size=max(1, n//5), replace=False)\n            for idx in perturb_indices:\n                centers[idx] += np.random.uniform(-0.05, 0.05, 2) * temperature\n                centers[idx] = np.clip(centers[idx], 0, 1)\n    \n    # Return the best configuration found\n    return best_centers, best_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n    \n    Uses an iterative approach with relaxation for better convergence.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n    \n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n    \n    # Then, iteratively adjust radii to avoid overlaps\n    for _ in range(20):  # More iterations for better convergence\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if dist < radii[i] + radii[j]:  # Overlap detected\n                        # Proportionally reduce both radii\n                        ratio = dist / (radii[i] + radii[j])\n                        radii[i] *= 0.99 * ratio\n                        radii[j] *= 0.99 * ratio\n    \n    # Final pass to ensure no overlaps\n    for _ in range(5):\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_allowed = max(0.0, dist - radii[j])\n                    if radii[i] > max_allowed:\n                        radii[i] = max_allowed * 0.999  # Small safety factor\n    \n    # Ensure circles are within bounds\n    for i in range(n):\n        x, y = centers[i]\n        border_dist = min(x, y, 1 - x, 1 - y)\n        if radii[i] > border_dist:\n            radii[i] = border_dist * 0.999  # Small safety factor\n    \n    return radii\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    visualize(centers, radii)", "language": "python", "parent_id": "54080351-29c7-4ee9-881d-9360474bba4e", "generation": 3, "timestamp": 1750788194.2603312, "iteration_found": 10, "metrics": {"validity": 1.0, "sum_radii": 1.6023546890832758, "target_ratio": 0.608104246331414, "combined_score": 0.608104246331414, "eval_time": 32.803996324539185}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "sum_radii": 0.0, "target_ratio": 0.0, "combined_score": 0.0}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.635 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.377, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - validity: 0.0000\n- sum_radii: 0.0000\n- target_ratio: 0.0000\n- combined_score: 0.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: validity, sum_radii, target_ratio, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.0532, target_ratio: 0.7792, combined_score: 0.7792, eval_time: 1.1042\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.0092, target_ratio: 0.7625, combined_score: 0.7625, eval_time: 1.3613\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.1289, target_ratio: 0.8079, combined_score: 0.8079, eval_time: 1.2307\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 1.1951)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.1289), Performs well on target_ratio (0.8079), Performs well on combined_score (0.8079), Performs well on eval_time (1.2307)\n\n\n### Program 2 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on error (Program execution failed: index 26 is out of bounds for axis 0 with size 26)\n\n\n### Program 3 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on error (Program execution failed: index 26 is out of bounds for axis 0 with size 26)\n\n\n### Program 4 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on error (Program execution failed: index 26 is out of bounds for axis 0 with size 26)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 1.0980)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\ndef construct_packing():\n# ... (truncated)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Improved initial placement based on hexagonal grid and edge/corner considerations\n    grid_size = 5  # Approximate grid size\n    cell_size = 1.0 / grid_size\n\n    # Place circles in a somewhat hexagonal arrangement\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) * cell_size\n        y = (row + 0.5) * cell_size\n        centers[i] = [x, y]\n        radii[i] = cell_size / 3.0  # Initial radius\n\n    # Adjust positions for better packing (more sophisticated)\n    # Prioritize corners and edges\n    centers[0] = [0.15, 0.15]  # Corner\n    centers[1] = [0.85, 0.15]  # Corner\n    centers[2] = [0.15, 0.85]  # Corner\n    centers[3] = [0.85, 0.85]  # Corner\n    centers[4] = [0.5, 0.1]  # Edge\n    centers[5] = [0.5, 0.9]  # Edge\n    centers[6] = [0.1, 0.5]  # Edge\n    centers[7] = [0.9, 0.5]  # Edge\n\n    # Central circles\n    centers[8] = [0.3, 0.3]\n    centers[9] = [0.7, 0.3]\n    centers[10] = [0.3, 0.7]\n    centers[11] = [0.7, 0.7]\n    centers[12] = [0.5, 0.5]\n\n\n    # Refinement iterations (increased and optimized)\n    for _ in range(200):  # Increased iterations significantly\n        for i in range(n):\n            # Distance to walls\n            dist_to_walls = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n\n            # Distance to other circles\n            dist_to_circles = float('inf')\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n                    dist_to_circles = min(dist_to_circles, dist - radii[j])\n\n            # Radius update: balance between wall distance and circle distance\n            radii[i] = min(dist_to_walls, dist_to_circles) * 0.98  # Reduce radius slightly to allow movement\n\n        # Position adjustment (simulated annealing-like approach)\n        temperature = 0.1  # Control the magnitude of movement\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n                    overlap = radii[i] + radii[j] - dist\n                    if overlap > 0:\n                        move_x = (centers[i][0] - centers[j][0]) * overlap * 0.05 * temperature\n                        move_y = (centers[i][1] - centers[j][1]) * overlap * 0.05 * temperature\n                        centers[i][0] += move_x\n                        centers[i][1] += move_y\n                        centers[j][0] -= move_x\n                        centers[j][1] -= move_y\n\n                        # Clip positions to stay within bounds\n                        centers[i][0] = np.clip(centers[i][0], radii[i], 1 - radii[i])\n                        centers[i][1] = np.clip(centers[i][1], radii[i], 1 - radii[i])\n                        centers[j][0] = np.clip(centers[j][0], radii[j], 1 - radii[j])\n                        centers[j][1] = np.clip(centers[j][1], radii[j], 1 - radii[j])\n        temperature *= 0.99  # Cool down\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, iteratively adjust radii to avoid overlaps\n    # This approach is more accurate than the proportional scaling\n    # We use multiple iterations to converge to a valid solution\n    for _ in range(15):  # Multiple iterations for better convergence\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n                    max_allowed = max(0.0, dist - radii[j])\n                    radii[i] = min(radii[i], max_allowed)\n\n    return radii\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["I'll rewrite the program to significantly improve the circle packing performance. The current implementation has several limitations that I'll address with a more sophisticated approach based on mathematical insights about optimal circle packing.\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing algorithm for n=26 circles in a unit square\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Initialize with a hybrid arrangement that combines corner, edge and interior placements\n    # with variable sized circles\n    centers, radii = initialize_strategic_packing(n)\n    \n    # Apply physics-based optimization with variable force parameters\n    centers, radii = optimize_packing(centers, radii, iterations=500)\n    \n    # Final refinement to maximize radii without overlaps\n    radii = compute_max_radii(centers)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef initialize_strategic_packing(n):\n    \"\"\"\n    Initialize circles with a strategic arrangement that combines:\n    - Corner circles\n    - Edge circles\n    - Interior circles with a modified hexagonal pattern\n    \n    This hybrid approach is known to produce better packings than uniform grids.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place 4 circles in corners with specific offsets\n    corner_offset = 0.09  # Optimized offset for corners\n    corners = [(corner_offset, corner_offset), \n               (corner_offset, 1-corner_offset),\n               (1-corner_offset, corner_offset),\n               (1-corner_offset, 1-corner_offset)]\n    \n    for i, (x, y) in enumerate(corners):\n        centers[i] = [x, y]\n        radii[i] = corner_offset  # Initial estimate\n    \n    # Place circles along edges\n    edge_count = 8\n    edge_circles = []\n    \n    # Top and bottom edges\n    for i in range(edge_count // 4):\n        x = (i + 1) * (1.0 / (edge_count // 4 + 1))\n        edge_circles.append((x, corner_offset))\n        edge_circles.append((x, 1 - corner_offset))\n    \n    # Left and right edges\n    for i in range(edge_count // 4):\n        y = (i + 1) * (1.0 / (edge_count // 4 + 1))\n        edge_circles.append((corner_offset, y))\n        edge_circles.append((1 - corner_offset, y))\n    \n    for i, (x, y) in enumerate(edge_circles[:edge_count]):\n        centers[i+4] = [x, y]\n        radii[i+4] = corner_offset  # Initial estimate\n    \n    # Place remaining circles in interior with a hexagonal-inspired pattern\n    interior_count = n - 4 - edge_count\n    \n    # Create a hexagonal grid with slight adjustments\n    interior_positions = []\n    rows = 3  # For interior circles\n    \n    for row in range(rows):\n        y = 0.25 + row * 0.25\n        # Offset even rows for hexagonal packing\n        offset = 0.125 if row % 2 == 1 else 0\n        cols = 4 if row % 2 == 1 else 5\n        \n        for col in range(cols):\n            x = 0.125 + offset + col * 0.2\n            if len(interior_positions) < interior_count:\n                interior_positions.append((x, y))\n    \n    # Add central circle if needed\n    if len(interior_positions) < interior_count:\n        interior_positions.append((0.5, 0.5))\n    \n    # Fill any remaining positions with strategic placements\n    while len(interior_positions) < interior_count:\n        x = np.random.uniform(0.2, 0.8)\n        y = np.random.uniform(0.2, 0.8)\n        interior_positions.append((x, y))\n    \n    for i, (x, y) in enumerate(interior_positions[:interior_count]):\n        centers[i+4+edge_count] = [x, y]\n        radii[i+4+edge_count] = 0.1  # Initial estimate\n    \n    # Initial radius computation\n    radii = compute_max_radii(centers)\n    \n    return centers, radii\n\n\ndef optimize_packing(centers, radii, iterations=500):\n    \"\"\"\n    Optimize circle packing using a physics-based approach with\n    adaptive parameters and simulated annealing.\n    \"\"\"\n    n = centers.shape[0]\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # Parameters for optimization\n    repulsion_strength = 0.05\n    attraction_strength = 0.01\n    temperature = 1.0\n    cooling_rate = 0.995\n    \n    for iter in range(iterations):\n        # Adjust temperature\n        temperature *= cooling_rate\n        \n        # Calculate forces between circles\n        forces = np.zeros_like(centers)\n        \n        # Repulsive forces to prevent overlap\n        for i in range(n):\n            for j in range(i+1, n):\n                vec = centers[i] - centers[j]\n                dist = np.linalg.norm(vec)\n                if dist == 0:  # Avoid division by zero\n                    vec = np.random.uniform(-0.01, 0.01, 2)\n                    dist = np.linalg.norm(vec)\n                \n                # Normalized direction vector\n                direction = vec / dist\n                \n                # Calculate overlap\n                overlap = radii[i] + radii[j] - dist\n                \n                if overlap > 0:  # Circles overlap\n                    # Apply stronger repulsion for overlapping circles\n                    force_mag = repulsion_strength * overlap * (1 + temperature)\n                    forces[i] += direction * force_mag\n                    forces[j] -= direction * force_mag\n                else:  # Circles don't overlap\n                    # Apply weak attraction if circles are far apart\n                    gap = -overlap\n                    if gap > 0.1:  # Only attract if gap is significant\n                        force_mag = attraction_strength * min(gap, 0.05) * temperature\n                        forces[i] -= direction * force_mag\n                        forces[j] += direction * force_mag\n        \n        # Apply boundary forces to keep circles inside the unit square\n        for i in range(n):\n            # Left boundary\n            if centers[i, 0] - radii[i] < 0:\n                forces[i, 0] += repulsion_strength * (0 - (centers[i, 0] - radii[i]))\n            \n            # Right boundary\n            if centers[i, 0] + radii[i] > 1:\n                forces[i, 0] -= repulsion_strength * ((centers[i, 0] + radii[i]) - 1)\n            \n            # Bottom boundary\n            if centers[i, 1] - radii[i] < 0:\n                forces[i, 1] += repulsion_strength * (0 - (centers[i, 1] - radii[i]))\n            \n            # Top boundary\n            if centers[i, 1] + radii[i] > 1:\n                forces[i, 1] -= repulsion_strength * ((centers[i, 1] + radii[i]) - 1)\n        \n        # Apply forces to update positions\n        # Scale by temperature to reduce movement as optimization progresses\n        centers += forces * temperature\n        \n        # Ensure centers stay within bounds\n        centers = np.clip(centers, 0, 1)\n        \n        # Update radii based on new positions\n        radii = compute_max_radii(centers)\n        \n        # Track best solution\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n        \n        # Periodically inject some randomness to escape local optima\n        if iter % 50 == 0 and temperature > 0.2:\n            # Randomly perturb some circles\n            perturb_indices = np.random.choice(n, size=max(1, n//5), replace=False)\n            for idx in perturb_indices:\n                centers[idx] += np.random.uniform(-0.05, 0.05, 2) * temperature\n                centers[idx] = np.clip(centers[idx], 0, 1)\n    \n    # Return the best configuration found\n    return best_centers, best_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n    \n    Uses an iterative approach with relaxation for better convergence.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n    \n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n    \n    # Then, iteratively adjust radii to avoid overlaps\n    for _ in range(20):  # More iterations for better convergence\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if dist < radii[i] + radii[j]:  # Overlap detected\n                        # Proportionally reduce both radii\n                        ratio = dist / (radii[i] + radii[j])\n                        radii[i] *= 0.99 * ratio\n                        radii[j] *= 0.99 * ratio\n    \n    # Final pass to ensure no overlaps\n    for _ in range(5):\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_allowed = max(0.0, dist - radii[j])\n                    if radii[i] > max_allowed:\n                        radii[i] = max_allowed * 0.999  # Small safety factor\n    \n    # Ensure circles are within bounds\n    for i in range(n):\n        x, y = centers[i]\n        border_dist = min(x, y, 1 - x, 1 - y)\n        if radii[i] > border_dist:\n            radii[i] = border_dist * 0.999  # Small safety factor\n    \n    return radii\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    visualize(centers, radii)\n```\n\nThe key improvements in this rewritten program include:\n\n1. **Strategic initial placement**: The initialization now uses a hybrid approach with special consideration for corners, edges, and interior circles, which is known to be more effective for circle packing problems.\n\n2. **Physics-based optimization**: The algorithm uses a more sophisticated physics model with both repulsive forces (to prevent overlap) and attractive forces (to minimize gaps), combined with simulated annealing to escape local optima.\n\n3. **Adaptive parameters**: The optimization parameters change during the process, allowing for more exploration early and more refinement later.\n\n4. **Improved radius computation**: The radius calculation uses a multi-pass approach with proportional adjustments to better handle complex arrangements.\n\n5. **Randomness injection**: Periodic perturbations help escape local optima, which is crucial for finding better global solutions.\n\n6. **Best solution tracking**: The algorithm keeps track of the best solution found during optimization, ensuring we don't lose good configurations.\n\nThis approach should significantly improve the sum of radii toward the target of 2.635 by combining mathematical insights about optimal circle packing with effective computational techniques."]}}}