{"id": "829b12c2-3276-42f2-bb01-adffb551d27a", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Try multiple initialization strategies and keep the best result\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try different initialization patterns\n    for pattern_type in range(4):\n        # Initialize with different patterns\n        if pattern_type == 0:\n            centers, radii = initialize_corner_edge_pattern()\n        elif pattern_type == 1:\n            centers, radii = initialize_hexagonal_pattern()\n        elif pattern_type == 2:\n            centers, radii = initialize_hybrid_pattern()\n        else:\n            centers, radii = initialize_variable_size_pattern()\n        \n        # Optimize positions and radii\n        centers, radii = optimize_packing(centers, radii)\n        \n        # Perform final refinement\n        centers, radii = refine_packing(centers, radii)\n        \n        # Calculate sum of radii\n        sum_radii = np.sum(radii)\n        \n        # Keep track of best result\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_corner_edge_pattern():\n    \"\"\"\n    Initialize with a pattern that places circles at corners and edges.\n    This pattern is known to work well for small numbers of circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place circles at corners\n    centers[0] = [0.0, 0.0]  # Bottom-left\n    centers[1] = [1.0, 0.0]  # Bottom-right\n    centers[2] = [0.0, 1.0]  # Top-left\n    centers[3] = [1.0, 1.0]  # Top-right\n    \n    # Initial corner radii\n    corner_radius = 0.1\n    radii[0:4] = corner_radius\n    \n    # Place circles along edges\n    edge_count = 5\n    for i in range(edge_count):\n        # Bottom edge\n        centers[4+i] = [(i+1)/(edge_count+1), 0.0]\n        # Right edge\n        centers[4+edge_count+i] = [1.0, (i+1)/(edge_count+1)]\n        # Top edge\n        centers[4+2*edge_count+i] = [(i+1)/(edge_count+1), 1.0]\n        # Left edge\n        centers[4+3*edge_count+i] = [0.0, (i+1)/(edge_count+1)]\n    \n    # Initial edge radii\n    edge_radius = 0.09\n    radii[4:4+4*edge_count] = edge_radius\n    \n    # Place remaining circles in the interior\n    remaining = n - (4 + 4*edge_count)\n    for i in range(remaining):\n        centers[4+4*edge_count+i] = [0.3 + 0.4 * np.random.random(), \n                                     0.3 + 0.4 * np.random.random()]\n        radii[4+4*edge_count+i] = 0.08\n    \n    return centers, radii\n\ndef initialize_hexagonal_pattern():\n    \"\"\"\n    Initialize with a hexagonal pattern, which is known to be efficient for circle packing.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Estimate radius based on hexagonal packing\n    r_est = 0.5 / np.sqrt(n * 2/np.sqrt(3))\n    \n    # Create a hexagonal grid\n    rows = int(np.ceil(np.sqrt(n)))\n    cols = int(np.ceil(n / rows))\n    \n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if count < n:\n                # Hexagonal offset for even rows\n                offset = (j % 2) * 0.5 * r_est\n                x = (i + 0.5) * 2 * r_est\n                y = (j + 0.5) * np.sqrt(3) * r_est + offset\n                \n                # Scale to fit unit square\n                x = x / (rows * 2 * r_est)\n                y = y / (cols * np.sqrt(3) * r_est)\n                \n                centers[count] = [x, y]\n                radii[count] = r_est * 0.9  # Slightly smaller to avoid overlaps\n                count += 1\n    \n    return centers, radii\n\ndef initialize_hybrid_pattern():\n    \"\"\"\n    Initialize with a hybrid pattern that combines aspects of hexagonal and variable size patterns.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place larger circles at corners\n    centers[0] = [0.1, 0.1]\n    centers[1] = [0.9, 0.1]\n    centers[2] = [0.1, 0.9]\n    centers[3] = [0.9, 0.9]\n    radii[0:4] = 0.1\n    \n    # Place a large circle in the center\n    centers[4] = [0.5, 0.5]\n    radii[4] = 0.12\n    \n    # Place medium circles in a ring around the center\n    ring_count = 8\n    for i in range(ring_count):\n        angle = 2 * np.pi * i / ring_count\n        r = 0.3  # Distance from center\n        centers[5+i] = [0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)]\n        radii[5+i] = 0.09\n    \n    # Place remaining circles in a larger ring\n    remaining = n - (5 + ring_count)\n    for i in range(remaining):\n        angle = 2 * np.pi * i / remaining\n        r = 0.65  # Distance from center\n        centers[5+ring_count+i] = [0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)]\n        radii[5+ring_count+i] = 0.08\n    \n    return centers, radii\n\ndef initialize_variable_size_pattern():\n    \"\"\"\n    Initialize with a pattern that has variable-sized circles.\n    Larger circles in the center, smaller circles at the edges.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place a large circle in the center\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.15\n    \n    # Place medium circles in a ring around the center\n    inner_ring = 6\n    for i in range(inner_ring):\n        angle = 2 * np.pi * i / inner_ring\n        r = 0.25  # Distance from center\n        centers[1+i] = [0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)]\n        radii[1+i] = 0.11\n    \n    # Place smaller circles in a second ring\n    middle_ring = 10\n    for i in range(middle_ring):\n        angle = 2 * np.pi * i / middle_ring\n        r = 0.45  # Distance from center\n        centers[1+inner_ring+i] = [0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)]\n        radii[1+inner_ring+i] = 0.09\n    \n    # Place smallest circles in the outermost ring\n    outer_ring = n - (1 + inner_ring + middle_ring)\n    for i in range(outer_ring):\n        angle = 2 * np.pi * i / outer_ring\n        r = 0.7  # Distance from center\n        centers[1+inner_ring+middle_ring+i] = [0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)]\n        radii[1+inner_ring+middle_ring+i] = 0.07\n    \n    return centers, radii\n\ndef optimize_packing(centers, radii):\n    \"\"\"\n    Optimize the circle packing using a physics-based approach.\n    \"\"\"\n    n = centers.shape[0]\n    \n    # Parameters for optimization\n    iterations = 500\n    learning_rate = 0.01\n    repulsion_strength = 0.1\n    attraction_strength = 0.01\n    border_repulsion = 0.2\n    \n    # Normalize centers to ensure they're within the unit square\n    centers = np.clip(centers, 0.0, 1.0)\n    \n    for iteration in range(iterations):\n        # Calculate forces between circles\n        forces = np.zeros_like(centers)\n        \n        # Circle-circle interactions\n        for i in range(n):\n            for j in range(i+1, n):\n                # Vector from i to j\n                vec = centers[j] - centers[i]\n                dist = np.linalg.norm(vec)\n                \n                # Skip if circles are too far apart\n                if dist > 3 * (radii[i] + radii[j]):\n                    continue\n                \n                # Normalize direction vector\n                if dist > 1e-10:  # Avoid division by zero\n                    direction = vec / dist\n                else:\n                    direction = np.array([1.0, 0.0])  # Default direction if circles are at same position\n                \n                # Calculate overlap\n                overlap = radii[i] + radii[j] - dist\n                \n                # Apply repulsion if circles overlap\n                if overlap > 0:\n                    repulsion = repulsion_strength * overlap\n                    forces[i] -= direction * repulsion\n                    forces[j] += direction * repulsion\n                else:\n                    # Apply weak attraction if circles are close but not overlapping\n                    attraction = attraction_strength * (overlap)  # Negative overlap means gap\n                    forces[i] += direction * attraction\n                    forces[j] -= direction * attraction\n        \n        # Border forces to keep circles inside the unit square\n        for i in range(n):\n            # Left border\n            if centers[i, 0] < radii[i]:\n                forces[i, 0] += border_repulsion * (radii[i] - centers[i, 0])\n            \n            # Right border\n            if centers[i, 0] > 1.0 - radii[i]:\n                forces[i, 0] -= border_repulsion * (centers[i, 0] - (1.0 - radii[i]))\n            \n            # Bottom border\n            if centers[i, 1] < radii[i]:\n                forces[i, 1] += border_repulsion * (radii[i] - centers[i, 1])\n            \n            # Top border\n            if centers[i, 1] > 1.0 - radii[i]:\n                forces[i, 1] -= border_repulsion * (centers[i, 1] - (1.0 - radii[i]))\n        \n        # Update positions\n        centers += learning_rate * forces\n        \n        # Ensure centers stay within bounds\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Adjust radii based on available space\n        if iteration % 10 == 0:\n            radii = adjust_radii(centers, radii)\n        \n        # Reduce learning rate over time\n        learning_rate *= 0.998\n    \n    # Final adjustment of radii\n    radii = adjust_radii(centers, radii)\n    \n    return centers, radii\n\ndef adjust_radii(centers, radii):\n    \"\"\"\n    Adjust the radii of circles to maximize their size without overlapping.\n    \"\"\"\n    n = centers.shape[0]\n    new_radii = np.zeros(n)\n    \n    # Initialize with distance to borders\n    for i in range(n):\n        x, y = centers[i]\n        new_radii[i] = min(x, y, 1.0 - x, 1.0 - y)\n    \n    # Limit by distance to other circles\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r = max(0.001, dist - radii[j])  # Ensure positive radius\n                new_radii[i] = min(new_radii[i], max_r)\n    \n    # Blend with current radii for stability\n    blend_factor = 0.2\n    adjusted_radii = (1 - blend_factor) * radii + blend_factor * new_radii\n    \n    return adjusted_radii\n\ndef refine_packing(centers, radii):\n    \"\"\"\n    Final refinement stage using a more precise optimization approach.\n    \"\"\"\n    n = centers.shape[0]\n    \n    # Parameters for refinement\n    iterations = 200\n    learning_rate = 0.005\n    \n    for iteration in range(iterations):\n        # Calculate gradient for each circle\n        gradients = np.zeros_like(centers)\n        \n        # For each circle, try small movements in different directions\n        for i in range(n):\n            for dx, dy in [(0.001, 0), (-0.001, 0), (0, 0.001), (0, -0.001)]:\n                # Move circle slightly\n                centers[i, 0] += dx\n                centers[i, 1] += dy\n                \n                # Recalculate maximum possible radii\n                new_radii = compute_max_radii(centers)\n                sum_new = np.sum(new_radii)\n                \n                # Move circle back\n                centers[i, 0] -= dx\n                centers[i, 1] -= dy\n                \n                # Calculate gradient\n                gradients[i, 0] += dx * sum_new / 0.001\n                gradients[i, 1] += dy * sum_new / 0.001\n        \n        # Normalize gradients\n        norms = np.linalg.norm(gradients, axis=1)\n        mask = norms > 1e-10\n        gradients[mask] = gradients[mask] / norms[mask, np.newaxis]\n        \n        # Update positions\n        centers += learning_rate * gradients\n        \n        # Ensure centers stay within bounds\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Update radii\n        radii = compute_max_radii(centers)\n        \n        # Reduce learning rate\n        learning_rate *= 0.99\n    \n    # Final calculation of radii\n    radii = compute_max_radii(centers)\n    \n    return centers, radii\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position, ensuring no overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n    \n    # Limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1.0 - x, 1.0 - y)\n    \n    # Limit by distance to other circles\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    # Distribute the overlap proportionally\n                    total = radii[i] + radii[j]\n                    if total > 0:\n                        ratio = dist / total\n                        radii[i] = min(radii[i], ratio * radii[i])\n                        radii[j] = min(radii[j], ratio * radii[j])\n    \n    # One more pass to ensure no overlaps\n    for _ in range(3):\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if dist < radii[i] + radii[j]:\n                        # Adjust both radii to eliminate overlap\n                        overlap = radii[i] + radii[j] - dist\n                        radii[i] -= overlap / 2\n                        radii[j] -= overlap / 2\n    \n    # Ensure minimum radius\n    radii = np.maximum(radii, 0.001)\n    \n    return radii\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)", "language": "python", "parent_id": "1ace6475-c974-4dae-a9ba-c0863d56bcf4", "generation": 6, "timestamp": 1750753416.599175, "iteration_found": 96, "metrics": {"stage1_passed": 0.0, "error": 0.0, "timeout": true}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 1.3892534258596105, "target_ratio": 0.5272309016545011, "combined_score": 0.5272309016545011, "eval_time": 1.5204167366027832}, "island": 2}, "artifacts_json": "{\"timeout\": true, \"timeout_duration\": 90, \"failure_stage\": \"stage1\", \"error_type\": \"timeout\"}", "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.635 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.377, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - validity: 1.0000\n- sum_radii: 1.3893\n- target_ratio: 0.5272\n- combined_score: 0.5272\n- eval_time: 1.5204\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: sum_radii, target_ratio, combined_score, eval_time. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.3617, target_ratio: 0.8963, combined_score: 0.8963, eval_time: 50.7247\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.3697, target_ratio: 0.8993, combined_score: 0.8993, eval_time: 51.0383\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 0.8986, target_ratio: 0.3410, combined_score: 0.3410, eval_time: 75.0648\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 2.1104)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4124), Performs well on target_ratio (0.9155), Performs well on combined_score (0.9155), Performs well on eval_time (5.3085)\n\n\n### Program 2 (Score: 15.5291)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a physics-based optimization approach with specialized patterns.\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (0.8986), Performs well on target_ratio (0.3410), Performs well on combined_score (0.3410), Performs well on eval_time (75.0648)\n\n\n### Program 3 (Score: 1.5092)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a hybrid optimization approach\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (1.6581), Performs well on target_ratio (0.6292), Performs well on combined_score (0.6292), Performs well on eval_time (3.6295)\n\n\n### Program 4 (Score: 0.9957)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles, optimized with gradient descent and adaptive radii\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii using a physics-inspired approach.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (1.4260), Performs well on target_ratio (0.5412), Performs well on combined_score (0.5412), Performs well on eval_time (1.4701)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern with variable-sized circles\"\"\"\nimport numpy as np\n\n\n# ... (truncated)\n```\nKey features: Alternative approach to stage1_passed, Alternative approach to error\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a hybrid approach with improved initialization and physics-based optimization.\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    centers, initial_radii = initialize_pattern()  # Initialize with radii\n    centers, radii = optimize_positions_radii(centers, initial_radii)\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef initialize_pattern():\n    \"\"\"\n    Initialize with a hybrid pattern, including estimated initial radii based on Voronoi cell area.\n    \"\"\"\n    n = 26\n    centers = np.random.rand(n, 2) * 0.8 + 0.1  # Random initial positions, avoiding edges\n    initial_radii = np.zeros(n)\n\n    #Initial radii based on a rough heuristic\n    initial_radii[:] = 0.07\n\n    # A few strategic placements to guide the optimization\n    centers[0] = [0.25, 0.25] # Bottom left\n    centers[1] = [0.75, 0.25] # Bottom Right\n    centers[2] = [0.25, 0.75] # Top Left\n    centers[3] = [0.75, 0.75] # Top Right\n    centers[4] = [0.5, 0.5] # Center\n\n    return centers, initial_radii\n\n\ndef optimize_positions_radii(centers, initial_radii):\n    \"\"\"\n    Optimize both circle positions and radii using a refined physics-based approach.\n    \"\"\"\n    n = centers.shape[0]\n    radii = initial_radii.copy()  # Start with initial radii\n    learning_rate = 0.2  # Increased learning rate\n    iterations = 300\n    repulsion_factor = 0.1  # Increased repulsion\n    border_repulsion = 0.02  # Repulsion from walls\n    radius_adjust_rate = 0.05  # Rate to adjust radii based on free space\n    damping_factor = 0.95 #Damping force\n\n    for iteration in range(iterations):\n        # Calculate forces\n        forces = np.zeros_like(centers)\n\n        # Circle-circle repulsion\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    direction = (centers[i] - centers[j]) / dist\n                    force_magnitude = repulsion_factor * overlap\n                    forces[i] += force_magnitude * direction\n                    forces[j] -= force_magnitude * direction\n\n        # Border repulsion\n        for i in range(n):\n            x, y = centers[i]\n            forces[i, 0] += border_repulsion * max(0, radii[i] - x)\n            forces[i, 0] -= border_repulsion * max(0, x - (1 - radii[i]))\n            forces[i, 1] += border_repulsion * max(0, radii[i] - y)\n            forces[i, 1] -= border_repulsion * max(0, y - (1 - radii[i]))\n\n        # Apply damping to forces\n        forces *= damping_factor\n\n        # Update positions\n        centers += learning_rate * forces\n\n        # Keep centers within bounds, adding a buffer\n        centers = np.clip(centers, 0.005, 0.995)\n\n        # Recalculate radii based on free space (more robust)\n        new_radii = compute_max_radii(centers)\n\n        # Adjust radii based on available space\n        for i in range(n):\n             radii[i] = (1 - radius_adjust_rate) * radii[i] + radius_adjust_rate * new_radii[i]\n\n        # Adjust learning rate\n        learning_rate *= 0.99\n\n    return centers, radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position, ensuring no overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # Limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Limit by distance to other circles\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                max_radius = (dist / 2.0) # Distribute space evenly\n                radii[i] = min(radii[i], max_radius)\n\n    return radii\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["Looking at the current performance, we need a significant improvement to reach the target of 2.635 for the sum of radii. The current implementation has plateaued at around 2.377, so we need to take a fundamentally different approach rather than just tweaking parameters.\n\nBased on the mathematical principles of circle packing, I'll implement a more sophisticated approach that:\n1. Uses a specialized initial pattern with variable-sized circles\n2. Implements a multi-stage optimization process\n3. Leverages known patterns for n=26 circles\n4. Uses strategic placement of circles at corners and edges\n5. Implements a more robust physics-based optimization\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Try multiple initialization strategies and keep the best result\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try different initialization patterns\n    for pattern_type in range(4):\n        # Initialize with different patterns\n        if pattern_type == 0:\n            centers, radii = initialize_corner_edge_pattern()\n        elif pattern_type == 1:\n            centers, radii = initialize_hexagonal_pattern()\n        elif pattern_type == 2:\n            centers, radii = initialize_hybrid_pattern()\n        else:\n            centers, radii = initialize_variable_size_pattern()\n        \n        # Optimize positions and radii\n        centers, radii = optimize_packing(centers, radii)\n        \n        # Perform final refinement\n        centers, radii = refine_packing(centers, radii)\n        \n        # Calculate sum of radii\n        sum_radii = np.sum(radii)\n        \n        # Keep track of best result\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_corner_edge_pattern():\n    \"\"\"\n    Initialize with a pattern that places circles at corners and edges.\n    This pattern is known to work well for small numbers of circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place circles at corners\n    centers[0] = [0.0, 0.0]  # Bottom-left\n    centers[1] = [1.0, 0.0]  # Bottom-right\n    centers[2] = [0.0, 1.0]  # Top-left\n    centers[3] = [1.0, 1.0]  # Top-right\n    \n    # Initial corner radii\n    corner_radius = 0.1\n    radii[0:4] = corner_radius\n    \n    # Place circles along edges\n    edge_count = 5\n    for i in range(edge_count):\n        # Bottom edge\n        centers[4+i] = [(i+1)/(edge_count+1), 0.0]\n        # Right edge\n        centers[4+edge_count+i] = [1.0, (i+1)/(edge_count+1)]\n        # Top edge\n        centers[4+2*edge_count+i] = [(i+1)/(edge_count+1), 1.0]\n        # Left edge\n        centers[4+3*edge_count+i] = [0.0, (i+1)/(edge_count+1)]\n    \n    # Initial edge radii\n    edge_radius = 0.09\n    radii[4:4+4*edge_count] = edge_radius\n    \n    # Place remaining circles in the interior\n    remaining = n - (4 + 4*edge_count)\n    for i in range(remaining):\n        centers[4+4*edge_count+i] = [0.3 + 0.4 * np.random.random(), \n                                     0.3 + 0.4 * np.random.random()]\n        radii[4+4*edge_count+i] = 0.08\n    \n    return centers, radii\n\ndef initialize_hexagonal_pattern():\n    \"\"\"\n    Initialize with a hexagonal pattern, which is known to be efficient for circle packing.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Estimate radius based on hexagonal packing\n    r_est = 0.5 / np.sqrt(n * 2/np.sqrt(3))\n    \n    # Create a hexagonal grid\n    rows = int(np.ceil(np.sqrt(n)))\n    cols = int(np.ceil(n / rows))\n    \n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if count < n:\n                # Hexagonal offset for even rows\n                offset = (j % 2) * 0.5 * r_est\n                x = (i + 0.5) * 2 * r_est\n                y = (j + 0.5) * np.sqrt(3) * r_est + offset\n                \n                # Scale to fit unit square\n                x = x / (rows * 2 * r_est)\n                y = y / (cols * np.sqrt(3) * r_est)\n                \n                centers[count] = [x, y]\n                radii[count] = r_est * 0.9  # Slightly smaller to avoid overlaps\n                count += 1\n    \n    return centers, radii\n\ndef initialize_hybrid_pattern():\n    \"\"\"\n    Initialize with a hybrid pattern that combines aspects of hexagonal and variable size patterns.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place larger circles at corners\n    centers[0] = [0.1, 0.1]\n    centers[1] = [0.9, 0.1]\n    centers[2] = [0.1, 0.9]\n    centers[3] = [0.9, 0.9]\n    radii[0:4] = 0.1\n    \n    # Place a large circle in the center\n    centers[4] = [0.5, 0.5]\n    radii[4] = 0.12\n    \n    # Place medium circles in a ring around the center\n    ring_count = 8\n    for i in range(ring_count):\n        angle = 2 * np.pi * i / ring_count\n        r = 0.3  # Distance from center\n        centers[5+i] = [0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)]\n        radii[5+i] = 0.09\n    \n    # Place remaining circles in a larger ring\n    remaining = n - (5 + ring_count)\n    for i in range(remaining):\n        angle = 2 * np.pi * i / remaining\n        r = 0.65  # Distance from center\n        centers[5+ring_count+i] = [0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)]\n        radii[5+ring_count+i] = 0.08\n    \n    return centers, radii\n\ndef initialize_variable_size_pattern():\n    \"\"\"\n    Initialize with a pattern that has variable-sized circles.\n    Larger circles in the center, smaller circles at the edges.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place a large circle in the center\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.15\n    \n    # Place medium circles in a ring around the center\n    inner_ring = 6\n    for i in range(inner_ring):\n        angle = 2 * np.pi * i / inner_ring\n        r = 0.25  # Distance from center\n        centers[1+i] = [0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)]\n        radii[1+i] = 0.11\n    \n    # Place smaller circles in a second ring\n    middle_ring = 10\n    for i in range(middle_ring):\n        angle = 2 * np.pi * i / middle_ring\n        r = 0.45  # Distance from center\n        centers[1+inner_ring+i] = [0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)]\n        radii[1+inner_ring+i] = 0.09\n    \n    # Place smallest circles in the outermost ring\n    outer_ring = n - (1 + inner_ring + middle_ring)\n    for i in range(outer_ring):\n        angle = 2 * np.pi * i / outer_ring\n        r = 0.7  # Distance from center\n        centers[1+inner_ring+middle_ring+i] = [0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)]\n        radii[1+inner_ring+middle_ring+i] = 0.07\n    \n    return centers, radii\n\ndef optimize_packing(centers, radii):\n    \"\"\"\n    Optimize the circle packing using a physics-based approach.\n    \"\"\"\n    n = centers.shape[0]\n    \n    # Parameters for optimization\n    iterations = 500\n    learning_rate = 0.01\n    repulsion_strength = 0.1\n    attraction_strength = 0.01\n    border_repulsion = 0.2\n    \n    # Normalize centers to ensure they're within the unit square\n    centers = np.clip(centers, 0.0, 1.0)\n    \n    for iteration in range(iterations):\n        # Calculate forces between circles\n        forces = np.zeros_like(centers)\n        \n        # Circle-circle interactions\n        for i in range(n):\n            for j in range(i+1, n):\n                # Vector from i to j\n                vec = centers[j] - centers[i]\n                dist = np.linalg.norm(vec)\n                \n                # Skip if circles are too far apart\n                if dist > 3 * (radii[i] + radii[j]):\n                    continue\n                \n                # Normalize direction vector\n                if dist > 1e-10:  # Avoid division by zero\n                    direction = vec / dist\n                else:\n                    direction = np.array([1.0, 0.0])  # Default direction if circles are at same position\n                \n                # Calculate overlap\n                overlap = radii[i] + radii[j] - dist\n                \n                # Apply repulsion if circles overlap\n                if overlap > 0:\n                    repulsion = repulsion_strength * overlap\n                    forces[i] -= direction * repulsion\n                    forces[j] += direction * repulsion\n                else:\n                    # Apply weak attraction if circles are close but not overlapping\n                    attraction = attraction_strength * (overlap)  # Negative overlap means gap\n                    forces[i] += direction * attraction\n                    forces[j] -= direction * attraction\n        \n        # Border forces to keep circles inside the unit square\n        for i in range(n):\n            # Left border\n            if centers[i, 0] < radii[i]:\n                forces[i, 0] += border_repulsion * (radii[i] - centers[i, 0])\n            \n            # Right border\n            if centers[i, 0] > 1.0 - radii[i]:\n                forces[i, 0] -= border_repulsion * (centers[i, 0] - (1.0 - radii[i]))\n            \n            # Bottom border\n            if centers[i, 1] < radii[i]:\n                forces[i, 1] += border_repulsion * (radii[i] - centers[i, 1])\n            \n            # Top border\n            if centers[i, 1] > 1.0 - radii[i]:\n                forces[i, 1] -= border_repulsion * (centers[i, 1] - (1.0 - radii[i]))\n        \n        # Update positions\n        centers += learning_rate * forces\n        \n        # Ensure centers stay within bounds\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Adjust radii based on available space\n        if iteration % 10 == 0:\n            radii = adjust_radii(centers, radii)\n        \n        # Reduce learning rate over time\n        learning_rate *= 0.998\n    \n    # Final adjustment of radii\n    radii = adjust_radii(centers, radii)\n    \n    return centers, radii\n\ndef adjust_radii(centers, radii):\n    \"\"\"\n    Adjust the radii of circles to maximize their size without overlapping.\n    \"\"\"\n    n = centers.shape[0]\n    new_radii = np.zeros(n)\n    \n    # Initialize with distance to borders\n    for i in range(n):\n        x, y = centers[i]\n        new_radii[i] = min(x, y, 1.0 - x, 1.0 - y)\n    \n    # Limit by distance to other circles\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r = max(0.001, dist - radii[j])  # Ensure positive radius\n                new_radii[i] = min(new_radii[i], max_r)\n    \n    # Blend with current radii for stability\n    blend_factor = 0.2\n    adjusted_radii = (1 - blend_factor) * radii + blend_factor * new_radii\n    \n    return adjusted_radii\n\ndef refine_packing(centers, radii):\n    \"\"\"\n    Final refinement stage using a more precise optimization approach.\n    \"\"\"\n    n = centers.shape[0]\n    \n    # Parameters for refinement\n    iterations = 200\n    learning_rate = 0.005\n    \n    for iteration in range(iterations):\n        # Calculate gradient for each circle\n        gradients = np.zeros_like(centers)\n        \n        # For each circle, try small movements in different directions\n        for i in range(n):\n            for dx, dy in [(0.001, 0), (-0.001, 0), (0, 0.001), (0, -0.001)]:\n                # Move circle slightly\n                centers[i, 0] += dx\n                centers[i, 1] += dy\n                \n                # Recalculate maximum possible radii\n                new_radii = compute_max_radii(centers)\n                sum_new = np.sum(new_radii)\n                \n                # Move circle back\n                centers[i, 0] -= dx\n                centers[i, 1] -= dy\n                \n                # Calculate gradient\n                gradients[i, 0] += dx * sum_new / 0.001\n                gradients[i, 1] += dy * sum_new / 0.001\n        \n        # Normalize gradients\n        norms = np.linalg.norm(gradients, axis=1)\n        mask = norms > 1e-10\n        gradients[mask] = gradients[mask] / norms[mask, np.newaxis]\n        \n        # Update positions\n        centers += learning_rate * gradients\n        \n        # Ensure centers stay within bounds\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Update radii\n        radii = compute_max_radii(centers)\n        \n        # Reduce learning rate\n        learning_rate *= 0.99\n    \n    # Final calculation of radii\n    radii = compute_max_radii(centers)\n    \n    return centers, radii\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position, ensuring no overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n    \n    # Limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1.0 - x, 1.0 - y)\n    \n    # Limit by distance to other circles\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    # Distribute the overlap proportionally\n                    total = radii[i] + radii[j]\n                    if total > 0:\n                        ratio = dist / total\n                        radii[i] = min(radii[i], ratio * radii[i])\n                        radii[j] = min(radii[j], ratio * radii[j])\n    \n    # One more pass to ensure no overlaps\n    for _ in range(3):\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if dist < radii[i] + radii[j]:\n                        # Adjust both radii to eliminate overlap\n                        overlap = radii[i] + radii[j] - dist\n                        radii[i] -= overlap / 2\n                        radii[j] -= overlap / 2\n    \n    # Ensure minimum radius\n    radii = np.maximum(radii, 0.001)\n    \n    return radii\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```"]}}}