{"id": "0175e097-c9be-40e7-b5f1-4c3a75caa6c1", "code": "# EVOLVE-BLOCK-START\n\"\"\"Optimized circle packing for n=26 circles in a unit square, using specialized mathematical patterns and advanced optimization techniques to maximize the sum of radii, targeting the theoretical optimal value of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Multiple specialized patterns for n=26 based on mathematical research\n    patterns = [\n        initialize_specialized_26,\n        initialize_hybrid_26,\n        initialize_variable_size_26,\n        initialize_corner_dominant_26,\n        initialize_asymmetric_26\n    ]\n    \n    start_total = time.time()\n    max_total_time = 120  # Total time budget in seconds\n    \n    for pattern_idx, pattern_func in enumerate(patterns):\n        # Set timeout for each pattern to avoid getting stuck\n        start_time = time.time()\n        max_pattern_time = 30  # seconds per pattern\n        \n        try:\n            centers, radii = pattern_func()\n            \n            # Ensure we have exactly 26 circles\n            if centers.shape[0] != n:\n                # Adjust to exactly n circles if needed\n                if centers.shape[0] > n:\n                    # Keep the n largest circles\n                    indices = np.argsort(radii)[-n:]\n                    centers = centers[indices]\n                    radii = radii[indices]\n                else:\n                    # Add more circles if needed\n                    extra_needed = n - centers.shape[0]\n                    extra_centers = np.random.rand(extra_needed, 2) * 0.8 + 0.1\n                    extra_radii = np.ones(extra_needed) * 0.05\n                    centers = np.vstack([centers, extra_centers])\n                    radii = np.concatenate([radii, extra_radii])\n            \n            # Ensure no initial overlaps or boundary violations\n            centers, radii = fix_constraints(centers, radii)\n            \n            # First optimization pass - quick optimization with basic parameters\n            centers, radii = optimize_packing(centers, radii, max_iter=100, ftol=1e-5)\n            \n            # Second optimization pass with basin hopping to escape local minima\n            centers, radii = optimize_with_basin_hopping(centers, radii, n_iter=10, T=0.1)\n            \n            # Final refinement\n            centers, radii = optimize_packing(centers, radii, max_iter=200, ftol=1e-8)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n            \n            # Print progress\n            # print(f\"Pattern {pattern_idx+1}: sum_radii = {sum_radii:.6f}, time = {time.time() - start_time:.2f}s\")\n                \n        except Exception as e:\n            # print(f\"Error with pattern {pattern_idx+1}: {str(e)}\")\n            continue\n            \n        # Check if we've exceeded the time limit for this pattern\n        if time.time() - start_time > max_pattern_time:\n            # print(f\"Pattern {pattern_idx+1} reached time limit\")\n            pass\n            \n        # Check if we've exceeded the total time budget\n        if time.time() - start_total > max_total_time:\n            # print(\"Total time budget reached\")\n            break\n    \n    # Final refinement on the best result\n    if best_centers is not None:\n        # Try one more optimization with higher precision\n        try:\n            best_centers, best_radii = optimize_packing(best_centers, best_radii, max_iter=300, ftol=1e-9)\n            best_sum = np.sum(best_radii)\n        except:\n            pass\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses variable-sized circles with larger ones in strategic positions.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.13\n    \n    # Inner ring of 6 circles\n    inner_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = inner_radius\n    \n    # Middle ring of 12 circles\n    middle_radius = 0.09\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12  # offset to stagger with inner ring\n        dist = 0.5 - middle_radius - 0.01  # Position closer to boundary\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.12\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n    \n    # Edge centers (3 circles)\n    edge_radius = 0.105\n    centers[23] = [0.5, edge_radius]\n    centers[24] = [edge_radius, 0.5]\n    centers[25] = [1-edge_radius, 0.5]\n    radii[23:26] = edge_radius\n    \n    return centers, radii\n\ndef initialize_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern that combines hexagonal packing with edge optimization.\n    This pattern is based on the mathematical theory that optimal packings often combine\n    different local arrangements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Four corners - larger circles\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Four edge midpoints - medium circles\n    edge_radius = 0.11\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Center circle - largest\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.135\n    \n    # Inner ring - 8 circles\n    inner_radius = 0.1\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.002\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n    \n    # Outer positions - 9 circles\n    outer_radius = 0.085\n    positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.25, 0.5), (0.75, 0.5), (0.33, 0.33), (0.67, 0.33), (0.67, 0.67)\n    ]\n    \n    for i, pos in enumerate(positions):\n        centers[17+i] = pos\n        radii[17+i] = outer_radius\n    \n    return centers, radii\n\ndef initialize_variable_size_26():\n    \"\"\"\n    Initialize with a pattern that uses significantly different sized circles.\n    Research suggests that optimal packings often have a mix of different sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Large central circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.14\n    \n    # Four large corner circles\n    corner_radius = 0.13\n    centers[1] = [corner_radius, corner_radius]\n    centers[2] = [1-corner_radius, corner_radius]\n    centers[3] = [corner_radius, 1-corner_radius]\n    centers[4] = [1-corner_radius, 1-corner_radius]\n    radii[1:5] = corner_radius\n    \n    # Medium circles along edges\n    medium_radius = 0.11\n    positions = [\n        (0.5, medium_radius), (0.5, 1-medium_radius),\n        (medium_radius, 0.5), (1-medium_radius, 0.5)\n    ]\n    \n    for i, pos in enumerate(positions):\n        centers[5+i] = pos\n        radii[5+i] = medium_radius\n    \n    # Small circles in a ring around the center\n    small_radius = 0.095\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + small_radius + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = small_radius\n    \n    # Tiny circles to fill gaps\n    tiny_radius = 0.075\n    remaining_positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.3, 0.5), (0.7, 0.5), (0.5, 0.3), (0.5, 0.7), (0.35, 0.35)\n    ]\n    \n    for i, pos in enumerate(remaining_positions):\n        if i + 17 < n:\n            centers[17+i] = pos\n            radii[17+i] = tiny_radius\n    \n    return centers, radii\n\ndef initialize_corner_dominant_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes larger circles in the corners\n    and along the edges, with smaller circles filling the interior.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Larger corner circles\n    corner_radius = 0.135\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Edge circles\n    edge_radius = 0.115\n    edge_positions = [\n        (0.5, edge_radius), (0.5, 1-edge_radius),\n        (edge_radius, 0.5), (1-edge_radius, 0.5),\n        (0.25, edge_radius), (0.75, edge_radius),\n        (edge_radius, 0.25), (edge_radius, 0.75)\n    ]\n    \n    for i, pos in enumerate(edge_positions):\n        centers[4+i] = pos\n        radii[4+i] = edge_radius\n    \n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.125\n    \n    # Fill remaining space with smaller circles\n    small_radius = 0.09\n    remaining_positions = [\n        (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),\n        (0.3, 0.5), (0.7, 0.5), (0.5, 0.3), (0.5, 0.7),\n        (0.4, 0.4), (0.6, 0.4), (0.4, 0.6), (0.6, 0.6),\n        (0.35, 0.65)\n    ]\n    \n    for i, pos in enumerate(remaining_positions):\n        if i + 13 < n:\n            centers[13+i] = pos\n            radii[13+i] = small_radius\n    \n    return centers, radii\n\ndef initialize_asymmetric_26():\n    \"\"\"\n    Initialize with an asymmetric pattern. Sometimes breaking symmetry\n    allows for better packing efficiency by avoiding local optima.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Distribute circles with varying sizes\n    sizes = [0.13, 0.125, 0.12, 0.115, 0.11, 0.105, 0.1, 0.095, 0.09, 0.085]\n    \n    # Place larger circles first in strategic positions\n    positions = [\n        (0.13, 0.13),  # bottom left\n        (0.87, 0.13),  # bottom right\n        (0.13, 0.87),  # top left\n        (0.87, 0.87),  # top right\n        (0.5, 0.5),    # center\n        (0.5, 0.13),   # bottom middle\n        (0.5, 0.87),   # top middle\n        (0.13, 0.5),   # left middle\n        (0.87, 0.5),   # right middle\n    ]\n    \n    # Add more positions with slight asymmetry\n    for x in [0.25, 0.4, 0.6, 0.75]:\n        for y in [0.25, 0.4, 0.6, 0.75]:\n            # Add some noise to break symmetry\n            noise_x = np.random.uniform(-0.03, 0.03)\n            noise_y = np.random.uniform(-0.03, 0.03)\n            positions.append((x + noise_x, y + noise_y))\n    \n    # Ensure we have enough positions\n    while len(positions) < n:\n        x, y = np.random.uniform(0.1, 0.9, 2)\n        positions.append((x, y))\n    \n    # Assign positions and sizes\n    for i in range(n):\n        centers[i] = positions[i]\n        # Cycle through sizes for variety\n        radii[i] = sizes[i % len(sizes)]\n    \n    return centers, radii\n\ndef optimize_packing(centers, radii, max_iter=200, ftol=1e-7):\n    \"\"\"\n    Optimize circle positions and radii using constrained optimization.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        max_iter: Maximum number of iterations\n        ftol: Tolerance for convergence\n        \n    Returns:\n        Optimized centers and radii\n    \"\"\"\n    n = len(centers)\n    \n    # Combine centers and radii into a single parameter vector\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    def objective(x):\n        \"\"\"Objective function: negative sum of radii + penalty for constraints\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        \n        # Calculate sum of radii (to be maximized)\n        sum_radii = np.sum(current_radii)\n        \n        # Calculate penalty for constraints\n        penalty = calculate_penalty(current_centers, current_radii)\n        \n        # Return negative sum (since we're minimizing) plus penalty\n        return -sum_radii + penalty\n    \n    # Bounds for optimization\n    # Centers must be within [0,1], radii within reasonable limits\n    bounds = []\n    for i in range(n):\n        # x-coordinate bounds\n        bounds.append((0.0, 1.0))\n        # y-coordinate bounds\n        bounds.append((0.0, 1.0))\n    \n    # Radii bounds - allow a wide range but prevent tiny or huge circles\n    for i in range(n):\n        bounds.append((0.05, 0.15))\n    \n    # Run the optimization\n    result = minimize(\n        objective,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': max_iter, 'ftol': ftol}\n    )\n    \n    # Extract optimized centers and radii\n    optimized_centers = result.x[:2*n].reshape((n, 2))\n    optimized_radii = result.x[2*n:]\n    \n    # Ensure circles are within bounds and don't overlap\n    optimized_centers, optimized_radii = fix_constraints(optimized_centers, optimized_radii)\n    \n    return optimized_centers, optimized_radii\n\ndef optimize_with_basin_hopping(centers, radii, n_iter=10, T=0.1):\n    \"\"\"\n    Use basin hopping to escape local minima in the optimization.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        n_iter: Number of basin hopping iterations\n        T: Temperature parameter for basin hopping\n        \n    Returns:\n        Optimized centers and radii\n    \"\"\"\n    n = len(centers)\n    \n    # Combine centers and radii into a single parameter vector\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    def objective(x):\n        \"\"\"Objective function: negative sum of radii + penalty for constraints\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        \n        # Calculate sum of radii (to be maximized)\n        sum_radii = np.sum(current_radii)\n        \n        # Calculate penalty for constraints\n        penalty = calculate_penalty(current_centers, current_radii)\n        \n        # Return negative sum (since we're minimizing) plus penalty\n        return -sum_radii + penalty\n    \n    # Bounds for optimization\n    bounds = []\n    for i in range(n):\n        bounds.append((0.0, 1.0))  # x-coordinate\n        bounds.append((0.0, 1.0))  # y-coordinate\n    for i in range(n):\n        bounds.append((0.05, 0.15))  # radii\n    \n    # Custom step function for basin hopping\n    def take_step(x):\n        # Create a copy of the current solution\n        new_x = x.copy()\n        \n        # Randomly choose whether to perturb positions or radii\n        if np.random.random() < 0.7:  # 70% chance to perturb positions\n            # Select a random circle\n            circle_idx = np.random.randint(0, n)\n            \n            # Perturb its position slightly\n            pos_idx = circle_idx * 2\n            new_x[pos_idx:pos_idx+2] += np.random.normal(0, 0.02, 2)\n            \n            # Ensure it stays within bounds\n            new_x[pos_idx:pos_idx+2] = np.clip(new_x[pos_idx:pos_idx+2], 0, 1)\n        else:  # 30% chance to perturb radii\n            # Select a random circle\n            circle_idx = np.random.randint(0, n)\n            \n            # Perturb its radius slightly\n            rad_idx = 2*n + circle_idx\n            new_x[rad_idx] += np.random.normal(0, 0.005)\n            \n            # Ensure it stays within bounds\n            new_x[rad_idx] = np.clip(new_x[rad_idx], 0.05, 0.15)\n        \n        return new_x\n    \n    # Run basin hopping\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": bounds,\n        \"options\": {\"maxiter\": 100, \"ftol\": 1e-6}\n    }\n    \n    result = basinhopping(\n        objective,\n        x0,\n        niter=n_iter,\n        T=T,\n        take_step=take_step,\n        minimizer_kwargs=minimizer_kwargs,\n        stepsize=0.1\n    )\n    \n    # Extract optimized centers and radii\n    optimized_centers = result.x[:2*n].reshape((n, 2))\n    optimized_radii = result.x[2*n:]\n    \n    # Ensure circles are within bounds and don't overlap\n    optimized_centers, optimized_radii = fix_constraints(optimized_centers, optimized_radii)\n    \n    return optimized_centers, optimized_radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for constraint violations:\n    1. Circles must be within the unit square\n    2. Circles must not overlap\n    \n    Uses a smooth, differentiable penalty function with graduated severity\n    based on the degree of violation.\n    \"\"\"\n    n = len(radii)\n    penalty = 0.0\n    \n    # Penalty factors - higher values enforce constraints more strictly\n    boundary_factor = 1500.0\n    overlap_factor = 1500.0\n    \n    # 1. Penalty for circles outside the unit square\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        \n        # Left boundary: x - r >= 0\n        if x - r < 0:\n            violation = -(x - r)\n            penalty += boundary_factor * violation**2\n        \n        # Right boundary: x + r <= 1\n        if x + r > 1:\n            violation = (x + r) - 1\n            penalty += boundary_factor * violation**2\n        \n        # Bottom boundary: y - r >= 0\n        if y - r < 0:\n            violation = -(y - r)\n            penalty += boundary_factor * violation**2\n        \n        # Top boundary: y + r <= 1\n        if y + r > 1:\n            violation = (y + r) - 1\n            penalty += boundary_factor * violation**2\n    \n    # 2. Penalty for overlapping circles - use vectorized operations for efficiency\n    for i in range(n):\n        # Calculate distances to all other circles at once\n        diff_x = centers[i, 0] - centers[:, 0]\n        diff_y = centers[i, 1] - centers[:, 1]\n        distances = np.sqrt(diff_x**2 + diff_y**2)\n        \n        # Minimum required distances\n        min_distances = radii[i] + radii\n        \n        # Find overlapping circles (excluding self)\n        mask = (distances < min_distances) & (distances > 0)  # distances > 0 excludes self\n        \n        if np.any(mask):\n            violations = min_distances[mask] - distances[mask]\n            # Apply quadratic penalty\n            penalty += overlap_factor * np.sum(violations**2)\n    \n    return penalty\n\ndef fix_constraints(centers, radii):\n    \"\"\"\n    Ensure all constraints are satisfied by making minimal adjustments.\n    This is a post-processing step to fix any remaining constraint violations.\n    \"\"\"\n    n = len(radii)\n    \n    # 1. Fix boundary constraints\n    for i in range(n):\n        # Ensure circle is within x-bounds\n        if centers[i, 0] - radii[i] < 0:\n            centers[i, 0] = radii[i]\n        if centers[i, 0] + radii[i] > 1:\n            centers[i, 0] = 1 - radii[i]\n            \n        # Ensure circle is within y-bounds\n        if centers[i, 1] - radii[i] < 0:\n            centers[i, 1] = radii[i]\n        if centers[i, 1] + radii[i] > 1:\n            centers[i, 1] = 1 - radii[i]\n    \n    # 2. Fix overlap constraints (iterative adjustment)\n    max_iterations = 50\n    for _ in range(max_iterations):\n        overlap_found = False\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                # Distance between centers\n                dist_vector = centers[i] - centers[j]\n                dist = np.linalg.norm(dist_vector)\n                min_dist = radii[i] + radii[j]\n                \n                # If circles overlap\n                if dist < min_dist and dist > 1e-10:  # Avoid division by zero\n                    overlap_found = True\n                    \n                    # Calculate unit vector from j to i\n                    unit_vector = dist_vector / dist\n                    \n                    # Move circles apart proportionally to their radii\n                    overlap = min_dist - dist\n                    move_i = overlap * 0.55 * (radii[i] / (radii[i] + radii[j]))\n                    move_j = overlap * 0.55 * (radii[j] / (radii[i] + radii[j]))\n                    \n                    centers[i] += move_i * unit_vector\n                    centers[j] -= move_j * unit_vector\n                    \n                    # Re-check boundary constraints\n                    for k in [i, j]:\n                        if centers[k, 0] - radii[k] < 0:\n                            centers[k, 0] = radii[k]\n                        if centers[k, 0] + radii[k] > 1:\n                            centers[k, 0] = 1 - radii[k]\n                        if centers[k, 1] - radii[k] < 0:\n                            centers[k, 1] = radii[k]\n                        if centers[k, 1] + radii[k] > 1:\n                            centers[k, 1] = 1 - radii[k]\n        \n        # If no overlaps found, we're done\n        if not overlap_found:\n            break\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "d8d959be-2833-4a45-a962-171d9b61e2c2", "generation": 5, "timestamp": 1750926033.819826, "iteration_found": 27, "metrics": {"validity": 0.0, "sum_radii": 0.0, "target_ratio": 0.0, "combined_score": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "sum_radii": 0.0, "target_ratio": 0.0, "combined_score": 0.0}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.645 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.636, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - validity: 0.0000\n- sum_radii: 0.0000\n- target_ratio: 0.0000\n- combined_score: 0.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: validity, sum_radii, target_ratio, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6360, target_ratio: 1.0004, combined_score: 1.0004, eval_time: 43.1799\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6228, target_ratio: 0.9954, combined_score: 0.9954, eval_time: 117.8238\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6073, target_ratio: 0.9895, combined_score: 0.9895, eval_time: 132.5911\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 9.7633)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6360), Performs well on target_ratio (1.0004), Performs well on combined_score (1.0004), Performs well on eval_time (43.1799)\n\n\n### Program 2 (Score: 27.6355)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6073), Performs well on target_ratio (0.9895), Performs well on combined_score (0.9895), Performs well on eval_time (132.5911)\n\n\n### Program 3 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on error (Program execution failed: index 26 is out of bounds for axis 0 with size 26)\n\n\n### Program 4 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy. It uses a simulated annealing approach for escaping local minima and introduces a scaling factor to the penalty function to better handle different stages of the optimization. Further optimizations include a refined custom step function for basin hopping and dynamic temperature adjustments.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport logging\nimport random\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy. It uses a simulated annealing approach for escaping local minima and introduces a scaling factor to the penalty function to better handle different stages of the optimization. Further optimizations include a refined custom step function for basin hopping and dynamic temperature adjustments.  This version implements a more efficient penalty calculation and parameter tuning for the basin hopping optimizer.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport logging\n# ... (truncated)\n```\nKey features: Alternative approach to stage1_passed, Alternative approach to error\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimized circle packing for n=26 circles in a unit square, using specialized mathematical patterns and efficient optimization techniques to maximize the sum of radii.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Use a specialized pattern for n=26 based on mathematical research\n    # This is a critical pattern identified in circle packing literature\n    patterns = [\n        initialize_specialized_26,\n        initialize_hybrid_26,\n        initialize_hexagonal_26\n    ]\n    \n    for pattern_func in patterns:\n        # Set timeout for each pattern to avoid getting stuck\n        start_time = time.time()\n        max_time = 60  # seconds\n        \n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern returned {centers.shape[0]} circles instead of {n}\"\n        \n        # First optimization pass - quick optimization with basic parameters\n        centers, radii = optimize_packing(centers, radii, max_iter=100, ftol=1e-6)\n        \n        # Second optimization pass - refined optimization with tighter parameters\n        centers, radii = optimize_packing(centers, radii, max_iter=200, ftol=1e-8)\n        \n        # Keep the best result\n        sum_radii = np.sum(radii)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n            \n        # Check if we've exceeded the time limit\n        if time.time() - start_time > max_time:\n            break\n    \n    # Final refinement on the best result\n    if best_centers is not None:\n        best_centers, best_radii = optimize_packing(best_centers, best_radii, max_iter=300, ftol=1e-9)\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses variable-sized circles with larger ones in strategic positions.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.13\n    \n    # Inner ring of 6 circles\n    inner_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = inner_radius\n    \n    # Middle ring of 12 circles\n    middle_radius = 0.09\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12  # offset to stagger with inner ring\n        dist = 0.5 - middle_radius - 0.01  # Position closer to boundary\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.12\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n    \n    # Edge centers (3 circles)\n    edge_radius = 0.105\n    centers[23] = [0.5, edge_radius]\n    centers[24] = [edge_radius, 0.5]\n    centers[25] = [1-edge_radius, 0.5]\n    radii[23:26] = edge_radius\n    \n    return centers, radii\n\ndef initialize_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern that combines hexagonal packing with edge optimization.\n    This pattern is based on the mathematical theory that optimal packings often combine\n    different local arrangements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Four corners - larger circles\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Four edge midpoints - medium circles\n    edge_radius = 0.11\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Center circle - largest\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.135\n    \n    # Inner ring - 8 circles\n    inner_radius = 0.1\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.002\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n    \n    # Outer positions - 9 circles\n    outer_radius = 0.085\n    positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.25, 0.5), (0.75, 0.5), (0.33, 0.33), (0.67, 0.33), (0.67, 0.67)\n    ]\n    \n    for i, pos in enumerate(positions):\n        centers[17+i] = pos\n        radii[17+i] = outer_radius\n    \n    return centers, radii\n\ndef initialize_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern which is known to be efficient for circle packing.\n    This implementation uses variable-sized circles with larger ones in key positions.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Hexagonal grid parameters\n    hex_radius = 0.095\n    dx = hex_radius * 2 + 0.002\n    dy = hex_radius * np.sqrt(3) + 0.002\n    \n    # Create hexagonal grid positions\n    positions = []\n    for i in range(6):\n        for j in range(6):\n            # Offset every other row\n            offset = (j % 2) * (dx / 2)\n            x = 0.1 + offset + i * dx\n            y = 0.1 + j * dy\n            if 0 <= x <= 1 and 0 <= y <= 1:\n                positions.append((x, y))\n    \n    # Sort positions by distance from center (0.5, 0.5)\n    center = np.array([0.5, 0.5])\n    positions.sort(key=lambda pos: np.linalg.norm(np.array(pos) - center))\n    \n    # Take the first n positions\n    for i in range(min(n, len(positions))):\n        centers[i] = positions[i]\n        \n        # Assign variable radii based on position\n        dist_from_center = np.linalg.norm(centers[i] - center)\n        if i == 0:  # Center circle\n            radii[i] = 0.13\n        elif dist_from_center < 0.3:  # Inner ring\n            radii[i] = 0.11\n        elif i < 4:  # Corner circles\n            radii[i] = 0.12\n        else:  # Other circles\n            radii[i] = 0.09\n    \n    # Ensure we have exactly n circles\n    if len(positions) < n:\n        remaining = n - len(positions)\n        for i in range(remaining):\n            # Add additional circles in any gaps\n            centers[len(positions) + i] = [0.3 + 0.2 * i, 0.3 + 0.1 * i]\n            radii[len(positions) + i] = 0.08\n    \n    return centers, radii\n\ndef optimize_packing(centers, radii, max_iter=200, ftol=1e-7):\n    \"\"\"\n    Optimize circle positions and radii using constrained optimization.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        max_iter: Maximum number of iterations\n        ftol: Tolerance for convergence\n        \n    Returns:\n        Optimized centers and radii\n    \"\"\"\n    n = len(centers)\n    \n    # Combine centers and radii into a single parameter vector\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    def objective(x):\n        \"\"\"Objective function: negative sum of radii + penalty for constraints\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        \n        # Calculate sum of radii (to be maximized)\n        sum_radii = np.sum(current_radii)\n        \n        # Calculate penalty for constraints\n        penalty = calculate_penalty(current_centers, current_radii)\n        \n        # Return negative sum (since we're minimizing) plus penalty\n        return -sum_radii + penalty\n    \n    # Bounds for optimization\n    # Centers must be within [0,1], radii within reasonable limits\n    bounds = []\n    for i in range(n):\n        # x-coordinate bounds\n        bounds.append((0.0, 1.0))\n        # y-coordinate bounds\n        bounds.append((0.0, 1.0))\n    \n    # Radii bounds - allow a wide range but prevent tiny or huge circles\n    for i in range(n):\n        bounds.append((0.05, 0.15))\n    \n    # Run the optimization\n    result = minimize(\n        objective,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': max_iter, 'ftol': ftol}\n    )\n    \n    # Extract optimized centers and radii\n    optimized_centers = result.x[:2*n].reshape((n, 2))\n    optimized_radii = result.x[2*n:]\n    \n    # Ensure circles are within bounds and don't overlap\n    optimized_centers, optimized_radii = fix_constraints(optimized_centers, optimized_radii)\n    \n    return optimized_centers, optimized_radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for constraint violations:\n    1. Circles must be within the unit square\n    2. Circles must not overlap\n    \n    Uses a smooth, differentiable penalty function with graduated severity\n    based on the degree of violation.\n    \"\"\"\n    n = len(radii)\n    penalty = 0.0\n    \n    # Penalty factors - higher values enforce constraints more strictly\n    boundary_factor = 1000.0\n    overlap_factor = 1000.0\n    \n    # 1. Penalty for circles outside the unit square\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        \n        # Left boundary: x - r >= 0\n        if x - r < 0:\n            violation = -(x - r)\n            penalty += boundary_factor * violation**2\n        \n        # Right boundary: x + r <= 1\n        if x + r > 1:\n            violation = (x + r) - 1\n            penalty += boundary_factor * violation**2\n        \n        # Bottom boundary: y - r >= 0\n        if y - r < 0:\n            violation = -(y - r)\n            penalty += boundary_factor * violation**2\n        \n        # Top boundary: y + r <= 1\n        if y + r > 1:\n            violation = (y + r) - 1\n            penalty += boundary_factor * violation**2\n    \n    # 2. Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            # Distance between centers\n            dist = np.linalg.norm(centers[i] - centers[j])\n            # Minimum required distance\n            min_dist = radii[i] + radii[j]\n            \n            # If circles overlap\n            if dist < min_dist:\n                violation = min_dist - dist\n                # Penalty increases quadratically with violation\n                penalty += overlap_factor * violation**2\n    \n    return penalty\n\ndef fix_constraints(centers, radii):\n    \"\"\"\n    Ensure all constraints are satisfied by making minimal adjustments.\n    This is a post-processing step to fix any remaining constraint violations.\n    \"\"\"\n    n = len(radii)\n    \n    # 1. Fix boundary constraints\n    for i in range(n):\n        # Ensure circle is within x-bounds\n        if centers[i, 0] - radii[i] < 0:\n            centers[i, 0] = radii[i]\n        if centers[i, 0] + radii[i] > 1:\n            centers[i, 0] = 1 - radii[i]\n            \n        # Ensure circle is within y-bounds\n        if centers[i, 1] - radii[i] < 0:\n            centers[i, 1] = radii[i]\n        if centers[i, 1] + radii[i] > 1:\n            centers[i, 1] = 1 - radii[i]\n    \n    # 2. Fix overlap constraints (iterative adjustment)\n    max_iterations = 50\n    for _ in range(max_iterations):\n        overlap_found = False\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                # Distance between centers\n                dist_vector = centers[i] - centers[j]\n                dist = np.linalg.norm(dist_vector)\n                min_dist = radii[i] + radii[j]\n                \n                # If circles overlap\n                if dist < min_dist and dist > 1e-10:  # Avoid division by zero\n                    overlap_found = True\n                    \n                    # Calculate unit vector from j to i\n                    unit_vector = dist_vector / dist\n                    \n                    # Move circles apart proportionally to their radii\n                    overlap = min_dist - dist\n                    move_i = overlap * 0.55 * (radii[i] / (radii[i] + radii[j]))\n                    move_j = overlap * 0.55 * (radii[j] / (radii[i] + radii[j]))\n                    \n                    centers[i] += move_i * unit_vector\n                    centers[j] -= move_j * unit_vector\n                    \n                    # Re-check boundary constraints\n                    for k in [i, j]:\n                        if centers[k, 0] - radii[k] < 0:\n                            centers[k, 0] = radii[k]\n                        if centers[k, 0] + radii[k] > 1:\n                            centers[k, 0] = 1 - radii[k]\n                        if centers[k, 1] - radii[k] < 0:\n                            centers[k, 1] = radii[k]\n                        if centers[k, 1] + radii[k] > 1:\n                            centers[k, 1] = 1 - radii[k]\n        \n        # If no overlaps found, we're done\n        if not overlap_found:\n            break\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["Looking at the current program and its performance metrics, I see that the most recent attempt has regressed to a score of 0.0000 across all metrics. The program needs significant improvements to reach the target sum of radii of 2.645 for packing 26 circles in a unit square. I'll rewrite the program with more advanced optimization techniques and specialized circle arrangements.\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimized circle packing for n=26 circles in a unit square, using specialized mathematical patterns and advanced optimization techniques to maximize the sum of radii, targeting the theoretical optimal value of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Multiple specialized patterns for n=26 based on mathematical research\n    patterns = [\n        initialize_specialized_26,\n        initialize_hybrid_26,\n        initialize_variable_size_26,\n        initialize_corner_dominant_26,\n        initialize_asymmetric_26\n    ]\n    \n    start_total = time.time()\n    max_total_time = 120  # Total time budget in seconds\n    \n    for pattern_idx, pattern_func in enumerate(patterns):\n        # Set timeout for each pattern to avoid getting stuck\n        start_time = time.time()\n        max_pattern_time = 30  # seconds per pattern\n        \n        try:\n            centers, radii = pattern_func()\n            \n            # Ensure we have exactly 26 circles\n            if centers.shape[0] != n:\n                # Adjust to exactly n circles if needed\n                if centers.shape[0] > n:\n                    # Keep the n largest circles\n                    indices = np.argsort(radii)[-n:]\n                    centers = centers[indices]\n                    radii = radii[indices]\n                else:\n                    # Add more circles if needed\n                    extra_needed = n - centers.shape[0]\n                    extra_centers = np.random.rand(extra_needed, 2) * 0.8 + 0.1\n                    extra_radii = np.ones(extra_needed) * 0.05\n                    centers = np.vstack([centers, extra_centers])\n                    radii = np.concatenate([radii, extra_radii])\n            \n            # Ensure no initial overlaps or boundary violations\n            centers, radii = fix_constraints(centers, radii)\n            \n            # First optimization pass - quick optimization with basic parameters\n            centers, radii = optimize_packing(centers, radii, max_iter=100, ftol=1e-5)\n            \n            # Second optimization pass with basin hopping to escape local minima\n            centers, radii = optimize_with_basin_hopping(centers, radii, n_iter=10, T=0.1)\n            \n            # Final refinement\n            centers, radii = optimize_packing(centers, radii, max_iter=200, ftol=1e-8)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n            \n            # Print progress\n            # print(f\"Pattern {pattern_idx+1}: sum_radii = {sum_radii:.6f}, time = {time.time() - start_time:.2f}s\")\n                \n        except Exception as e:\n            # print(f\"Error with pattern {pattern_idx+1}: {str(e)}\")\n            continue\n            \n        # Check if we've exceeded the time limit for this pattern\n        if time.time() - start_time > max_pattern_time:\n            # print(f\"Pattern {pattern_idx+1} reached time limit\")\n            pass\n            \n        # Check if we've exceeded the total time budget\n        if time.time() - start_total > max_total_time:\n            # print(\"Total time budget reached\")\n            break\n    \n    # Final refinement on the best result\n    if best_centers is not None:\n        # Try one more optimization with higher precision\n        try:\n            best_centers, best_radii = optimize_packing(best_centers, best_radii, max_iter=300, ftol=1e-9)\n            best_sum = np.sum(best_radii)\n        except:\n            pass\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses variable-sized circles with larger ones in strategic positions.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.13\n    \n    # Inner ring of 6 circles\n    inner_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = inner_radius\n    \n    # Middle ring of 12 circles\n    middle_radius = 0.09\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12  # offset to stagger with inner ring\n        dist = 0.5 - middle_radius - 0.01  # Position closer to boundary\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.12\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n    \n    # Edge centers (3 circles)\n    edge_radius = 0.105\n    centers[23] = [0.5, edge_radius]\n    centers[24] = [edge_radius, 0.5]\n    centers[25] = [1-edge_radius, 0.5]\n    radii[23:26] = edge_radius\n    \n    return centers, radii\n\ndef initialize_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern that combines hexagonal packing with edge optimization.\n    This pattern is based on the mathematical theory that optimal packings often combine\n    different local arrangements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Four corners - larger circles\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Four edge midpoints - medium circles\n    edge_radius = 0.11\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Center circle - largest\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.135\n    \n    # Inner ring - 8 circles\n    inner_radius = 0.1\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.002\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n    \n    # Outer positions - 9 circles\n    outer_radius = 0.085\n    positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.25, 0.5), (0.75, 0.5), (0.33, 0.33), (0.67, 0.33), (0.67, 0.67)\n    ]\n    \n    for i, pos in enumerate(positions):\n        centers[17+i] = pos\n        radii[17+i] = outer_radius\n    \n    return centers, radii\n\ndef initialize_variable_size_26():\n    \"\"\"\n    Initialize with a pattern that uses significantly different sized circles.\n    Research suggests that optimal packings often have a mix of different sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Large central circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.14\n    \n    # Four large corner circles\n    corner_radius = 0.13\n    centers[1] = [corner_radius, corner_radius]\n    centers[2] = [1-corner_radius, corner_radius]\n    centers[3] = [corner_radius, 1-corner_radius]\n    centers[4] = [1-corner_radius, 1-corner_radius]\n    radii[1:5] = corner_radius\n    \n    # Medium circles along edges\n    medium_radius = 0.11\n    positions = [\n        (0.5, medium_radius), (0.5, 1-medium_radius),\n        (medium_radius, 0.5), (1-medium_radius, 0.5)\n    ]\n    \n    for i, pos in enumerate(positions):\n        centers[5+i] = pos\n        radii[5+i] = medium_radius\n    \n    # Small circles in a ring around the center\n    small_radius = 0.095\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + small_radius + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = small_radius\n    \n    # Tiny circles to fill gaps\n    tiny_radius = 0.075\n    remaining_positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.3, 0.5), (0.7, 0.5), (0.5, 0.3), (0.5, 0.7), (0.35, 0.35)\n    ]\n    \n    for i, pos in enumerate(remaining_positions):\n        if i + 17 < n:\n            centers[17+i] = pos\n            radii[17+i] = tiny_radius\n    \n    return centers, radii\n\ndef initialize_corner_dominant_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes larger circles in the corners\n    and along the edges, with smaller circles filling the interior.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Larger corner circles\n    corner_radius = 0.135\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Edge circles\n    edge_radius = 0.115\n    edge_positions = [\n        (0.5, edge_radius), (0.5, 1-edge_radius),\n        (edge_radius, 0.5), (1-edge_radius, 0.5),\n        (0.25, edge_radius), (0.75, edge_radius),\n        (edge_radius, 0.25), (edge_radius, 0.75)\n    ]\n    \n    for i, pos in enumerate(edge_positions):\n        centers[4+i] = pos\n        radii[4+i] = edge_radius\n    \n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.125\n    \n    # Fill remaining space with smaller circles\n    small_radius = 0.09\n    remaining_positions = [\n        (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),\n        (0.3, 0.5), (0.7, 0.5), (0.5, 0.3), (0.5, 0.7),\n        (0.4, 0.4), (0.6, 0.4), (0.4, 0.6), (0.6, 0.6),\n        (0.35, 0.65)\n    ]\n    \n    for i, pos in enumerate(remaining_positions):\n        if i + 13 < n:\n            centers[13+i] = pos\n            radii[13+i] = small_radius\n    \n    return centers, radii\n\ndef initialize_asymmetric_26():\n    \"\"\"\n    Initialize with an asymmetric pattern. Sometimes breaking symmetry\n    allows for better packing efficiency by avoiding local optima.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Distribute circles with varying sizes\n    sizes = [0.13, 0.125, 0.12, 0.115, 0.11, 0.105, 0.1, 0.095, 0.09, 0.085]\n    \n    # Place larger circles first in strategic positions\n    positions = [\n        (0.13, 0.13),  # bottom left\n        (0.87, 0.13),  # bottom right\n        (0.13, 0.87),  # top left\n        (0.87, 0.87),  # top right\n        (0.5, 0.5),    # center\n        (0.5, 0.13),   # bottom middle\n        (0.5, 0.87),   # top middle\n        (0.13, 0.5),   # left middle\n        (0.87, 0.5),   # right middle\n    ]\n    \n    # Add more positions with slight asymmetry\n    for x in [0.25, 0.4, 0.6, 0.75]:\n        for y in [0.25, 0.4, 0.6, 0.75]:\n            # Add some noise to break symmetry\n            noise_x = np.random.uniform(-0.03, 0.03)\n            noise_y = np.random.uniform(-0.03, 0.03)\n            positions.append((x + noise_x, y + noise_y))\n    \n    # Ensure we have enough positions\n    while len(positions) < n:\n        x, y = np.random.uniform(0.1, 0.9, 2)\n        positions.append((x, y))\n    \n    # Assign positions and sizes\n    for i in range(n):\n        centers[i] = positions[i]\n        # Cycle through sizes for variety\n        radii[i] = sizes[i % len(sizes)]\n    \n    return centers, radii\n\ndef optimize_packing(centers, radii, max_iter=200, ftol=1e-7):\n    \"\"\"\n    Optimize circle positions and radii using constrained optimization.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        max_iter: Maximum number of iterations\n        ftol: Tolerance for convergence\n        \n    Returns:\n        Optimized centers and radii\n    \"\"\"\n    n = len(centers)\n    \n    # Combine centers and radii into a single parameter vector\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    def objective(x):\n        \"\"\"Objective function: negative sum of radii + penalty for constraints\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        \n        # Calculate sum of radii (to be maximized)\n        sum_radii = np.sum(current_radii)\n        \n        # Calculate penalty for constraints\n        penalty = calculate_penalty(current_centers, current_radii)\n        \n        # Return negative sum (since we're minimizing) plus penalty\n        return -sum_radii + penalty\n    \n    # Bounds for optimization\n    # Centers must be within [0,1], radii within reasonable limits\n    bounds = []\n    for i in range(n):\n        # x-coordinate bounds\n        bounds.append((0.0, 1.0))\n        # y-coordinate bounds\n        bounds.append((0.0, 1.0))\n    \n    # Radii bounds - allow a wide range but prevent tiny or huge circles\n    for i in range(n):\n        bounds.append((0.05, 0.15))\n    \n    # Run the optimization\n    result = minimize(\n        objective,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': max_iter, 'ftol': ftol}\n    )\n    \n    # Extract optimized centers and radii\n    optimized_centers = result.x[:2*n].reshape((n, 2))\n    optimized_radii = result.x[2*n:]\n    \n    # Ensure circles are within bounds and don't overlap\n    optimized_centers, optimized_radii = fix_constraints(optimized_centers, optimized_radii)\n    \n    return optimized_centers, optimized_radii\n\ndef optimize_with_basin_hopping(centers, radii, n_iter=10, T=0.1):\n    \"\"\"\n    Use basin hopping to escape local minima in the optimization.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        n_iter: Number of basin hopping iterations\n        T: Temperature parameter for basin hopping\n        \n    Returns:\n        Optimized centers and radii\n    \"\"\"\n    n = len(centers)\n    \n    # Combine centers and radii into a single parameter vector\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    def objective(x):\n        \"\"\"Objective function: negative sum of radii + penalty for constraints\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        \n        # Calculate sum of radii (to be maximized)\n        sum_radii = np.sum(current_radii)\n        \n        # Calculate penalty for constraints\n        penalty = calculate_penalty(current_centers, current_radii)\n        \n        # Return negative sum (since we're minimizing) plus penalty\n        return -sum_radii + penalty\n    \n    # Bounds for optimization\n    bounds = []\n    for i in range(n):\n        bounds.append((0.0, 1.0))  # x-coordinate\n        bounds.append((0.0, 1.0))  # y-coordinate\n    for i in range(n):\n        bounds.append((0.05, 0.15))  # radii\n    \n    # Custom step function for basin hopping\n    def take_step(x):\n        # Create a copy of the current solution\n        new_x = x.copy()\n        \n        # Randomly choose whether to perturb positions or radii\n        if np.random.random() < 0.7:  # 70% chance to perturb positions\n            # Select a random circle\n            circle_idx = np.random.randint(0, n)\n            \n            # Perturb its position slightly\n            pos_idx = circle_idx * 2\n            new_x[pos_idx:pos_idx+2] += np.random.normal(0, 0.02, 2)\n            \n            # Ensure it stays within bounds\n            new_x[pos_idx:pos_idx+2] = np.clip(new_x[pos_idx:pos_idx+2], 0, 1)\n        else:  # 30% chance to perturb radii\n            # Select a random circle\n            circle_idx = np.random.randint(0, n)\n            \n            # Perturb its radius slightly\n            rad_idx = 2*n + circle_idx\n            new_x[rad_idx] += np.random.normal(0, 0.005)\n            \n            # Ensure it stays within bounds\n            new_x[rad_idx] = np.clip(new_x[rad_idx], 0.05, 0.15)\n        \n        return new_x\n    \n    # Run basin hopping\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": bounds,\n        \"options\": {\"maxiter\": 100, \"ftol\": 1e-6}\n    }\n    \n    result = basinhopping(\n        objective,\n        x0,\n        niter=n_iter,\n        T=T,\n        take_step=take_step,\n        minimizer_kwargs=minimizer_kwargs,\n        stepsize=0.1\n    )\n    \n    # Extract optimized centers and radii\n    optimized_centers = result.x[:2*n].reshape((n, 2))\n    optimized_radii = result.x[2*n:]\n    \n    # Ensure circles are within bounds and don't overlap\n    optimized_centers, optimized_radii = fix_constraints(optimized_centers, optimized_radii)\n    \n    return optimized_centers, optimized_radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for constraint violations:\n    1. Circles must be within the unit square\n    2. Circles must not overlap\n    \n    Uses a smooth, differentiable penalty function with graduated severity\n    based on the degree of violation.\n    \"\"\"\n    n = len(radii)\n    penalty = 0.0\n    \n    # Penalty factors - higher values enforce constraints more strictly\n    boundary_factor = 1500.0\n    overlap_factor = 1500.0\n    \n    # 1. Penalty for circles outside the unit square\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        \n        # Left boundary: x - r >= 0\n        if x - r < 0:\n            violation = -(x - r)\n            penalty += boundary_factor * violation**2\n        \n        # Right boundary: x + r <= 1\n        if x + r > 1:\n            violation = (x + r) - 1\n            penalty += boundary_factor * violation**2\n        \n        # Bottom boundary: y - r >= 0\n        if y - r < 0:\n            violation = -(y - r)\n            penalty += boundary_factor * violation**2\n        \n        # Top boundary: y + r <= 1\n        if y + r > 1:\n            violation = (y + r) - 1\n            penalty += boundary_factor * violation**2\n    \n    # 2. Penalty for overlapping circles - use vectorized operations for efficiency\n    for i in range(n):\n        # Calculate distances to all other circles at once\n        diff_x = centers[i, 0] - centers[:, 0]\n        diff_y = centers[i, 1] - centers[:, 1]\n        distances = np.sqrt(diff_x**2 + diff_y**2)\n        \n        # Minimum required distances\n        min_distances = radii[i] + radii\n        \n        # Find overlapping circles (excluding self)\n        mask = (distances < min_distances) & (distances > 0)  # distances > 0 excludes self\n        \n        if np.any(mask):\n            violations = min_distances[mask] - distances[mask]\n            # Apply quadratic penalty\n            penalty += overlap_factor * np.sum(violations**2)\n    \n    return penalty\n\ndef fix_constraints(centers, radii):\n    \"\"\"\n    Ensure all constraints are satisfied by making minimal adjustments.\n    This is a post-processing step to fix any remaining constraint violations.\n    \"\"\"\n    n = len(radii)\n    \n    # 1. Fix boundary constraints\n    for i in range(n):\n        # Ensure circle is within x-bounds\n        if centers[i, 0] - radii[i] < 0:\n            centers[i, 0] = radii[i]\n        if centers[i, 0] + radii[i] > 1:\n            centers[i, 0] = 1 - radii[i]\n            \n        # Ensure circle is within y-bounds\n        if centers[i, 1] - radii[i] < 0:\n            centers[i, 1] = radii[i]\n        if centers[i, 1] + radii[i] > 1:\n            centers[i, 1] = 1 - radii[i]\n    \n    # 2. Fix overlap constraints (iterative adjustment)\n    max_iterations = 50\n    for _ in range(max_iterations):\n        overlap_found = False\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                # Distance between centers\n                dist_vector = centers[i] - centers[j]\n                dist = np.linalg.norm(dist_vector)\n                min_dist = radii[i] + radii[j]\n                \n                # If circles overlap\n                if dist < min_dist and dist > 1e-10:  # Avoid division by zero\n                    overlap_found = True\n                    \n                    # Calculate unit vector from j to i\n                    unit_vector = dist_vector / dist\n                    \n                    # Move circles apart proportionally to their radii\n                    overlap = min_dist - dist\n                    move_i = overlap * 0.55 * (radii[i] / (radii[i] + radii[j]))\n                    move_j = overlap * 0.55 * (radii[j] / (radii[i] + radii[j]))\n                    \n                    centers[i] += move_i * unit_vector\n                    centers[j] -= move_j * unit_vector\n                    \n                    # Re-check boundary constraints\n                    for k in [i, j]:\n                        if centers[k, 0] - radii[k] < 0:\n                            centers[k, 0] = radii[k]\n                        if centers[k, 0] + radii[k] > 1:\n                            centers[k, 0] = 1 - radii[k]\n                        if centers[k, 1] - radii[k] < 0:\n                            centers[k, 1] = radii[k]\n                        if centers[k, 1] + radii[k] > 1:\n                            centers[k, 1] = 1 - radii[k]\n        \n        # If no overlaps found, we're done\n        if not overlap_found:\n            break\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```"]}}}