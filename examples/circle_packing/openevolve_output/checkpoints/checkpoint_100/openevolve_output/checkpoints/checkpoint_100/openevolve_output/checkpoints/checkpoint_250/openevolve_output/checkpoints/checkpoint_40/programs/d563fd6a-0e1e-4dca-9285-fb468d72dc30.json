{"id": "d563fd6a-0e1e-4dca-9285-fb468d72dc30", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square, implementing specialized geometric patterns and multi-stage optimization techniques to maximize the sum of radii. This implementation focuses on a simplified penalty function, aggressive radius adjustment, and a refined basin hopping optimization. Includes a dynamic radius scaling factor and individual radius scaling to fine-tune the sizes. Addressing stagnation by focusing on dynamic radius adjustment and more robust initialization. Removing proximity penalty and simplifying bounds.\n\nThis version introduces a more aggressive initial radius scaling based on the golden ratio, a refined penalty function that prioritizes boundary adherence, and a dynamically adjusted step size in the basin hopping algorithm. It also includes a more targeted perturbation strategy during the multi-stage optimization. The goal is to achieve better packing density and avoid local minima.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    start_time = time.time()\n    max_time = 180  # Maximum time in seconds\n\n    # Define pattern generation functions in order of expected performance\n    patterns = [\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_hybrid_variable_26,\n        initialize_pattern_optimized_corners_26,\n        initialize_pattern_concentric_26,\n        initialize_pattern_specialized_26\n    ]\n\n    # First pass: try each pattern with basic optimization\n    for pattern_func in patterns:\n        if time.time() - start_time > max_time * 0.15: # Limit time per pattern\n            break\n            \n        try:\n            centers, radii = pattern_func()\n            \n            # Ensure we have exactly 26 circles\n            assert centers.shape[0] == n, f\"Pattern function returned {centers.shape[0]} circles instead of {n}\"\n\n            # Scale radii based on golden ratio to encourage larger circles\n            radii = radii * 1.618  # Golden ratio scaling\n\n            # Quick optimization to improve the pattern\n            centers, radii = optimize_packing(centers, radii, iterations=30, quick=True)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            logging.error(f\"Error in pattern initialization or quick optimization: {e}\")\n            continue\n\n    # Second pass: intensive optimization on the best pattern\n    if best_centers is not None:\n        remaining_time = max_time - (time.time() - start_time)\n        if remaining_time > max_time * 0.3:  # Only if we have enough time left\n            try:\n                centers, radii = optimize_packing(best_centers, best_radii, \n                                                 iterations=150, \n                                                 quick=False)\n                \n                sum_radii = np.sum(radii)\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n            except Exception as e:\n                logging.error(f\"Error in intensive optimization: {e}\")\n                pass  # Keep the previous best if optimization fails\n\n    # Final refinement with multi-stage optimization\n    remaining_time = max_time - (time.time() - start_time)\n    if remaining_time > max_time * 0.3 and best_centers is not None:\n        try:\n            centers, radii = multi_stage_optimization(best_centers, best_radii)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            logging.error(f\"Error in multi-stage optimization: {e}\")\n            pass  # Keep the previous best if optimization fails\n\n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26, with larger circles in the center\n    and corners, and smaller circles to fill gaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place a large circle in the center\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.14\n\n    # Place 6 circles in the first hexagonal ring\n    first_ring_radius = 0.11\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + first_ring_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = first_ring_radius\n\n    # Place 12 circles in the second hexagonal ring\n    second_ring_radius = 0.09\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*first_ring_radius + second_ring_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = second_ring_radius\n\n    # Place 4 larger circles in the corners\n    corner_radius = 0.125\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n\n    # Place 3 medium circles to fill remaining spaces\n    medium_radius = 0.085\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = medium_radius\n\n    return centers, radii\n\ndef initialize_pattern_hybrid_variable_26():\n    \"\"\"\n    Initialize with a hybrid pattern using variable-sized circles arranged in a pattern\n    that combines hexagonal and square grid elements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.12\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.10\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Central circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.13\n\n    # 8 circles in inner ring around center\n    inner_radius = 0.095\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n\n    # 2 smaller circles on each edge\n    small_radius = 0.07\n    centers[17] = [0.25, 0.1]\n    centers[18] = [0.75, 0.1]\n    centers[19] = [0.25, 0.9]\n    centers[20] = [0.75, 0.9]\n    centers[21] = [0.1, 0.25]\n    centers[22] = [0.1, 0.75]\n    centers[23] = [0.9, 0.25]\n    centers[24] = [0.9, 0.75]\n    radii[17:25] = small_radius\n\n    # Center fill circle\n    centers[25] = [0.5, 0.25]\n    radii[25] = 0.07\n\n    return centers, radii\n\ndef initialize_pattern_optimized_corners_26():\n    \"\"\"\n    Initialize with a pattern that optimizes corner and edge utilization with\n    variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 8 edge circles (2 on each edge)\n    edge_radius = 0.09\n    edge_positions = [0.27, 0.73]\n    \n    # Bottom edge\n    centers[4] = [edge_positions[0], edge_radius]\n    centers[5] = [edge_positions[1], edge_radius]\n    \n    # Top edge\n    centers[6] = [edge_positions[0], 1-edge_radius]\n    centers[7] = [edge_positions[1], 1-edge_radius]\n    \n    # Left edge\n    centers[8] = [edge_radius, edge_positions[0]]\n    centers[9] = [edge_radius, edge_positions[1]]\n    \n    # Right edge\n    centers[10] = [1-edge_radius, edge_positions[0]]\n    centers[11] = [1-edge_radius, edge_positions[1]]\n    \n    radii[4:12] = edge_radius\n\n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.11\n\n    # Inner grid (13 circles)\n    inner_radius = 0.075\n    grid_positions = [\n        (0.5, 0.3), (0.5, 0.7),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),\n        (0.4, 0.4), (0.6, 0.4), (0.4, 0.6), (0.6, 0.6),\n        (0.5, 0.4)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        centers[13+i] = pos\n        radii[13+i] = inner_radius\n\n    return centers, radii\n\ndef initialize_pattern_concentric_26():\n    \"\"\"\n    Initialize with concentric rings of circles with carefully chosen radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.135\n\n    # First ring (6 circles)\n    ring1_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = ring1_radius\n\n    # Second ring (12 circles)\n    ring2_radius = 0.085\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*ring1_radius + ring2_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = ring2_radius\n\n    # Corner circles (4 circles)\n    corner_radius = 0.115\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n\n    # Remaining circles\n    radii[23:26] = 0.075\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.75]\n    centers[25] = [0.25, 0.75]\n\n    return centers, radii\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically designed for n=26 based on mathematical research.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.12\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.105\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place 8 medium-small circles at intermediate edge positions\n    mid_edge_radius = 0.09\n    centers[8] = [0.25, mid_edge_radius]\n    centers[9] = [0.75, mid_edge_radius]\n    centers[10] = [0.25, 1-mid_edge_radius]\n    centers[11] = [0.75, 1-mid_edge_radius]\n    centers[12] = [mid_edge_radius, 0.25]\n    centers[13] = [mid_edge_radius, 0.75]\n    centers[14] = [1-mid_edge_radius, 0.25]\n    centers[15] = [1-mid_edge_radius, 0.75]\n    radii[8:16] = mid_edge_radius\n\n    # Place a large circle in the center\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.13\n\n    # Place 9 smaller circles in a grid pattern\n    small_radius = 0.07\n    grid_positions = [\n        (0.3, 0.3), (0.5, 0.3), (0.7, 0.3),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.7), (0.5, 0.7), (0.7, 0.7),\n        (0.4, 0.4)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        centers[17+i] = pos\n        radii[17+i] = small_radius\n\n    return centers, radii\n\ndef optimize_packing(centers, radii, iterations=100, quick=False):\n    \"\"\"\n    Optimize circle positions and radii using a combination of global and local optimization.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        iterations: Number of optimization iterations\n        quick: If True, perform a faster but less thorough optimization\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        sum_radii = np.sum(current_radii)\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -sum_radii + penalty\n    \n    # Initial guess\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds for centers and radii\n    center_bounds = [(0.01, 0.99)] * (2 * n)\n    radii_bounds = [(0.03, 0.2)] * n\n    bounds = center_bounds + radii_bounds\n    \n    # Define the step-taking function for basin hopping\n    def take_step(x):\n        \"\"\"Custom step function that perturbs the configuration intelligently.\"\"\"\n        centers_part = x[:2*n].reshape((n, 2))\n        radii_part = x[2*n:]\n        \n        # Perturb centers with small random displacements\n        centers_step = np.random.normal(0, 0.008, size=2*n)\n        \n        # Perturb radii with smaller displacements, scaled by current radius\n        radii_step = np.random.normal(0, 0.003, size=n) * (1.0 + radii_part)\n        \n        # Combine the steps\n        return x + np.concatenate([centers_step, radii_step])\n    \n    # Define optimization parameters\n    if quick:\n        niter = min(iterations, 40)\n        T = 0.4\n        stepsize = 0.08\n        minimizer_kwargs = {\n            \"method\": \"L-BFGS-B\", \n            \"bounds\": bounds,\n            \"options\": {'maxiter': 40, 'ftol': 1e-5}\n        }\n    else:\n        niter = iterations\n        T = 0.9\n        # Dynamically adjust stepsize based on number of iterations\n        stepsize = min(0.15, 0.05 + (iterations / 500))\n        minimizer_kwargs = {\n            \"method\": \"L-BFGS-B\", \n            \"bounds\": bounds,\n            \"options\": {'maxiter': 80, 'ftol': 1e-6}\n        }\n    \n    # Perform basin hopping optimization\n    result = basinhopping(\n        objective, x0, \n        niter=niter,\n        T=T,\n        stepsize=stepsize,\n        minimizer_kwargs=minimizer_kwargs,\n        take_step=take_step\n    )\n    \n    # Extract optimized centers and radii\n    final_centers = result.x[:2*n].reshape((n, 2))\n    final_radii = result.x[2*n:]\n    \n    return final_centers, final_radii\n\ndef multi_stage_optimization(centers, radii):\n    \"\"\"\n    Perform multi-stage optimization with different strategies to escape local minima.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # Stage 1: Optimize with high temperature\n    try:\n        stage1_centers, stage1_radii = optimize_packing(\n            centers, radii, iterations=40, quick=False)\n        stage1_sum = np.sum(stage1_radii)\n        \n        if stage1_sum > best_sum:\n            best_centers = stage1_centers\n            best_radii = stage1_radii\n            best_sum = stage1_sum\n    except Exception as e:\n        logging.error(f\"Error in stage 1 optimization: {e}\")\n        pass\n    \n    # Stage 2: Perturb and optimize specific circles - Target largest circles\n    try:\n        # Find the *largest* circles (instead of smallest)\n        sorted_indices = np.argsort(best_radii)[::-1]  # Sort in descending order\n        large_indices = sorted_indices[:4]  # 4 largest circles\n        \n        # Perturb their positions *and radii*\n        perturbed_centers = best_centers.copy()\n        perturbed_radii = best_radii.copy()\n        for idx in large_indices:\n            perturbed_centers[idx] += np.random.normal(0, 0.04, size=2)\n            perturbed_radii[idx] *= (1 + np.random.normal(0, 0.02))  # Perturb radius\n            perturbed_radii[idx] = np.clip(perturbed_radii[idx], 0.03, 0.2) # Keep radii in bounds\n            \n        # Re-optimize\n        stage2_centers, stage2_radii = optimize_packing(\n            perturbed_centers, perturbed_radii, iterations=25, quick=False)\n        stage2_sum = np.sum(stage2_radii)\n        \n        if stage2_sum > best_sum:\n            best_centers = stage2_centers\n            best_radii = stage2_radii\n            best_sum = stage2_sum\n    except Exception as e:\n        logging.error(f\"Error in stage 2 optimization: {e}\")\n        pass\n    \n    # Stage 3: Targeted radius adjustment\n    try:\n        # Slightly increase all radii and let the optimizer fix overlaps\n        adjusted_radii = best_radii * 1.015\n        \n        # Re-optimize\n        stage3_centers, stage3_radii = optimize_packing(\n            best_centers, adjusted_radii, iterations=25, quick=False)\n        stage3_sum = np.sum(stage3_radii)\n        \n        if stage3_sum > best_sum:\n            best_centers = stage3_centers\n            best_radii = stage3_radii\n            best_sum = stage3_sum\n    except Exception as e:\n        logging.error(f\"Error in stage 3 optimization: {e}\")\n        pass\n    \n    return best_centers, best_radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Uses a smooth, differentiable penalty function for better optimization.\n    Prioritizes boundary adherence to prevent circles from escaping the square.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    overlap_penalty_factor = 5000\n    boundary_penalty_factor = 10000  # Increased boundary penalty\n    \n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                # Use a quadratic penalty with radius-dependent scaling\n                penalty += overlap_penalty_factor * overlap**2\n    \n    # Penalty for circles outside the unit square - STRONGLY ENFORCED\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2 * 2 # Higher penalty\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2 * 2 # Higher penalty\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2 * 2 # Higher penalty\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2 * 2 # Higher penalty\n    \n    return penalty\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "c40aa5d2-bc7f-47ff-aafb-4de7dbb1e484", "generation": 7, "timestamp": 1750927213.7272086, "iteration_found": 36, "metrics": {"validity": 0.0, "sum_radii": 0.0, "target_ratio": 0.0, "combined_score": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "sum_radii": 0.0, "target_ratio": 0.0, "combined_score": 0.0}, "island": 3}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.645 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.636, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - validity: 0.0000\n- sum_radii: 0.0000\n- target_ratio: 0.0000\n- combined_score: 0.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: validity, sum_radii, target_ratio, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6360, target_ratio: 1.0004, combined_score: 1.0004, eval_time: 43.1799\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6228, target_ratio: 0.9954, combined_score: 0.9954, eval_time: 117.8238\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6073, target_ratio: 0.9895, combined_score: 0.9895, eval_time: 132.5911\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 9.7633)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6360), Performs well on target_ratio (1.0004), Performs well on combined_score (1.0004), Performs well on eval_time (43.1799)\n\n\n### Program 2 (Score: 27.6355)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6073), Performs well on target_ratio (0.9895), Performs well on combined_score (0.9895), Performs well on eval_time (132.5911)\n\n\n### Program 3 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on error (Program execution failed: index 26 is out of bounds for axis 0 with size 26)\n\n\n### Program 4 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on error (Program execution failed: index 26 is out of bounds for axis 0 with size 26)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy. Addressing stagnation by incorporating simulated annealing.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n# ... (truncated)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square, implementing specialized geometric patterns and multi-stage optimization techniques to maximize the sum of radii. This implementation focuses on a simplified penalty function, aggressive radius adjustment, and a refined basin hopping optimization. Includes a dynamic radius scaling factor and individual radius scaling to fine-tune the sizes. Addressing stagnation by focusing on dynamic radius adjustment and more robust initialization. Removing proximity penalty and simplifying bounds.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    start_time = time.time()\n    max_time = 180  # Maximum time in seconds\n\n    # Define pattern generation functions in order of expected performance\n    patterns = [\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_hybrid_variable_26,\n        initialize_pattern_optimized_corners_26,\n        initialize_pattern_concentric_26,\n        initialize_pattern_specialized_26\n    ]\n\n    # First pass: try each pattern with basic optimization\n    for pattern_func in patterns:\n        if time.time() - start_time > max_time * 0.2: # Limit time per pattern\n            break\n            \n        try:\n            centers, radii = pattern_func()\n            \n            # Ensure we have exactly 26 circles\n            assert centers.shape[0] == n, f\"Pattern function returned {centers.shape[0]} circles instead of {n}\"\n            \n            # Quick optimization to improve the pattern\n            centers, radii = optimize_packing(centers, radii, iterations=30, quick=True)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            logging.error(f\"Error in pattern initialization or quick optimization: {e}\")\n            continue\n\n    # Second pass: intensive optimization on the best pattern\n    if best_centers is not None:\n        remaining_time = max_time - (time.time() - start_time)\n        if remaining_time > max_time * 0.3:  # Only if we have enough time left\n            try:\n                centers, radii = optimize_packing(best_centers, best_radii, \n                                                 iterations=150, \n                                                 quick=False)\n                \n                sum_radii = np.sum(radii)\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n            except Exception as e:\n                logging.error(f\"Error in intensive optimization: {e}\")\n                pass  # Keep the previous best if optimization fails\n\n    # Final refinement with multi-stage optimization\n    remaining_time = max_time - (time.time() - start_time)\n    if remaining_time > max_time * 0.3 and best_centers is not None:\n        try:\n            centers, radii = multi_stage_optimization(best_centers, best_radii)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            logging.error(f\"Error in multi-stage optimization: {e}\")\n            pass  # Keep the previous best if optimization fails\n\n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26, with larger circles in the center\n    and corners, and smaller circles to fill gaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place a large circle in the center\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.14\n\n    # Place 6 circles in the first hexagonal ring\n    first_ring_radius = 0.11\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + first_ring_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = first_ring_radius\n\n    # Place 12 circles in the second hexagonal ring\n    second_ring_radius = 0.09\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*first_ring_radius + second_ring_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = second_ring_radius\n\n    # Place 4 larger circles in the corners\n    corner_radius = 0.125\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n\n    # Place 3 medium circles to fill remaining spaces\n    medium_radius = 0.085\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = medium_radius\n\n    return centers, radii\n\ndef initialize_pattern_hybrid_variable_26():\n    \"\"\"\n    Initialize with a hybrid pattern using variable-sized circles arranged in a pattern\n    that combines hexagonal and square grid elements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.12\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.10\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Central circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.13\n\n    # 8 circles in inner ring around center\n    inner_radius = 0.095\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n\n    # 2 smaller circles on each edge\n    small_radius = 0.07\n    centers[17] = [0.25, 0.1]\n    centers[18] = [0.75, 0.1]\n    centers[19] = [0.25, 0.9]\n    centers[20] = [0.75, 0.9]\n    centers[21] = [0.1, 0.25]\n    centers[22] = [0.1, 0.75]\n    centers[23] = [0.9, 0.25]\n    centers[24] = [0.9, 0.75]\n    radii[17:25] = small_radius\n\n    # Center fill circle\n    centers[25] = [0.5, 0.25]\n    radii[25] = 0.07\n\n    return centers, radii\n\ndef initialize_pattern_optimized_corners_26():\n    \"\"\"\n    Initialize with a pattern that optimizes corner and edge utilization with\n    variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 8 edge circles (2 on each edge)\n    edge_radius = 0.09\n    edge_positions = [0.27, 0.73]\n    \n    # Bottom edge\n    centers[4] = [edge_positions[0], edge_radius]\n    centers[5] = [edge_positions[1], edge_radius]\n    \n    # Top edge\n    centers[6] = [edge_positions[0], 1-edge_radius]\n    centers[7] = [edge_positions[1], 1-edge_radius]\n    \n    # Left edge\n    centers[8] = [edge_radius, edge_positions[0]]\n    centers[9] = [edge_radius, edge_positions[1]]\n    \n    # Right edge\n    centers[10] = [1-edge_radius, edge_positions[0]]\n    centers[11] = [1-edge_radius, edge_positions[1]]\n    \n    radii[4:12] = edge_radius\n\n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.11\n\n    # Inner grid (13 circles)\n    inner_radius = 0.075\n    grid_positions = [\n        (0.5, 0.3), (0.5, 0.7),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),\n        (0.4, 0.4), (0.6, 0.4), (0.4, 0.6), (0.6, 0.6),\n        (0.5, 0.4)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        centers[13+i] = pos\n        radii[13+i] = inner_radius\n\n    return centers, radii\n\ndef initialize_pattern_concentric_26():\n    \"\"\"\n    Initialize with concentric rings of circles with carefully chosen radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.135\n\n    # First ring (6 circles)\n    ring1_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = ring1_radius\n\n    # Second ring (12 circles)\n    ring2_radius = 0.085\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*ring1_radius + ring2_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = ring2_radius\n\n    # Corner circles (4 circles)\n    corner_radius = 0.115\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n\n    # Remaining circles\n    radii[23:26] = 0.075\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.75]\n    centers[25] = [0.25, 0.75]\n\n    return centers, radii\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically designed for n=26 based on mathematical research.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.12\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.105\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place 8 medium-small circles at intermediate edge positions\n    mid_edge_radius = 0.09\n    centers[8] = [0.25, mid_edge_radius]\n    centers[9] = [0.75, mid_edge_radius]\n    centers[10] = [0.25, 1-mid_edge_radius]\n    centers[11] = [0.75, 1-mid_edge_radius]\n    centers[12] = [mid_edge_radius, 0.25]\n    centers[13] = [mid_edge_radius, 0.75]\n    centers[14] = [1-mid_edge_radius, 0.25]\n    centers[15] = [1-mid_edge_radius, 0.75]\n    radii[8:16] = mid_edge_radius\n\n    # Place a large circle in the center\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.13\n\n    # Place 9 smaller circles in a grid pattern\n    small_radius = 0.07\n    grid_positions = [\n        (0.3, 0.3), (0.5, 0.3), (0.7, 0.3),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.7), (0.5, 0.7), (0.7, 0.7),\n        (0.4, 0.4)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        centers[17+i] = pos\n        radii[17+i] = small_radius\n\n    return centers, radii\n\ndef optimize_packing(centers, radii, iterations=100, quick=False):\n    \"\"\"\n    Optimize circle positions and radii using a combination of global and local optimization.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        iterations: Number of optimization iterations\n        quick: If True, perform a faster but less thorough optimization\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        sum_radii = np.sum(current_radii)\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -sum_radii + penalty\n    \n    # Initial guess\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds for centers and radii\n    center_bounds = [(0.01, 0.99)] * (2 * n)\n    radii_bounds = [(0.03, 0.2)] * n\n    bounds = center_bounds + radii_bounds\n    \n    # Define the step-taking function for basin hopping\n    def take_step(x):\n        \"\"\"Custom step function that perturbs the configuration intelligently.\"\"\"\n        centers_part = x[:2*n].reshape((n, 2))\n        radii_part = x[2*n:]\n        \n        # Perturb centers with small random displacements\n        centers_step = np.random.normal(0, 0.008, size=2*n)\n        \n        # Perturb radii with smaller displacements, scaled by current radius\n        radii_step = np.random.normal(0, 0.003, size=n) * (1.0 + radii_part)\n        \n        # Combine the steps\n        return x + np.concatenate([centers_step, radii_step])\n    \n    # Define optimization parameters\n    if quick:\n        niter = min(iterations, 40)\n        T = 0.4\n        stepsize = 0.08\n        minimizer_kwargs = {\n            \"method\": \"L-BFGS-B\", \n            \"bounds\": bounds,\n            \"options\": {'maxiter': 40, 'ftol': 1e-5}\n        }\n    else:\n        niter = iterations\n        T = 0.9\n        stepsize = 0.15\n        minimizer_kwargs = {\n            \"method\": \"L-BFGS-B\", \n            \"bounds\": bounds,\n            \"options\": {'maxiter': 80, 'ftol': 1e-6}\n        }\n    \n    # Perform basin hopping optimization\n    result = basinhopping(\n        objective, x0, \n        niter=niter,\n        T=T,\n        stepsize=stepsize,\n        minimizer_kwargs=minimizer_kwargs,\n        take_step=take_step\n    )\n    \n    # Extract optimized centers and radii\n    final_centers = result.x[:2*n].reshape((n, 2))\n    final_radii = result.x[2*n:]\n    \n    return final_centers, final_radii\n\ndef multi_stage_optimization(centers, radii):\n    \"\"\"\n    Perform multi-stage optimization with different strategies to escape local minima.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # Stage 1: Optimize with high temperature\n    try:\n        stage1_centers, stage1_radii = optimize_packing(\n            centers, radii, iterations=40, quick=False)\n        stage1_sum = np.sum(stage1_radii)\n        \n        if stage1_sum > best_sum:\n            best_centers = stage1_centers\n            best_radii = stage1_radii\n            best_sum = stage1_sum\n    except Exception as e:\n        logging.error(f\"Error in stage 1 optimization: {e}\")\n        pass\n    \n    # Stage 2: Perturb and optimize specific circles\n    try:\n        # Find the smallest circles\n        sorted_indices = np.argsort(best_radii)\n        small_indices = sorted_indices[:4]  # 4 smallest circles\n        \n        # Perturb their positions\n        perturbed_centers = best_centers.copy()\n        for idx in small_indices:\n            perturbed_centers[idx] += np.random.normal(0, 0.04, size=2)\n            \n        # Re-optimize\n        stage2_centers, stage2_radii = optimize_packing(\n            perturbed_centers, best_radii, iterations=25, quick=False)\n        stage2_sum = np.sum(stage2_radii)\n        \n        if stage2_sum > best_sum:\n            best_centers = stage2_centers\n            best_radii = stage2_radii\n            best_sum = stage2_sum\n    except Exception as e:\n        logging.error(f\"Error in stage 2 optimization: {e}\")\n        pass\n    \n    # Stage 3: Targeted radius adjustment\n    try:\n        # Slightly increase all radii and let the optimizer fix overlaps\n        adjusted_radii = best_radii * 1.015\n        \n        # Re-optimize\n        stage3_centers, stage3_radii = optimize_packing(\n            best_centers, adjusted_radii, iterations=25, quick=False)\n        stage3_sum = np.sum(stage3_radii)\n        \n        if stage3_sum > best_sum:\n            best_centers = stage3_centers\n            best_radii = stage3_radii\n            best_sum = stage3_sum\n    except Exception as e:\n        logging.error(f\"Error in stage 3 optimization: {e}\")\n        pass\n    \n    return best_centers, best_radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Uses a smooth, differentiable penalty function for better optimization.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    overlap_penalty_factor = 5000\n    boundary_penalty_factor = 5000\n    \n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                # Use a quadratic penalty with radius-dependent scaling\n                penalty += overlap_penalty_factor * overlap**2\n    \n    # Penalty for circles outside the unit square\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n    \n    return penalty\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square, implementing specialized geometric patterns and multi-stage optimization techniques to maximize the sum of radii. This implementation focuses on a simplified penalty function, aggressive radius adjustment, and a refined basin hopping optimization. Includes a dynamic radius scaling factor and individual radius scaling to fine-tune the sizes. Addressing stagnation by focusing on dynamic radius adjustment and more robust initialization. Removing proximity penalty and simplifying bounds.\n\nThis version introduces a more aggressive initial radius scaling based on the golden ratio, a refined penalty function that prioritizes boundary adherence, and a dynamically adjusted step size in the basin hopping algorithm. It also includes a more targeted perturbation strategy during the multi-stage optimization. The goal is to achieve better packing density and avoid local minima.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    start_time = time.time()\n    max_time = 180  # Maximum time in seconds\n\n    # Define pattern generation functions in order of expected performance\n    patterns = [\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_hybrid_variable_26,\n        initialize_pattern_optimized_corners_26,\n        initialize_pattern_concentric_26,\n        initialize_pattern_specialized_26\n    ]\n\n    # First pass: try each pattern with basic optimization\n    for pattern_func in patterns:\n        if time.time() - start_time > max_time * 0.15: # Limit time per pattern\n            break\n            \n        try:\n            centers, radii = pattern_func()\n            \n            # Ensure we have exactly 26 circles\n            assert centers.shape[0] == n, f\"Pattern function returned {centers.shape[0]} circles instead of {n}\"\n\n            # Scale radii based on golden ratio to encourage larger circles\n            radii = radii * 1.618  # Golden ratio scaling\n\n            # Quick optimization to improve the pattern\n            centers, radii = optimize_packing(centers, radii, iterations=30, quick=True)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            logging.error(f\"Error in pattern initialization or quick optimization: {e}\")\n            continue\n\n    # Second pass: intensive optimization on the best pattern\n    if best_centers is not None:\n        remaining_time = max_time - (time.time() - start_time)\n        if remaining_time > max_time * 0.3:  # Only if we have enough time left\n            try:\n                centers, radii = optimize_packing(best_centers, best_radii, \n                                                 iterations=150, \n                                                 quick=False)\n                \n                sum_radii = np.sum(radii)\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n            except Exception as e:\n                logging.error(f\"Error in intensive optimization: {e}\")\n                pass  # Keep the previous best if optimization fails\n\n    # Final refinement with multi-stage optimization\n    remaining_time = max_time - (time.time() - start_time)\n    if remaining_time > max_time * 0.3 and best_centers is not None:\n        try:\n            centers, radii = multi_stage_optimization(best_centers, best_radii)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            logging.error(f\"Error in multi-stage optimization: {e}\")\n            pass  # Keep the previous best if optimization fails\n\n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26, with larger circles in the center\n    and corners, and smaller circles to fill gaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place a large circle in the center\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.14\n\n    # Place 6 circles in the first hexagonal ring\n    first_ring_radius = 0.11\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + first_ring_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = first_ring_radius\n\n    # Place 12 circles in the second hexagonal ring\n    second_ring_radius = 0.09\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*first_ring_radius + second_ring_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = second_ring_radius\n\n    # Place 4 larger circles in the corners\n    corner_radius = 0.125\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n\n    # Place 3 medium circles to fill remaining spaces\n    medium_radius = 0.085\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = medium_radius\n\n    return centers, radii\n\ndef initialize_pattern_hybrid_variable_26():\n    \"\"\"\n    Initialize with a hybrid pattern using variable-sized circles arranged in a pattern\n    that combines hexagonal and square grid elements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.12\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.10\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Central circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.13\n\n    # 8 circles in inner ring around center\n    inner_radius = 0.095\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n\n    # 2 smaller circles on each edge\n    small_radius = 0.07\n    centers[17] = [0.25, 0.1]\n    centers[18] = [0.75, 0.1]\n    centers[19] = [0.25, 0.9]\n    centers[20] = [0.75, 0.9]\n    centers[21] = [0.1, 0.25]\n    centers[22] = [0.1, 0.75]\n    centers[23] = [0.9, 0.25]\n    centers[24] = [0.9, 0.75]\n    radii[17:25] = small_radius\n\n    # Center fill circle\n    centers[25] = [0.5, 0.25]\n    radii[25] = 0.07\n\n    return centers, radii\n\ndef initialize_pattern_optimized_corners_26():\n    \"\"\"\n    Initialize with a pattern that optimizes corner and edge utilization with\n    variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 8 edge circles (2 on each edge)\n    edge_radius = 0.09\n    edge_positions = [0.27, 0.73]\n    \n    # Bottom edge\n    centers[4] = [edge_positions[0], edge_radius]\n    centers[5] = [edge_positions[1], edge_radius]\n    \n    # Top edge\n    centers[6] = [edge_positions[0], 1-edge_radius]\n    centers[7] = [edge_positions[1], 1-edge_radius]\n    \n    # Left edge\n    centers[8] = [edge_radius, edge_positions[0]]\n    centers[9] = [edge_radius, edge_positions[1]]\n    \n    # Right edge\n    centers[10] = [1-edge_radius, edge_positions[0]]\n    centers[11] = [1-edge_radius, edge_positions[1]]\n    \n    radii[4:12] = edge_radius\n\n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.11\n\n    # Inner grid (13 circles)\n    inner_radius = 0.075\n    grid_positions = [\n        (0.5, 0.3), (0.5, 0.7),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),\n        (0.4, 0.4), (0.6, 0.4), (0.4, 0.6), (0.6, 0.6),\n        (0.5, 0.4)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        centers[13+i] = pos\n        radii[13+i] = inner_radius\n\n    return centers, radii\n\ndef initialize_pattern_concentric_26():\n    \"\"\"\n    Initialize with concentric rings of circles with carefully chosen radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.135\n\n    # First ring (6 circles)\n    ring1_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = ring1_radius\n\n    # Second ring (12 circles)\n    ring2_radius = 0.085\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*ring1_radius + ring2_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = ring2_radius\n\n    # Corner circles (4 circles)\n    corner_radius = 0.115\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n\n    # Remaining circles\n    radii[23:26] = 0.075\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.75]\n    centers[25] = [0.25, 0.75]\n\n    return centers, radii\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically designed for n=26 based on mathematical research.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.12\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.105\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place 8 medium-small circles at intermediate edge positions\n    mid_edge_radius = 0.09\n    centers[8] = [0.25, mid_edge_radius]\n    centers[9] = [0.75, mid_edge_radius]\n    centers[10] = [0.25, 1-mid_edge_radius]\n    centers[11] = [0.75, 1-mid_edge_radius]\n    centers[12] = [mid_edge_radius, 0.25]\n    centers[13] = [mid_edge_radius, 0.75]\n    centers[14] = [1-mid_edge_radius, 0.25]\n    centers[15] = [1-mid_edge_radius, 0.75]\n    radii[8:16] = mid_edge_radius\n\n    # Place a large circle in the center\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.13\n\n    # Place 9 smaller circles in a grid pattern\n    small_radius = 0.07\n    grid_positions = [\n        (0.3, 0.3), (0.5, 0.3), (0.7, 0.3),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.7), (0.5, 0.7), (0.7, 0.7),\n        (0.4, 0.4)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        centers[17+i] = pos\n        radii[17+i] = small_radius\n\n    return centers, radii\n\ndef optimize_packing(centers, radii, iterations=100, quick=False):\n    \"\"\"\n    Optimize circle positions and radii using a combination of global and local optimization.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        iterations: Number of optimization iterations\n        quick: If True, perform a faster but less thorough optimization\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        sum_radii = np.sum(current_radii)\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -sum_radii + penalty\n    \n    # Initial guess\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds for centers and radii\n    center_bounds = [(0.01, 0.99)] * (2 * n)\n    radii_bounds = [(0.03, 0.2)] * n\n    bounds = center_bounds + radii_bounds\n    \n    # Define the step-taking function for basin hopping\n    def take_step(x):\n        \"\"\"Custom step function that perturbs the configuration intelligently.\"\"\"\n        centers_part = x[:2*n].reshape((n, 2))\n        radii_part = x[2*n:]\n        \n        # Perturb centers with small random displacements\n        centers_step = np.random.normal(0, 0.008, size=2*n)\n        \n        # Perturb radii with smaller displacements, scaled by current radius\n        radii_step = np.random.normal(0, 0.003, size=n) * (1.0 + radii_part)\n        \n        # Combine the steps\n        return x + np.concatenate([centers_step, radii_step])\n    \n    # Define optimization parameters\n    if quick:\n        niter = min(iterations, 40)\n        T = 0.4\n        stepsize = 0.08\n        minimizer_kwargs = {\n            \"method\": \"L-BFGS-B\", \n            \"bounds\": bounds,\n            \"options\": {'maxiter': 40, 'ftol': 1e-5}\n        }\n    else:\n        niter = iterations\n        T = 0.9\n        # Dynamically adjust stepsize based on number of iterations\n        stepsize = min(0.15, 0.05 + (iterations / 500))\n        minimizer_kwargs = {\n            \"method\": \"L-BFGS-B\", \n            \"bounds\": bounds,\n            \"options\": {'maxiter': 80, 'ftol': 1e-6}\n        }\n    \n    # Perform basin hopping optimization\n    result = basinhopping(\n        objective, x0, \n        niter=niter,\n        T=T,\n        stepsize=stepsize,\n        minimizer_kwargs=minimizer_kwargs,\n        take_step=take_step\n    )\n    \n    # Extract optimized centers and radii\n    final_centers = result.x[:2*n].reshape((n, 2))\n    final_radii = result.x[2*n:]\n    \n    return final_centers, final_radii\n\ndef multi_stage_optimization(centers, radii):\n    \"\"\"\n    Perform multi-stage optimization with different strategies to escape local minima.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # Stage 1: Optimize with high temperature\n    try:\n        stage1_centers, stage1_radii = optimize_packing(\n            centers, radii, iterations=40, quick=False)\n        stage1_sum = np.sum(stage1_radii)\n        \n        if stage1_sum > best_sum:\n            best_centers = stage1_centers\n            best_radii = stage1_radii\n            best_sum = stage1_sum\n    except Exception as e:\n        logging.error(f\"Error in stage 1 optimization: {e}\")\n        pass\n    \n    # Stage 2: Perturb and optimize specific circles - Target largest circles\n    try:\n        # Find the *largest* circles (instead of smallest)\n        sorted_indices = np.argsort(best_radii)[::-1]  # Sort in descending order\n        large_indices = sorted_indices[:4]  # 4 largest circles\n        \n        # Perturb their positions *and radii*\n        perturbed_centers = best_centers.copy()\n        perturbed_radii = best_radii.copy()\n        for idx in large_indices:\n            perturbed_centers[idx] += np.random.normal(0, 0.04, size=2)\n            perturbed_radii[idx] *= (1 + np.random.normal(0, 0.02))  # Perturb radius\n            perturbed_radii[idx] = np.clip(perturbed_radii[idx], 0.03, 0.2) # Keep radii in bounds\n            \n        # Re-optimize\n        stage2_centers, stage2_radii = optimize_packing(\n            perturbed_centers, perturbed_radii, iterations=25, quick=False)\n        stage2_sum = np.sum(stage2_radii)\n        \n        if stage2_sum > best_sum:\n            best_centers = stage2_centers\n            best_radii = stage2_radii\n            best_sum = stage2_sum\n    except Exception as e:\n        logging.error(f\"Error in stage 2 optimization: {e}\")\n        pass\n    \n    # Stage 3: Targeted radius adjustment\n    try:\n        # Slightly increase all radii and let the optimizer fix overlaps\n        adjusted_radii = best_radii * 1.015\n        \n        # Re-optimize\n        stage3_centers, stage3_radii = optimize_packing(\n            best_centers, adjusted_radii, iterations=25, quick=False)\n        stage3_sum = np.sum(stage3_radii)\n        \n        if stage3_sum > best_sum:\n            best_centers = stage3_centers\n            best_radii = stage3_radii\n            best_sum = stage3_sum\n    except Exception as e:\n        logging.error(f\"Error in stage 3 optimization: {e}\")\n        pass\n    \n    return best_centers, best_radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Uses a smooth, differentiable penalty function for better optimization.\n    Prioritizes boundary adherence to prevent circles from escaping the square.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    overlap_penalty_factor = 5000\n    boundary_penalty_factor = 10000  # Increased boundary penalty\n    \n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                # Use a quadratic penalty with radius-dependent scaling\n                penalty += overlap_penalty_factor * overlap**2\n    \n    # Penalty for circles outside the unit square - STRONGLY ENFORCED\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2 * 2 # Higher penalty\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2 * 2 # Higher penalty\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2 * 2 # Higher penalty\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2 * 2 # Higher penalty\n    \n    return penalty\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```"]}}}