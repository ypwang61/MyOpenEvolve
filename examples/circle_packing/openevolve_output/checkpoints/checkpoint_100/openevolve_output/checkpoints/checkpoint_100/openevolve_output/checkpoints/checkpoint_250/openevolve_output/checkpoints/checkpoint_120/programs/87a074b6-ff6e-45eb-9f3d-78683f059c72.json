{"id": "87a074b6-ff6e-45eb-9f3d-78683f059c72", "code": "# EVOLVE-BLOCK-START\n\"\"\"Optimized circle packing for n=26 circles in a unit square using specialized patterns and efficient optimization techniques to maximize the sum of radii toward the target value of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Time management - allocate time for each pattern\n    start_time = time.time()\n    max_time = 180  # Maximum seconds to spend\n    time_per_pattern = max_time / 4  # Allocate time for top patterns\n    \n    # Prioritize patterns known to perform well\n    patterns = [\n        initialize_pattern_specialized_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_variable_26,\n        initialize_pattern_edge_optimized_26\n    ]\n\n    for i, pattern_func in enumerate(patterns):\n        pattern_start_time = time.time()\n        remaining_time = max_time - (pattern_start_time - start_time)\n        \n        # Skip if we're running out of time\n        if remaining_time < 10:  # Need at least 10 seconds for a pattern\n            break\n            \n        # Set time limit for this pattern\n        pattern_time_limit = min(time_per_pattern, remaining_time)\n        \n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization with time limit\n        try:\n            centers, radii = optimize_pattern(centers, radii, time_limit=pattern_time_limit)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n            # If we're very close to target, stop early\n            if sum_radii > 2.64:\n                break\n                \n        except Exception:\n            continue\n            \n        # Check if we're out of time\n        if time.time() - start_time > max_time - 10:\n            break\n\n    # Return the best result found\n    return best_centers, best_radii, best_sum\n\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.121\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.106\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.127\n\n    # Place 8 circles in inner ring around center\n    inner_radius = 0.101\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n\n    # Place 9 circles in outer ring\n    outer_radius = 0.074\n    for i in range(9):\n        angle = 2 * np.pi * i / 9 + np.pi/9\n        dist = 0.40\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = outer_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.131\n\n    # Inner ring (6 circles)\n    inner_radius = 0.106\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n\n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.096\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius + 0.001\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n\n    # Corner circles (4 larger circles)\n    corner_radius = 0.116\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n\n    # Edge circles (4 medium circles)\n    edge_radius = 0.091\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n\n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.076\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.25, 0.75]\n    radii[23:26] = small_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_variable_26():\n    \"\"\"\n    Initialize with a pattern that uses variable-sized circles with emphasis on\n    maximizing the sum of radii based on mathematical insights.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 corner circles - larger\n    corner_radius = 0.127\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # Center circle - largest\n    centers[4] = [0.5, 0.5]\n    radii[4] = 0.135\n\n    # 4 edge centers - medium-large\n    edge_radius = 0.111\n    centers[5] = [0.5, edge_radius]\n    centers[6] = [0.5, 1 - edge_radius]\n    centers[7] = [edge_radius, 0.5]\n    centers[8] = [1 - edge_radius, 0.5]\n    radii[5:9] = edge_radius\n\n    # Inner ring around center - medium\n    inner_radius = 0.104\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[4] + inner_radius + 0.001\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n\n    # Intermediate positions - medium-small\n    mid_radius = 0.091\n    positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.25, 0.5), (0.75, 0.5)\n    ]\n    for i, (x, y) in enumerate(positions[:6]):\n        centers[15 + i] = [x, y]\n        radii[15 + i] = mid_radius\n\n    # Remaining positions - smallest\n    small_radius = 0.083\n    remaining_positions = [\n        (0.35, 0.15), (0.65, 0.15), (0.35, 0.85), (0.65, 0.85),\n        (0.15, 0.35), (0.15, 0.65)\n    ]\n    for i, (x, y) in enumerate(remaining_positions[:5]):\n        centers[21 + i] = [x, y]\n        radii[21 + i] = small_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_edge_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Corner circles (4) - larger\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # Center circle (1) - largest\n    centers[4] = [0.5, 0.5]\n    radii[4] = 0.14\n\n    # Primary edge circles (4) - medium-large\n    edge_radius = 0.108\n    centers[5] = [0.5, edge_radius]\n    centers[6] = [0.5, 1 - edge_radius]\n    centers[7] = [edge_radius, 0.5]\n    centers[8] = [1 - edge_radius, 0.5]\n    radii[5:9] = edge_radius\n\n    # Secondary edge circles (8) - medium\n    sec_edge_radius = 0.095\n    edge_positions = [\n        (0.25, 0.095), (0.75, 0.095),  # Bottom edge\n        (0.25, 0.905), (0.75, 0.905),  # Top edge\n        (0.095, 0.25), (0.095, 0.75),  # Left edge\n        (0.905, 0.25), (0.905, 0.75)   # Right edge\n    ]\n    for i, (x, y) in enumerate(edge_positions):\n        centers[9 + i] = [x, y]\n        radii[9 + i] = sec_edge_radius\n\n    # Inner ring around center (6) - medium-small\n    inner_radius = 0.098\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[4] + inner_radius + 0.001\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = inner_radius\n\n    # Fill remaining spaces (3) - smallest\n    small_radius = 0.085\n    fill_positions = [(0.3, 0.3), (0.7, 0.3), (0.3, 0.7)]\n    for i, (x, y) in enumerate(fill_positions):\n        centers[23 + i] = [x, y]\n        radii[23 + i] = small_radius\n\n    return centers, radii\n\n\ndef optimize_pattern(centers, radii, time_limit=45.0):\n    \"\"\"Optimize circle positions and radii with time limit.\"\"\"\n    n = len(centers)\n    start_time = time.time()\n\n    # Define bounds for center coordinates and radii\n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.03, 0.2)] * n\n\n    # Initial guess\n    initial_guess = np.concatenate([centers.flatten(), radii])\n    \n    # Two-stage optimization\n    # Stage 1: Quick optimization with looser tolerances\n    result = minimize(\n        lambda x: objective_function(x, n),\n        initial_guess,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 300, 'ftol': 1e-5}\n    )\n    \n    # Check if we have time for stage 2\n    elapsed = time.time() - start_time\n    if elapsed < time_limit - 5:  # Need at least 5 seconds for stage 2\n        # Stage 2: Refined optimization with tighter tolerances\n        result = minimize(\n            lambda x: objective_function(x, n),\n            result.x,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 700, 'ftol': 1e-7, 'gtol': 1e-7}\n        )\n    \n    # Extract results\n    optimized_centers = result.x[:2 * n].reshape(n, 2)\n    optimized_radii = result.x[2 * n:]\n\n    # Ensure validity\n    optimized_centers, optimized_radii = ensure_validity(optimized_centers, optimized_radii)\n    \n    return optimized_centers, optimized_radii\n\n\ndef objective_function(x, n):\n    \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n    current_centers = x[:2 * n].reshape(n, 2)\n    current_radii = x[2 * n:]\n    penalty = calculate_penalty(current_centers, current_radii)\n    return -np.sum(current_radii) + penalty\n\n\ndef calculate_penalty(centers, radii):\n    \"\"\"Calculate penalty for overlapping circles or circles outside the unit square.\"\"\"\n    n = len(centers)\n    penalty = 0.0\n    \n    # Penalty factors\n    overlap_penalty_factor = 800\n    boundary_penalty_factor = 800\n    \n    # Precompute distances between all pairs of centers (more efficient)\n    dists = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1, n):\n            dists[i, j] = np.linalg.norm(centers[i] - centers[j])\n            dists[j, i] = dists[i, j]  # Symmetric\n    \n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            overlap = radii[i] + radii[j] - dists[i, j]\n            if overlap > 0:\n                # Quadratic penalty weighted by the size of the circles\n                penalty += overlap_penalty_factor * overlap**2 * (radii[i] + radii[j])\n\n    # Penalty for circles outside the unit square\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n\n    return penalty\n\n\ndef ensure_validity(centers, radii):\n    \"\"\"Ensure all circles are valid (within bounds and non-overlapping).\"\"\"\n    n = len(centers)\n    \n    # Clip radii to valid range\n    radii = np.clip(radii, 0.03, 0.2)\n    \n    # Ensure centers are within bounds considering radii\n    for i in range(n):\n        centers[i, 0] = np.clip(centers[i, 0], radii[i], 1.0 - radii[i])\n        centers[i, 1] = np.clip(centers[i, 1], radii[i], 1.0 - radii[i])\n    \n    # Resolve overlaps by slightly shrinking overlapping circles\n    overlap_resolved = False\n    max_iterations = 5\n    iteration = 0\n    \n    while not overlap_resolved and iteration < max_iterations:\n        overlap_resolved = True\n        iteration += 1\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                \n                if overlap > 1e-6:  # Significant overlap\n                    overlap_resolved = False\n                    # Shrink both circles proportionally to their size\n                    total_radius = radii[i] + radii[j]\n                    shrink_i = overlap * (radii[i] / total_radius) * 0.6\n                    shrink_j = overlap * (radii[j] / total_radius) * 0.6\n                    \n                    # Apply shrinking with limits\n                    radii[i] = max(radii[i] - shrink_i, 0.03)\n                    radii[j] = max(radii[j] - shrink_j, 0.03)\n    \n    return centers, radii\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "aa303664-c59a-4f54-8b0f-761e7bb2a051", "generation": 8, "timestamp": 1750939892.6943734, "iteration_found": 112, "metrics": {"validity": 0.0, "sum_radii": 0.0, "target_ratio": 0.0, "combined_score": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"stage1_passed": 0.0, "error": 0.0, "timeout": true}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.645 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.636, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - stage1_passed: 0.0000\n- error: 0.0000\n- timeout: 1.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n## Last Execution Output\n\n### timeout\n```\nTrue\n```\n\n### timeout_duration\n```\n200\n```\n\n### failure_stage\n```\nstage1\n```\n\n### error_type\n```\ntimeout\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6202, target_ratio: 0.9944, combined_score: 0.9944, eval_time: 43.5821\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6228, target_ratio: 0.9954, combined_score: 0.9954, eval_time: 117.8238\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6073, target_ratio: 0.9895, combined_score: 0.9895, eval_time: 132.5911\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 9.7633)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6360), Performs well on target_ratio (1.0004), Performs well on combined_score (1.0004), Performs well on eval_time (43.1799)\n\n\n### Program 2 (Score: 27.6355)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6073), Performs well on target_ratio (0.9895), Performs well on combined_score (0.9895), Performs well on eval_time (132.5911)\n\n\n### Program 3 (Score: 6.3621)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square, using a hybrid approach combining mathematical patterns, physics-based optimization, and adaptive sizing strategies to maximize the sum of radii.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\nimport time\nimport random\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6281), Performs well on target_ratio (0.9974), Performs well on combined_score (0.9974), Performs well on eval_time (26.1879)\n\n\n### Program 4 (Score: 9.6940)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6360), Performs well on target_ratio (1.0004), Performs well on combined_score (1.0004), Performs well on eval_time (42.8332)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using multi-stage optimization with specialized patterns and mathematical insights to maximize the sum of radii toward the theoretical optimal value of 2.645. This version introduces a novel adaptive penalty scaling, refined initial guess generation, and a three-stage optimization process combining global exploration with local refinement and radius balancing.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport logging\n# ... (truncated)\n```\nKey features: Alternative approach to stage1_passed, Alternative approach to error\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using multi-stage optimization with specialized patterns and mathematical insights to maximize the sum of radii toward the theoretical optimal value of 2.645. This version introduces a more efficient optimization strategy and refined penalty function.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n\n    # Prioritize patterns known to perform well\n    patterns = [\n        initialize_pattern_specialized_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_corner_optimized_26,\n        initialize_pattern_ring_26,\n        initialize_pattern_billiard_26,\n        initialize_pattern_optimized_grid_26,\n        initialize_pattern_greedy_26\n    ]\n\n    for pattern_func in patterns:\n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function {pattern_func.__name__} returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization\n        try:\n            centers, radii = optimize_pattern(centers, radii)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            print(f\"Optimization failed for {pattern_func.__name__}: {e}\")\n            continue\n\n    return best_centers, best_radii, best_sum\n\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.121\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.106\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.127\n\n    # Place 8 circles in inner ring around center\n    inner_radius = 0.101\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n\n    # Place 6 circles in outer ring (adjusted from 10 to 9 to ensure we have exactly 26 circles)\n    outer_radius = 0.074\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi/6\n        dist = 0.40\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = outer_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.131\n\n    # Inner ring (6 circles)\n    inner_radius = 0.106\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n\n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.096\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius + 0.001\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n\n    # Corner circles (4 larger circles)\n    corner_radius = 0.116\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n\n    # Edge circles (4 medium circles)\n    edge_radius = 0.091\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n\n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.076\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = small_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_billiard_26():\n    \"\"\"\n    Initialize with a billiard-table inspired pattern with circles along the edges\n    and a triangular pattern in the center.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 corner circles\n    corner_radius = 0.116\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # 8 edge circles (2 on each edge)\n    edge_radius = 0.096\n    edge_positions = [0.3, 0.7]\n\n    # Bottom edge\n    centers[4] = [edge_positions[0], edge_radius]\n    centers[5] = [edge_positions[1], edge_radius]\n\n    # Top edge\n    centers[6] = [edge_positions[0], 1 - edge_radius]\n    centers[7] = [edge_positions[1], 1 - edge_radius]\n\n    # Left edge\n    centers[8] = [edge_radius, edge_positions[0]]\n    centers[9] = [edge_radius, edge_positions[1]]\n\n    # Right edge\n    centers[10] = [1 - edge_radius, edge_positions[0]]\n    centers[11] = [1 - edge_radius, edge_positions[1]]\n\n    radii[4:12] = edge_radius\n\n    # Triangular pattern in center (14 circles)\n    inner_radius = 0.086\n\n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.106  # Slightly larger center circle\n\n    # Inner hexagon (6 circles)\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[12] + inner_radius + 0.001\n        centers[13 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[13 + i] = inner_radius\n\n    # Outer partial ring (7 circles)\n    outer_radius = 0.081\n    for i in range(7):\n        angle = 2 * np.pi * i / 7 + np.pi / 7\n        dist = radii[12] + 2 * inner_radius + outer_radius + 0.001\n        centers[19 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[19 + i] = outer_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_corner_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal corner and edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.126\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.101\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # 8 smaller edge circles\n    small_edge_radius = 0.086\n    centers[8] = [0.25, small_edge_radius]\n    centers[9] = [0.75, small_edge_radius]\n    centers[10] = [0.25, 1 - small_edge_radius]\n    centers[11] = [0.75, 1 - small_edge_radius]\n    centers[12] = [small_edge_radius, 0.25]\n    centers[13] = [small_edge_radius, 0.75]\n    centers[14] = [1 - small_edge_radius, 0.25]\n    centers[15] = [1 - small_edge_radius, 0.75]\n    radii[8:16] = small_edge_radius\n\n    # Inner grid (10 circles)\n    inner_radius = 0.081\n    grid_positions = [0.3, 0.5, 0.7]\n    \n    count = 16\n    grid_points = []\n    for x in grid_positions:\n        for y in grid_positions:\n            grid_points.append((x, y))\n    \n    # Ensure we don't exceed 26 circles\n    for x, y in grid_points[:n-count]:\n        if x == 0.5 and y == 0.5:\n            # Larger circle in the center\n            centers[count] = [x, y]\n            radii[count] = 0.116\n        else:\n            centers[count] = [x, y]\n            radii[count] = inner_radius\n        count += 1\n\n    return centers, radii\n\n\ndef initialize_pattern_ring_26():\n    \"\"\"\n    Initialize with concentric rings of circles, optimized for n=26.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.136\n\n    # First ring (8 circles)\n    ring1_radius = 0.101\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = ring1_radius\n\n    # Second ring (12 circles)\n    ring2_radius = 0.091\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * ring1_radius + ring2_radius + 0.001\n        centers[i + 9] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 9] = ring2_radius\n\n    # Corner circles (4 circles)\n    corner_radius = 0.096\n    centers[21] = [corner_radius, corner_radius]\n    centers[22] = [1 - corner_radius, corner_radius]\n    centers[23] = [corner_radius, 1 - corner_radius]\n    centers[24] = [1 - corner_radius, 1 - corner_radius]\n    radii[21:25] = corner_radius\n\n    # One extra circle\n    centers[25] = [0.5, 0.15]\n    radii[25] = 0.086\n\n    return centers, radii\n\ndef initialize_pattern_optimized_grid_26():\n    \"\"\"\n    Initializes circles in an optimized grid-like pattern, focusing on even distribution and space filling.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Start with a rough grid\n    num_x = 6\n    num_y = 5  # Adjusted for 26 circles\n    \n    x_coords = np.linspace(0.1, 0.9, num_x)\n    y_coords = np.linspace(0.1, 0.9, num_y)\n\n    count = 0\n    for i in range(num_y):\n        for j in range(num_x):\n            if count < n:\n                centers[count, 0] = x_coords[j]\n                centers[count, 1] = y_coords[i]\n                radii[count] = 0.086  # Initial radius\n                count += 1\n            else:\n                break\n        if count >= n:\n            break\n            \n    # Adjust radii based on location - corners slightly larger\n    for i in range(n):\n        if (centers[i, 0] < 0.2 and centers[i, 1] < 0.2) or \\\n           (centers[i, 0] > 0.8 and centers[i, 1] < 0.2) or \\\n           (centers[i, 0] < 0.2 and centers[i, 1] > 0.8) or \\\n           (centers[i, 0] > 0.8 and centers[i, 1] > 0.8):\n            radii[i] = 0.091  # Slightly larger in the corners\n        elif centers[i, 0] == 0.5 and centers[i, 1] == 0.5:\n            radii[i] = 0.106  # Largest radius in the very center\n        else:\n            radii[i] = 0.081\n\n    return centers, radii\n\n\ndef initialize_pattern_greedy_26():\n    \"\"\"\n    Initialize with a greedy approach that places larger circles first\n    and then fills in with smaller ones.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Define initial positions for the first 5 circles (corners and center)\n    initial_positions = [\n        (0.126, 0.126),       # Bottom left corner\n        (0.874, 0.126),       # Bottom right corner\n        (0.126, 0.874),       # Top left corner\n        (0.874, 0.874),       # Top right corner\n        (0.5, 0.5)          # Center\n    ]\n    \n    # Initial radii for the first 5 circles\n    initial_radii = [0.126, 0.126, 0.126, 0.126, 0.146]\n    \n    for i in range(min(5, n)):\n        centers[i] = initial_positions[i]\n        radii[i] = initial_radii[i]\n    \n    # Place circles along the edges\n    edge_positions = [\n        (0.5, 0.1),         # Bottom edge\n        (0.5, 0.9),         # Top edge\n        (0.1, 0.5),         # Left edge\n        (0.9, 0.5),         # Right edge\n        (0.3, 0.1),         # Bottom edge\n        (0.7, 0.1),         # Bottom edge\n        (0.3, 0.9),         # Top edge\n        (0.7, 0.9),         # Top edge\n        (0.1, 0.3),         # Left edge\n        (0.1, 0.7),         # Left edge\n        (0.9, 0.3),         # Right edge\n        (0.9, 0.7)          # Right edge\n    ]\n    \n    edge_radii = [0.106, 0.106, 0.106, 0.106, 0.096, 0.096, 0.096, 0.096, 0.096, 0.096, 0.096, 0.096]\n    \n    for i in range(min(len(edge_positions), n-5)):\n        centers[i+5] = edge_positions[i]\n        radii[i+5] = edge_radii[i]\n    \n    # Place inner circles in a grid-like pattern\n    inner_positions = [\n        (0.3, 0.3),\n        (0.5, 0.3),\n        (0.7, 0.3),\n        (0.3, 0.5),\n        (0.7, 0.5),\n        (0.3, 0.7),\n        (0.5, 0.7),\n        (0.7, 0.7),\n        (0.4, 0.4)\n    ]\n    \n    inner_radii = [0.096, 0.096, 0.096, 0.096, 0.096, 0.096, 0.096, 0.096, 0.086]\n    \n    remaining_circles = n - (5 + len(edge_positions))\n    for i in range(min(len(inner_positions), remaining_circles)):\n        centers[i+5+len(edge_positions)] = inner_positions[i]\n        radii[i+5+len(edge_positions)] = inner_radii[i]\n    \n    return centers, radii\n\n\ndef optimize_pattern(centers, radii):\n    \"\"\"Optimize circle positions and radii using a combination of techniques.\"\"\"\n    n = len(centers)\n\n    # Define bounds for center coordinates and radii\n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.03, 0.2)] * n  # Radius bounds\n\n    def objective_function(x):\n        \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n        current_centers = x[:2 * n].reshape(n, 2)\n        current_radii = x[2 * n:]\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -np.sum(current_radii) + penalty  # Minimize -sum(radii) + penalty\n\n    # Initial guess\n    initial_guess = np.concatenate([centers.flatten(), radii])\n\n    # Optimization using L-BFGS-B\n    result = minimize(objective_function, initial_guess, method='L-BFGS-B', bounds=bounds,\n                       options={'maxiter': 1500, 'ftol': 1e-7, 'gtol': 1e-8})  # Increased iterations and tighter tolerance\n\n    optimized_centers = result.x[:2 * n].reshape(n, 2)\n    optimized_radii = result.x[2 * n:]\n\n    # Clip values to ensure validity\n    optimized_radii = np.clip(optimized_radii, 0.03, 0.2)\n    optimized_centers = np.clip(optimized_centers, optimized_radii.reshape(-1, 1), 1.0 - optimized_radii.reshape(-1, 1))\n\n    return optimized_centers, optimized_radii\n\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Used for optimization.  Increased penalty magnitude and added radius-dependent term.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    overlap_penalty_factor = 600  # Increased penalty\n    boundary_penalty_factor = 600 # Increased penalty\n    proximity_penalty_factor = 50\n\n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                penalty += overlap_penalty_factor * overlap**2 * (radii[i] + radii[j])\n\n    # Penalty for circles outside the unit square\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n\n    # Proximity penalty (discourage circles from being too close without overlapping)\n    min_distance_threshold = 0.005  # Tune this value\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            expected_distance = radii[i] + radii[j]\n            if dist < expected_distance + min_distance_threshold and dist > expected_distance:\n                 penalty += proximity_penalty_factor * (expected_distance + min_distance_threshold - dist)**2\n\n    return penalty\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["I'll rewrite the program to make it more efficient and effective at reaching the target sum of radii (2.645). The current program is timing out, and we need to optimize both the algorithm and implementation.\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimized circle packing for n=26 circles in a unit square using specialized patterns and efficient optimization techniques to maximize the sum of radii toward the target value of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Time management - allocate time for each pattern\n    start_time = time.time()\n    max_time = 180  # Maximum seconds to spend\n    time_per_pattern = max_time / 4  # Allocate time for top patterns\n    \n    # Prioritize patterns known to perform well\n    patterns = [\n        initialize_pattern_specialized_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_variable_26,\n        initialize_pattern_edge_optimized_26\n    ]\n\n    for i, pattern_func in enumerate(patterns):\n        pattern_start_time = time.time()\n        remaining_time = max_time - (pattern_start_time - start_time)\n        \n        # Skip if we're running out of time\n        if remaining_time < 10:  # Need at least 10 seconds for a pattern\n            break\n            \n        # Set time limit for this pattern\n        pattern_time_limit = min(time_per_pattern, remaining_time)\n        \n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization with time limit\n        try:\n            centers, radii = optimize_pattern(centers, radii, time_limit=pattern_time_limit)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n            # If we're very close to target, stop early\n            if sum_radii > 2.64:\n                break\n                \n        except Exception:\n            continue\n            \n        # Check if we're out of time\n        if time.time() - start_time > max_time - 10:\n            break\n\n    # Return the best result found\n    return best_centers, best_radii, best_sum\n\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.121\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.106\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.127\n\n    # Place 8 circles in inner ring around center\n    inner_radius = 0.101\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n\n    # Place 9 circles in outer ring\n    outer_radius = 0.074\n    for i in range(9):\n        angle = 2 * np.pi * i / 9 + np.pi/9\n        dist = 0.40\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = outer_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.131\n\n    # Inner ring (6 circles)\n    inner_radius = 0.106\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n\n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.096\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius + 0.001\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n\n    # Corner circles (4 larger circles)\n    corner_radius = 0.116\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n\n    # Edge circles (4 medium circles)\n    edge_radius = 0.091\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n\n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.076\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.25, 0.75]\n    radii[23:26] = small_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_variable_26():\n    \"\"\"\n    Initialize with a pattern that uses variable-sized circles with emphasis on\n    maximizing the sum of radii based on mathematical insights.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 corner circles - larger\n    corner_radius = 0.127\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # Center circle - largest\n    centers[4] = [0.5, 0.5]\n    radii[4] = 0.135\n\n    # 4 edge centers - medium-large\n    edge_radius = 0.111\n    centers[5] = [0.5, edge_radius]\n    centers[6] = [0.5, 1 - edge_radius]\n    centers[7] = [edge_radius, 0.5]\n    centers[8] = [1 - edge_radius, 0.5]\n    radii[5:9] = edge_radius\n\n    # Inner ring around center - medium\n    inner_radius = 0.104\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[4] + inner_radius + 0.001\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n\n    # Intermediate positions - medium-small\n    mid_radius = 0.091\n    positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.25, 0.5), (0.75, 0.5)\n    ]\n    for i, (x, y) in enumerate(positions[:6]):\n        centers[15 + i] = [x, y]\n        radii[15 + i] = mid_radius\n\n    # Remaining positions - smallest\n    small_radius = 0.083\n    remaining_positions = [\n        (0.35, 0.15), (0.65, 0.15), (0.35, 0.85), (0.65, 0.85),\n        (0.15, 0.35), (0.15, 0.65)\n    ]\n    for i, (x, y) in enumerate(remaining_positions[:5]):\n        centers[21 + i] = [x, y]\n        radii[21 + i] = small_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_edge_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Corner circles (4) - larger\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # Center circle (1) - largest\n    centers[4] = [0.5, 0.5]\n    radii[4] = 0.14\n\n    # Primary edge circles (4) - medium-large\n    edge_radius = 0.108\n    centers[5] = [0.5, edge_radius]\n    centers[6] = [0.5, 1 - edge_radius]\n    centers[7] = [edge_radius, 0.5]\n    centers[8] = [1 - edge_radius, 0.5]\n    radii[5:9] = edge_radius\n\n    # Secondary edge circles (8) - medium\n    sec_edge_radius = 0.095\n    edge_positions = [\n        (0.25, 0.095), (0.75, 0.095),  # Bottom edge\n        (0.25, 0.905), (0.75, 0.905),  # Top edge\n        (0.095, 0.25), (0.095, 0.75),  # Left edge\n        (0.905, 0.25), (0.905, 0.75)   # Right edge\n    ]\n    for i, (x, y) in enumerate(edge_positions):\n        centers[9 + i] = [x, y]\n        radii[9 + i] = sec_edge_radius\n\n    # Inner ring around center (6) - medium-small\n    inner_radius = 0.098\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[4] + inner_radius + 0.001\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = inner_radius\n\n    # Fill remaining spaces (3) - smallest\n    small_radius = 0.085\n    fill_positions = [(0.3, 0.3), (0.7, 0.3), (0.3, 0.7)]\n    for i, (x, y) in enumerate(fill_positions):\n        centers[23 + i] = [x, y]\n        radii[23 + i] = small_radius\n\n    return centers, radii\n\n\ndef optimize_pattern(centers, radii, time_limit=45.0):\n    \"\"\"Optimize circle positions and radii with time limit.\"\"\"\n    n = len(centers)\n    start_time = time.time()\n\n    # Define bounds for center coordinates and radii\n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.03, 0.2)] * n\n\n    # Initial guess\n    initial_guess = np.concatenate([centers.flatten(), radii])\n    \n    # Two-stage optimization\n    # Stage 1: Quick optimization with looser tolerances\n    result = minimize(\n        lambda x: objective_function(x, n),\n        initial_guess,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 300, 'ftol': 1e-5}\n    )\n    \n    # Check if we have time for stage 2\n    elapsed = time.time() - start_time\n    if elapsed < time_limit - 5:  # Need at least 5 seconds for stage 2\n        # Stage 2: Refined optimization with tighter tolerances\n        result = minimize(\n            lambda x: objective_function(x, n),\n            result.x,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 700, 'ftol': 1e-7, 'gtol': 1e-7}\n        )\n    \n    # Extract results\n    optimized_centers = result.x[:2 * n].reshape(n, 2)\n    optimized_radii = result.x[2 * n:]\n\n    # Ensure validity\n    optimized_centers, optimized_radii = ensure_validity(optimized_centers, optimized_radii)\n    \n    return optimized_centers, optimized_radii\n\n\ndef objective_function(x, n):\n    \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n    current_centers = x[:2 * n].reshape(n, 2)\n    current_radii = x[2 * n:]\n    penalty = calculate_penalty(current_centers, current_radii)\n    return -np.sum(current_radii) + penalty\n\n\ndef calculate_penalty(centers, radii):\n    \"\"\"Calculate penalty for overlapping circles or circles outside the unit square.\"\"\"\n    n = len(centers)\n    penalty = 0.0\n    \n    # Penalty factors\n    overlap_penalty_factor = 800\n    boundary_penalty_factor = 800\n    \n    # Precompute distances between all pairs of centers (more efficient)\n    dists = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1, n):\n            dists[i, j] = np.linalg.norm(centers[i] - centers[j])\n            dists[j, i] = dists[i, j]  # Symmetric\n    \n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            overlap = radii[i] + radii[j] - dists[i, j]\n            if overlap > 0:\n                # Quadratic penalty weighted by the size of the circles\n                penalty += overlap_penalty_factor * overlap**2 * (radii[i] + radii[j])\n\n    # Penalty for circles outside the unit square\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n\n    return penalty\n\n\ndef ensure_validity(centers, radii):\n    \"\"\"Ensure all circles are valid (within bounds and non-overlapping).\"\"\"\n    n = len(centers)\n    \n    # Clip radii to valid range\n    radii = np.clip(radii, 0.03, 0.2)\n    \n    # Ensure centers are within bounds considering radii\n    for i in range(n):\n        centers[i, 0] = np.clip(centers[i, 0], radii[i], 1.0 - radii[i])\n        centers[i, 1] = np.clip(centers[i, 1], radii[i], 1.0 - radii[i])\n    \n    # Resolve overlaps by slightly shrinking overlapping circles\n    overlap_resolved = False\n    max_iterations = 5\n    iteration = 0\n    \n    while not overlap_resolved and iteration < max_iterations:\n        overlap_resolved = True\n        iteration += 1\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                \n                if overlap > 1e-6:  # Significant overlap\n                    overlap_resolved = False\n                    # Shrink both circles proportionally to their size\n                    total_radius = radii[i] + radii[j]\n                    shrink_i = overlap * (radii[i] / total_radius) * 0.6\n                    shrink_j = overlap * (radii[j] / total_radius) * 0.6\n                    \n                    # Apply shrinking with limits\n                    radii[i] = max(radii[i] - shrink_i, 0.03)\n                    radii[j] = max(radii[j] - shrink_j, 0.03)\n    \n    return centers, radii\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```\n\nThe key improvements in this rewritten program include:\n\n1. **Time management** - Added strict time limits to prevent timeouts, with time allocation per pattern\n2. **Reduced complexity** - Removed unnecessary patterns and focused on the most promising ones\n3. **More efficient optimization** - Two-stage optimization with different tolerances\n4. **Improved initial patterns** - Created new specialized patterns based on mathematical insights\n5. **Better penalty calculation** - More efficient implementation with precomputed distances\n6. **Validity enforcement** - Added explicit overlap resolution to ensure valid circle configurations\n7. **Simplified code structure** - Removed unnecessary logging and reduced function complexity\n\nThese changes should significantly improve performance while maintaining the core functionality of finding an optimal packing arrangement for 26 circles in a unit square, targeting the sum of radii of 2.645."]}}}