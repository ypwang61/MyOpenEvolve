{"id": "037642e1-e3b8-4c19-b3de-6c86c3c0159e", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square, implementing specialized geometric patterns and multi-stage optimization techniques to maximize the sum of radii. This implementation uses hybrid patterns with variable-sized circles, targeted perturbation strategies, and adaptive penalty functions to escape local optima. This version focuses on SIMPLER optimization and increased pattern diversity.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport random\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    start_time = time.time()\n    max_time = 40  # Increased max time\n\n    # Define pattern generation functions in order of expected performance\n    patterns = [\n        initialize_pattern_hybrid_variable_26,  # Prioritize this pattern\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_optimized_corners_26,\n        initialize_pattern_concentric_26,\n        initialize_pattern_specialized_26,\n        initialize_pattern_random_26 #Adding random initialization\n    ]\n\n    # First pass: try each pattern with basic optimization\n    for pattern_func in patterns:\n        if time.time() - start_time > max_time:\n            break\n            \n        try:\n            centers, radii = pattern_func()\n            \n            # Ensure we have exactly 26 circles\n            assert centers.shape[0] == n, f\"Pattern function returned {centers.shape[0]} circles instead of {n}\"\n            \n            # Quick optimization to improve the pattern\n            centers, radii = optimize_packing(centers, radii, iterations=30, quick=True)  # Reduced iterations for speed\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            continue\n\n    # Second pass: intensive optimization on the best pattern\n    if best_centers is not None:\n        remaining_time = max_time - (time.time() - start_time)\n        if remaining_time > 5:  # Only if we have enough time left\n            try:\n                centers, radii = optimize_packing(best_centers, best_radii, \n                                                 iterations=100,  # Reduced iterations for speed\n                                                 quick=False)\n                \n                sum_radii = np.sum(radii)\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n            except Exception:\n                pass  # Keep the previous best if optimization fails\n\n    # Final refinement with multi-stage optimization - Simplified for efficiency\n    remaining_time = max_time - (time.time() - start_time)\n    if remaining_time > 3 and best_centers is not None:\n        try:\n            centers, radii = refine_packing(best_centers, best_radii)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception:\n            pass  # Keep the previous best if optimization fails\n\n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26, with larger circles in the center\n    and corners, and smaller circles to fill gaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place a large circle in the center\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.135\n\n    # Place 6 circles in the first hexagonal ring\n    first_ring_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + first_ring_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = first_ring_radius\n\n    # Place 12 circles in the second hexagonal ring\n    second_ring_radius = 0.09\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*first_ring_radius + second_ring_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = second_ring_radius\n\n    # Place 4 larger circles in the corners\n    corner_radius = 0.12\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n\n    # Place 3 medium circles to fill remaining spaces\n    medium_radius = 0.08\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = medium_radius\n\n    return centers, radii\n\ndef initialize_pattern_hybrid_variable_26():\n    \"\"\"\n    Initialize with a hybrid pattern using variable-sized circles arranged in a pattern\n    that combines hexagonal and square grid elements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.105\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Central circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.13\n\n    # 8 circles in inner ring around center\n    inner_radius = 0.1\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n\n    # 9 circles in outer positions\n    outer_radius = 0.075\n    positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.25, 0.5), (0.75, 0.5), (0.33, 0.33), (0.67, 0.33), (0.67, 0.67)\n    ]\n    \n    for i, pos in enumerate(positions):\n        centers[17+i] = pos\n        radii[17+i] = outer_radius\n\n    return centers, radii\n\ndef initialize_pattern_optimized_corners_26():\n    \"\"\"\n    Initialize with a pattern that optimizes corner and edge utilization with\n    variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.13\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 8 edge circles (2 on each edge)\n    edge_radius = 0.095\n    edge_positions = [0.3, 0.7]\n    \n    # Bottom edge\n    centers[4] = [edge_positions[0], edge_radius]\n    centers[5] = [edge_positions[1], edge_radius]\n    \n    # Top edge\n    centers[6] = [edge_positions[0], 1-edge_radius]\n    centers[7] = [edge_positions[1], 1-edge_radius]\n    \n    # Left edge\n    centers[8] = [edge_radius, edge_positions[0]]\n    centers[9] = [edge_radius, edge_positions[1]]\n    \n    # Right edge\n    centers[10] = [1-edge_radius, edge_positions[0]]\n    centers[11] = [1-edge_radius, edge_positions[1]]\n    \n    radii[4:12] = edge_radius\n\n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.115\n\n    # Inner grid (13 circles)\n    inner_radius = 0.08\n    grid_positions = [\n        (0.5, 0.3), (0.5, 0.7),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),\n        (0.4, 0.4), (0.6, 0.4), (0.4, 0.6), (0.6, 0.6),\n        (0.5, 0.5)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        if i < 13:  # Ensure we don't exceed 26 circles\n            centers[13+i] = pos\n            if pos == (0.5, 0.5):  # Center of grid gets slightly larger radius\n                radii[13+i] = 0.09\n            else:\n                radii[13+i] = inner_radius\n\n    return centers, radii\n\ndef initialize_pattern_concentric_26():\n    \"\"\"\n    Initialize with concentric rings of circles with carefully chosen radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.14\n\n    # First ring (6 circles)\n    ring1_radius = 0.11\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = ring1_radius\n\n    # Second ring (10 circles)\n    ring2_radius = 0.09\n    for i in range(10):\n        angle = 2 * np.pi * i / 10 + np.pi/10\n        dist = radii[0] + 2*ring1_radius + ring2_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = ring2_radius\n\n    # Corner circles (4 circles)\n    corner_radius = 0.12\n    centers[17] = [corner_radius, corner_radius]\n    centers[18] = [1-corner_radius, corner_radius]\n    centers[19] = [corner_radius, 1-corner_radius]\n    centers[20] = [1-corner_radius, 1-corner_radius]\n    radii[17:21] = corner_radius\n\n    # Edge circles (5 circles)\n    edge_radius = 0.08\n    centers[21] = [0.5, edge_radius]\n    centers[22] = [0.5, 1-edge_radius]\n    centers[23] = [edge_radius, 0.5]\n    centers[24] = [1-edge_radius, 0.5]\n    centers[25] = [0.25, 0.25]  # Extra circle to fill a gap\n    radii[21:26] = edge_radius\n\n    return centers, radii\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically designed for n=26 based on mathematical research.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.123\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.108\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place 8 medium-small circles at intermediate edge positions\n    mid_edge_radius = 0.095\n    centers[8] = [0.25, mid_edge_radius]\n    centers[9] = [0.75, mid_edge_radius]\n    centers[10] = [0.25, 1-mid_edge_radius]\n    centers[11] = [0.75, 1-mid_edge_radius]\n    centers[12] = [mid_edge_radius, 0.25]\n    centers[13] = [mid_edge_radius, 0.75]\n    centers[14] = [1-mid_edge_radius, 0.25]\n    centers[15] = [1-mid_edge_radius, 0.75]\n    radii[8:16] = mid_edge_radius\n\n    # Place a large circle in the center\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.135\n\n    # Place 9 smaller circles in a grid pattern\n    small_radius = 0.075\n    grid_positions = [\n        (0.3, 0.3), (0.5, 0.3), (0.7, 0.3),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.7), (0.5, 0.7), (0.7, 0.7),\n        (0.4, 0.4)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        centers[17+i] = pos\n        radii[17+i] = small_radius\n\n    return centers, radii\n\ndef initialize_pattern_random_26():\n    \"\"\"\n    Initialize with random circle positions and radii\n    \"\"\"\n    n = 26\n    centers = np.random.rand(n, 2) * 0.8 + 0.1  # Ensure circles are within bounds\n    radii = np.random.rand(n) * 0.07 + 0.06   # Radii between 0.06 and 0.13\n    return centers, radii\n\n\ndef optimize_packing(centers, radii, iterations=100, quick=False):\n    \"\"\"\n    Optimize circle positions and radii using a simple gradient descent approach.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        iterations: Number of optimization iterations\n        quick: If True, perform a faster but less thorough optimization\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        sum_radii = np.sum(current_radii)\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -sum_radii + penalty\n    \n    # Initial guess\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds for centers and radii\n    center_bounds = [(0.01, 0.99)] * (2 * n)\n    radii_bounds = [(0.03, 0.2)] * n\n    bounds = center_bounds + radii_bounds\n    \n    # Define optimization parameters\n    if quick:\n        options = {'maxiter': min(iterations, 30), 'ftol': 1e-5}\n    else:\n        options = {'maxiter': iterations, 'ftol': 1e-6}\n    \n    # Perform optimization\n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds, options=options)\n    \n    # Extract optimized centers and radii\n    final_centers = result.x[:2*n].reshape((n, 2))\n    final_radii = result.x[2*n:]\n    \n    return final_centers, final_radii\n\ndef refine_packing(centers, radii):\n    \"\"\"\n    Simplified refinement stage to improve packing.\n    \"\"\"\n    n = len(centers)\n    \n    # Perturb positions of smaller circles\n    sorted_indices = np.argsort(radii)\n    for i in range(min(5, n)):  # Perturb the smallest 5 circles\n        idx = sorted_indices[i]\n        centers[idx] += np.random.normal(0, 0.02, size=2)\n    \n    # Adjust radii slightly\n    radii *= 1.005  # Increase radii by a small amount\n    \n    # Re-optimize with reduced iterations\n    centers, radii = optimize_packing(centers, radii, iterations=30, quick=True)\n    \n    return centers, radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Uses a smooth, differentiable penalty function for better optimization.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    overlap_penalty_factor = 1000\n    boundary_penalty_factor = 1000\n    \n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                # Use a quadratic penalty with radius-dependent scaling\n                penalty += overlap_penalty_factor * overlap**2 * (radii[i] + radii[j])\n    \n    # Penalty for circles outside the unit square\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n    \n    return penalty\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "1dcb44da-abd9-4784-89c2-82a4c264b608", "generation": 7, "timestamp": 1750926762.2849925, "iteration_found": 33, "metrics": {"validity": 0.0, "sum_radii": 0.0, "target_ratio": 0.0, "combined_score": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"stage1_passed": 0.0, "error": 0.0, "timeout": true}, "island": 3}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.645 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.636, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - stage1_passed: 0.0000\n- error: 0.0000\n- timeout: 1.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n## Last Execution Output\n\n### timeout\n```\nTrue\n```\n\n### timeout_duration\n```\n200\n```\n\n### failure_stage\n```\nstage1\n```\n\n### error_type\n```\ntimeout\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6360, target_ratio: 1.0004, combined_score: 1.0004, eval_time: 43.1799\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6228, target_ratio: 0.9954, combined_score: 0.9954, eval_time: 117.8238\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6073, target_ratio: 0.9895, combined_score: 0.9895, eval_time: 132.5911\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 9.7633)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6360), Performs well on target_ratio (1.0004), Performs well on combined_score (1.0004), Performs well on eval_time (43.1799)\n\n\n### Program 2 (Score: 27.6355)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6073), Performs well on target_ratio (0.9895), Performs well on combined_score (0.9895), Performs well on eval_time (132.5911)\n\n\n### Program 3 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a gradient-based optimization refinement step, a dynamic penalty function, and a more sophisticated initial pattern selection. It also includes a better handling of edge cases to prevent circles from escaping the unit square. This version focuses on more aggressive gradient descent and simulated annealing in the optimization routine.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n\n### Program 4 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy. It uses a simulated annealing approach for escaping local minima and introduces a scaling factor to the penalty function to better handle different stages of the optimization. Further optimizations include a refined custom step function for basin hopping and dynamic temperature adjustments.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport logging\nimport random\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n# ... (truncated)\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square, implementing specialized geometric patterns and multi-stage optimization techniques to maximize the sum of radii. This implementation uses hybrid patterns with variable-sized circles, targeted perturbation strategies, and adaptive penalty functions to escape local optima.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    start_time = time.time()\n    max_time = 40  # Increased max time\n\n    # Define pattern generation functions in order of expected performance\n    patterns = [\n        initialize_pattern_hybrid_variable_26,  # Prioritize this pattern\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_optimized_corners_26,\n        initialize_pattern_concentric_26,\n        initialize_pattern_specialized_26\n    ]\n\n    # First pass: try each pattern with basic optimization\n    for pattern_func in patterns:\n        if time.time() - start_time > max_time:\n            break\n            \n        try:\n            centers, radii = pattern_func()\n            \n            # Ensure we have exactly 26 circles\n            assert centers.shape[0] == n, f\"Pattern function returned {centers.shape[0]} circles instead of {n}\"\n            \n            # Quick optimization to improve the pattern\n            centers, radii = optimize_packing(centers, radii, iterations=40, quick=True)  # Reduced iterations for speed\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            continue\n\n    # Second pass: intensive optimization on the best pattern\n    if best_centers is not None:\n        remaining_time = max_time - (time.time() - start_time)\n        if remaining_time > 5:  # Only if we have enough time left\n            try:\n                centers, radii = optimize_packing(best_centers, best_radii, \n                                                 iterations=150,  # Reduced iterations for speed\n                                                 quick=False)\n                \n                sum_radii = np.sum(radii)\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n            except Exception:\n                pass  # Keep the previous best if optimization fails\n\n    # Final refinement with multi-stage optimization - Simplified for efficiency\n    remaining_time = max_time - (time.time() - start_time)\n    if remaining_time > 3 and best_centers is not None:\n        try:\n            centers, radii = refine_packing(best_centers, best_radii)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception:\n            pass  # Keep the previous best if optimization fails\n\n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26, with larger circles in the center\n    and corners, and smaller circles to fill gaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place a large circle in the center\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.135\n\n    # Place 6 circles in the first hexagonal ring\n    first_ring_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + first_ring_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = first_ring_radius\n\n    # Place 12 circles in the second hexagonal ring\n    second_ring_radius = 0.09\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*first_ring_radius + second_ring_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = second_ring_radius\n\n    # Place 4 larger circles in the corners\n    corner_radius = 0.12\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n\n    # Place 3 medium circles to fill remaining spaces\n    medium_radius = 0.08\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = medium_radius\n\n    return centers, radii\n\ndef initialize_pattern_hybrid_variable_26():\n    \"\"\"\n    Initialize with a hybrid pattern using variable-sized circles arranged in a pattern\n    that combines hexagonal and square grid elements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.105\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Central circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.13\n\n    # 8 circles in inner ring around center\n    inner_radius = 0.1\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n\n    # 9 circles in outer positions\n    outer_radius = 0.075\n    positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.25, 0.5), (0.75, 0.5), (0.33, 0.33), (0.67, 0.33), (0.67, 0.67)\n    ]\n    \n    for i, pos in enumerate(positions):\n        centers[17+i] = pos\n        radii[17+i] = outer_radius\n\n    return centers, radii\n\ndef initialize_pattern_optimized_corners_26():\n    \"\"\"\n    Initialize with a pattern that optimizes corner and edge utilization with\n    variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.13\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 8 edge circles (2 on each edge)\n    edge_radius = 0.095\n    edge_positions = [0.3, 0.7]\n    \n    # Bottom edge\n    centers[4] = [edge_positions[0], edge_radius]\n    centers[5] = [edge_positions[1], edge_radius]\n    \n    # Top edge\n    centers[6] = [edge_positions[0], 1-edge_radius]\n    centers[7] = [edge_positions[1], 1-edge_radius]\n    \n    # Left edge\n    centers[8] = [edge_radius, edge_positions[0]]\n    centers[9] = [edge_radius, edge_positions[1]]\n    \n    # Right edge\n    centers[10] = [1-edge_radius, edge_positions[0]]\n    centers[11] = [1-edge_radius, edge_positions[1]]\n    \n    radii[4:12] = edge_radius\n\n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.115\n\n    # Inner grid (13 circles)\n    inner_radius = 0.08\n    grid_positions = [\n        (0.5, 0.3), (0.5, 0.7),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),\n        (0.4, 0.4), (0.6, 0.4), (0.4, 0.6), (0.6, 0.6),\n        (0.5, 0.5)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        if i < 13:  # Ensure we don't exceed 26 circles\n            centers[13+i] = pos\n            if pos == (0.5, 0.5):  # Center of grid gets slightly larger radius\n                radii[13+i] = 0.09\n            else:\n                radii[13+i] = inner_radius\n\n    return centers, radii\n\ndef initialize_pattern_concentric_26():\n    \"\"\"\n    Initialize with concentric rings of circles with carefully chosen radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.14\n\n    # First ring (6 circles)\n    ring1_radius = 0.11\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = ring1_radius\n\n    # Second ring (10 circles)\n    ring2_radius = 0.09\n    for i in range(10):\n        angle = 2 * np.pi * i / 10 + np.pi/10\n        dist = radii[0] + 2*ring1_radius + ring2_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = ring2_radius\n\n    # Corner circles (4 circles)\n    corner_radius = 0.12\n    centers[17] = [corner_radius, corner_radius]\n    centers[18] = [1-corner_radius, corner_radius]\n    centers[19] = [corner_radius, 1-corner_radius]\n    centers[20] = [1-corner_radius, 1-corner_radius]\n    radii[17:21] = corner_radius\n\n    # Edge circles (5 circles)\n    edge_radius = 0.08\n    centers[21] = [0.5, edge_radius]\n    centers[22] = [0.5, 1-edge_radius]\n    centers[23] = [edge_radius, 0.5]\n    centers[24] = [1-edge_radius, 0.5]\n    centers[25] = [0.25, 0.25]  # Extra circle to fill a gap\n    radii[21:26] = edge_radius\n\n    return centers, radii\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically designed for n=26 based on mathematical research.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.123\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.108\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place 8 medium-small circles at intermediate edge positions\n    mid_edge_radius = 0.095\n    centers[8] = [0.25, mid_edge_radius]\n    centers[9] = [0.75, mid_edge_radius]\n    centers[10] = [0.25, 1-mid_edge_radius]\n    centers[11] = [0.75, 1-mid_edge_radius]\n    centers[12] = [mid_edge_radius, 0.25]\n    centers[13] = [mid_edge_radius, 0.75]\n    centers[14] = [1-mid_edge_radius, 0.25]\n    centers[15] = [1-mid_edge_radius, 0.75]\n    radii[8:16] = mid_edge_radius\n\n    # Place a large circle in the center\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.135\n\n    # Place 9 smaller circles in a grid pattern\n    small_radius = 0.075\n    grid_positions = [\n        (0.3, 0.3), (0.5, 0.3), (0.7, 0.3),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.7), (0.5, 0.7), (0.7, 0.7),\n        (0.4, 0.4)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        centers[17+i] = pos\n        radii[17+i] = small_radius\n\n    return centers, radii\n\ndef optimize_packing(centers, radii, iterations=100, quick=False):\n    \"\"\"\n    Optimize circle positions and radii using a combination of global and local optimization.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        iterations: Number of optimization iterations\n        quick: If True, perform a faster but less thorough optimization\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        sum_radii = np.sum(current_radii)\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -sum_radii + penalty\n    \n    # Initial guess\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds for centers and radii\n    center_bounds = [(0.01, 0.99)] * (2 * n)\n    radii_bounds = [(0.03, 0.2)] * n\n    bounds = center_bounds + radii_bounds\n    \n    # Define the step-taking function for basin hopping\n    def take_step(x):\n        \"\"\"Custom step function that perturbs the configuration intelligently.\"\"\"\n        centers_part = x[:2*n].reshape((n, 2))\n        radii_part = x[2*n:]\n        \n        # Perturb centers with small random displacements\n        centers_step = np.random.normal(0, 0.008, size=2*n)  # Reduced step size\n        \n        # Perturb radii with smaller displacements, scaled by current radius\n        radii_step = np.random.normal(0, 0.0015, size=n) * (1.0 + radii_part) # Reduced step size\n        \n        # Combine the steps\n        return x + np.concatenate([centers_step, radii_step])\n    \n    # Define optimization parameters\n    if quick:\n        niter = min(iterations, 40) # Reduced iterations\n        T = 0.4  # Reduced temperature\n        stepsize = 0.08  # Reduced stepsize\n        minimizer_kwargs = {\n            \"method\": \"L-BFGS-B\", \n            \"bounds\": bounds,\n            \"options\": {'maxiter': 40, 'ftol': 1e-6} # Reduced iterations\n        }\n    else:\n        niter = iterations\n        T = 0.8  # Reduced temperature\n        stepsize = 0.15 # Reduced stepsize\n        minimizer_kwargs = {\n            \"method\": \"L-BFGS-B\", \n            \"bounds\": bounds,\n            \"options\": {'maxiter': 80, 'ftol': 1e-7} # Reduced iterations\n        }\n    \n    # Perform basin hopping optimization\n    result = basinhopping(\n        objective, x0, \n        niter=niter,\n        T=T,\n        stepsize=stepsize,\n        minimizer_kwargs=minimizer_kwargs,\n        take_step=take_step\n    )\n    \n    # Extract optimized centers and radii\n    final_centers = result.x[:2*n].reshape((n, 2))\n    final_radii = result.x[2*n:]\n    \n    return final_centers, final_radii\n\ndef refine_packing(centers, radii):\n    \"\"\"\n    Simplified refinement stage to improve packing.\n    \"\"\"\n    n = len(centers)\n    \n    # Perturb positions of smaller circles\n    sorted_indices = np.argsort(radii)\n    for i in range(min(5, n)):  # Perturb the smallest 5 circles\n        idx = sorted_indices[i]\n        centers[idx] += np.random.normal(0, 0.02, size=2)\n    \n    # Adjust radii slightly\n    radii *= 1.005  # Increase radii by a small amount\n    \n    # Re-optimize with reduced iterations\n    centers, radii = optimize_packing(centers, radii, iterations=30, quick=True)\n    \n    return centers, radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Uses a smooth, differentiable penalty function for better optimization.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    overlap_penalty_factor = 1000\n    boundary_penalty_factor = 1000\n    \n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                # Use a quadratic penalty with radius-dependent scaling\n                penalty += overlap_penalty_factor * overlap**2 * (radii[i] + radii[j])\n    \n    # Penalty for circles outside the unit square\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n    \n    return penalty\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square, implementing specialized geometric patterns and multi-stage optimization techniques to maximize the sum of radii. This implementation uses hybrid patterns with variable-sized circles, targeted perturbation strategies, and adaptive penalty functions to escape local optima. This version focuses on SIMPLER optimization and increased pattern diversity.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport random\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    start_time = time.time()\n    max_time = 40  # Increased max time\n\n    # Define pattern generation functions in order of expected performance\n    patterns = [\n        initialize_pattern_hybrid_variable_26,  # Prioritize this pattern\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_optimized_corners_26,\n        initialize_pattern_concentric_26,\n        initialize_pattern_specialized_26,\n        initialize_pattern_random_26 #Adding random initialization\n    ]\n\n    # First pass: try each pattern with basic optimization\n    for pattern_func in patterns:\n        if time.time() - start_time > max_time:\n            break\n            \n        try:\n            centers, radii = pattern_func()\n            \n            # Ensure we have exactly 26 circles\n            assert centers.shape[0] == n, f\"Pattern function returned {centers.shape[0]} circles instead of {n}\"\n            \n            # Quick optimization to improve the pattern\n            centers, radii = optimize_packing(centers, radii, iterations=30, quick=True)  # Reduced iterations for speed\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            continue\n\n    # Second pass: intensive optimization on the best pattern\n    if best_centers is not None:\n        remaining_time = max_time - (time.time() - start_time)\n        if remaining_time > 5:  # Only if we have enough time left\n            try:\n                centers, radii = optimize_packing(best_centers, best_radii, \n                                                 iterations=100,  # Reduced iterations for speed\n                                                 quick=False)\n                \n                sum_radii = np.sum(radii)\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n            except Exception:\n                pass  # Keep the previous best if optimization fails\n\n    # Final refinement with multi-stage optimization - Simplified for efficiency\n    remaining_time = max_time - (time.time() - start_time)\n    if remaining_time > 3 and best_centers is not None:\n        try:\n            centers, radii = refine_packing(best_centers, best_radii)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception:\n            pass  # Keep the previous best if optimization fails\n\n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26, with larger circles in the center\n    and corners, and smaller circles to fill gaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place a large circle in the center\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.135\n\n    # Place 6 circles in the first hexagonal ring\n    first_ring_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + first_ring_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = first_ring_radius\n\n    # Place 12 circles in the second hexagonal ring\n    second_ring_radius = 0.09\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*first_ring_radius + second_ring_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = second_ring_radius\n\n    # Place 4 larger circles in the corners\n    corner_radius = 0.12\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n\n    # Place 3 medium circles to fill remaining spaces\n    medium_radius = 0.08\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = medium_radius\n\n    return centers, radii\n\ndef initialize_pattern_hybrid_variable_26():\n    \"\"\"\n    Initialize with a hybrid pattern using variable-sized circles arranged in a pattern\n    that combines hexagonal and square grid elements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.105\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Central circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.13\n\n    # 8 circles in inner ring around center\n    inner_radius = 0.1\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n\n    # 9 circles in outer positions\n    outer_radius = 0.075\n    positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.25, 0.5), (0.75, 0.5), (0.33, 0.33), (0.67, 0.33), (0.67, 0.67)\n    ]\n    \n    for i, pos in enumerate(positions):\n        centers[17+i] = pos\n        radii[17+i] = outer_radius\n\n    return centers, radii\n\ndef initialize_pattern_optimized_corners_26():\n    \"\"\"\n    Initialize with a pattern that optimizes corner and edge utilization with\n    variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.13\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 8 edge circles (2 on each edge)\n    edge_radius = 0.095\n    edge_positions = [0.3, 0.7]\n    \n    # Bottom edge\n    centers[4] = [edge_positions[0], edge_radius]\n    centers[5] = [edge_positions[1], edge_radius]\n    \n    # Top edge\n    centers[6] = [edge_positions[0], 1-edge_radius]\n    centers[7] = [edge_positions[1], 1-edge_radius]\n    \n    # Left edge\n    centers[8] = [edge_radius, edge_positions[0]]\n    centers[9] = [edge_radius, edge_positions[1]]\n    \n    # Right edge\n    centers[10] = [1-edge_radius, edge_positions[0]]\n    centers[11] = [1-edge_radius, edge_positions[1]]\n    \n    radii[4:12] = edge_radius\n\n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.115\n\n    # Inner grid (13 circles)\n    inner_radius = 0.08\n    grid_positions = [\n        (0.5, 0.3), (0.5, 0.7),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),\n        (0.4, 0.4), (0.6, 0.4), (0.4, 0.6), (0.6, 0.6),\n        (0.5, 0.5)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        if i < 13:  # Ensure we don't exceed 26 circles\n            centers[13+i] = pos\n            if pos == (0.5, 0.5):  # Center of grid gets slightly larger radius\n                radii[13+i] = 0.09\n            else:\n                radii[13+i] = inner_radius\n\n    return centers, radii\n\ndef initialize_pattern_concentric_26():\n    \"\"\"\n    Initialize with concentric rings of circles with carefully chosen radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.14\n\n    # First ring (6 circles)\n    ring1_radius = 0.11\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = ring1_radius\n\n    # Second ring (10 circles)\n    ring2_radius = 0.09\n    for i in range(10):\n        angle = 2 * np.pi * i / 10 + np.pi/10\n        dist = radii[0] + 2*ring1_radius + ring2_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = ring2_radius\n\n    # Corner circles (4 circles)\n    corner_radius = 0.12\n    centers[17] = [corner_radius, corner_radius]\n    centers[18] = [1-corner_radius, corner_radius]\n    centers[19] = [corner_radius, 1-corner_radius]\n    centers[20] = [1-corner_radius, 1-corner_radius]\n    radii[17:21] = corner_radius\n\n    # Edge circles (5 circles)\n    edge_radius = 0.08\n    centers[21] = [0.5, edge_radius]\n    centers[22] = [0.5, 1-edge_radius]\n    centers[23] = [edge_radius, 0.5]\n    centers[24] = [1-edge_radius, 0.5]\n    centers[25] = [0.25, 0.25]  # Extra circle to fill a gap\n    radii[21:26] = edge_radius\n\n    return centers, radii\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically designed for n=26 based on mathematical research.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.123\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.108\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place 8 medium-small circles at intermediate edge positions\n    mid_edge_radius = 0.095\n    centers[8] = [0.25, mid_edge_radius]\n    centers[9] = [0.75, mid_edge_radius]\n    centers[10] = [0.25, 1-mid_edge_radius]\n    centers[11] = [0.75, 1-mid_edge_radius]\n    centers[12] = [mid_edge_radius, 0.25]\n    centers[13] = [mid_edge_radius, 0.75]\n    centers[14] = [1-mid_edge_radius, 0.25]\n    centers[15] = [1-mid_edge_radius, 0.75]\n    radii[8:16] = mid_edge_radius\n\n    # Place a large circle in the center\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.135\n\n    # Place 9 smaller circles in a grid pattern\n    small_radius = 0.075\n    grid_positions = [\n        (0.3, 0.3), (0.5, 0.3), (0.7, 0.3),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.7), (0.5, 0.7), (0.7, 0.7),\n        (0.4, 0.4)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        centers[17+i] = pos\n        radii[17+i] = small_radius\n\n    return centers, radii\n\ndef initialize_pattern_random_26():\n    \"\"\"\n    Initialize with random circle positions and radii\n    \"\"\"\n    n = 26\n    centers = np.random.rand(n, 2) * 0.8 + 0.1  # Ensure circles are within bounds\n    radii = np.random.rand(n) * 0.07 + 0.06   # Radii between 0.06 and 0.13\n    return centers, radii\n\n\ndef optimize_packing(centers, radii, iterations=100, quick=False):\n    \"\"\"\n    Optimize circle positions and radii using a simple gradient descent approach.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        iterations: Number of optimization iterations\n        quick: If True, perform a faster but less thorough optimization\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        sum_radii = np.sum(current_radii)\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -sum_radii + penalty\n    \n    # Initial guess\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds for centers and radii\n    center_bounds = [(0.01, 0.99)] * (2 * n)\n    radii_bounds = [(0.03, 0.2)] * n\n    bounds = center_bounds + radii_bounds\n    \n    # Define optimization parameters\n    if quick:\n        options = {'maxiter': min(iterations, 30), 'ftol': 1e-5}\n    else:\n        options = {'maxiter': iterations, 'ftol': 1e-6}\n    \n    # Perform optimization\n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds, options=options)\n    \n    # Extract optimized centers and radii\n    final_centers = result.x[:2*n].reshape((n, 2))\n    final_radii = result.x[2*n:]\n    \n    return final_centers, final_radii\n\ndef refine_packing(centers, radii):\n    \"\"\"\n    Simplified refinement stage to improve packing.\n    \"\"\"\n    n = len(centers)\n    \n    # Perturb positions of smaller circles\n    sorted_indices = np.argsort(radii)\n    for i in range(min(5, n)):  # Perturb the smallest 5 circles\n        idx = sorted_indices[i]\n        centers[idx] += np.random.normal(0, 0.02, size=2)\n    \n    # Adjust radii slightly\n    radii *= 1.005  # Increase radii by a small amount\n    \n    # Re-optimize with reduced iterations\n    centers, radii = optimize_packing(centers, radii, iterations=30, quick=True)\n    \n    return centers, radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Uses a smooth, differentiable penalty function for better optimization.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    overlap_penalty_factor = 1000\n    boundary_penalty_factor = 1000\n    \n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                # Use a quadratic penalty with radius-dependent scaling\n                penalty += overlap_penalty_factor * overlap**2 * (radii[i] + radii[j])\n    \n    # Penalty for circles outside the unit square\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n    \n    return penalty\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```"]}}}