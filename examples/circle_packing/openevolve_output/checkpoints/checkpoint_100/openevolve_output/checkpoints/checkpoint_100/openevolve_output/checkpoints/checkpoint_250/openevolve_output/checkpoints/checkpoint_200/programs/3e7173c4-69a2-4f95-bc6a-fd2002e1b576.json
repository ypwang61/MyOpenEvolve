{"id": "3e7173c4-69a2-4f95-bc6a-fd2002e1b576", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and multi-stage optimization techniques. This implementation leverages mathematical insights from circle packing theory with variable-sized circles, strategic pattern selection, and a hybrid optimization approach to maximize the sum of radii toward the theoretical target of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Start with the most promising patterns\n    patterns = [\n        initialize_pattern_specialized_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_corner_optimized_26,\n        initialize_pattern_ring_26\n    ]\n    \n    start_time = time.time()\n    time_limit = 25  # Set a time limit to ensure we don't timeout\n    \n    for pattern_func in patterns:\n        # Check if we're approaching the time limit\n        if time.time() - start_time > time_limit:\n            break\n            \n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function {pattern_func.__name__} returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization\n        try:\n            # Multi-stage optimization approach\n            # 1. First optimize with Nelder-Mead for rough positioning\n            centers, radii = optimize_nelder_mead(centers, radii)\n            \n            # 2. Apply basin-hopping to escape local minima\n            centers, radii = optimize_basin_hopping(centers, radii)\n            \n            # 3. Final refinement with direct radius maximization\n            radii = maximize_radii(centers, radii)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n        except Exception as e:\n            logging.warning(f\"Optimization failed for {pattern_func.__name__}: {e}\")\n            continue\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26 with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.135\n    \n    # First hexagonal ring (6 circles)\n    inner_radius = 0.108\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n    \n    # Second partial hexagonal ring (12 circles)\n    middle_radius = 0.098\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * inner_radius + 0.002\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.118\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1 - corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1 - corner_radius]\n    centers[22] = [1 - corner_radius, 1 - corner_radius]\n    radii[19:23] = corner_radius\n    \n    # Edge circles (3 medium circles)\n    edge_radius = 0.092\n    centers[23] = [0.5, edge_radius]\n    centers[24] = [edge_radius, 0.5]\n    centers[25] = [1 - edge_radius, 0.5]\n    radii[23:26] = edge_radius\n    \n    return centers, radii\n\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place 4 large circles in corners\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.110\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.135\n    \n    # Place 8 circles in inner ring around center\n    inner_radius = 0.105\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n    \n    # Place 6 circles in outer positions\n    outer_radius = 0.078\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi/6\n        dist = 0.41\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = outer_radius\n    \n    # Adjust remaining circles\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.25, 0.25]\n    radii[23:26] = 0.082\n    \n    return centers, radii\n\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.136\n    \n    # Inner ring (6 circles)\n    inner_radius = 0.110\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n    \n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.100\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius + 0.001\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.120\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n    \n    # Edge circles (4 medium circles)\n    edge_radius = 0.095\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n    \n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.080\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = small_radius\n    \n    return centers, radii\n\n\ndef initialize_pattern_corner_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal corner and edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # 4 large corner circles\n    corner_radius = 0.130\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # 4 medium edge circles\n    edge_radius = 0.105\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # 8 smaller edge circles\n    small_edge_radius = 0.090\n    centers[8] = [0.25, small_edge_radius]\n    centers[9] = [0.75, small_edge_radius]\n    centers[10] = [0.25, 1 - small_edge_radius]\n    centers[11] = [0.75, 1 - small_edge_radius]\n    centers[12] = [small_edge_radius, 0.25]\n    centers[13] = [small_edge_radius, 0.75]\n    centers[14] = [1 - small_edge_radius, 0.25]\n    centers[15] = [1 - small_edge_radius, 0.75]\n    radii[8:16] = small_edge_radius\n    \n    # Center circle\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.120\n    \n    # Inner grid (9 circles)\n    inner_radius = 0.085\n    grid_positions = [0.3, 0.5, 0.7]\n    \n    count = 17\n    for x in grid_positions:\n        for y in grid_positions:\n            if not (x == 0.5 and y == 0.5):  # Skip center as it's already placed\n                centers[count] = [x, y]\n                radii[count] = inner_radius\n                count += 1\n                if count >= n:\n                    break\n        if count >= n:\n            break\n    \n    return centers, radii\n\n\ndef initialize_pattern_ring_26():\n    \"\"\"\n    Initialize with concentric rings of circles, optimized for n=26.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.140\n    \n    # First ring (8 circles)\n    ring1_radius = 0.105\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = ring1_radius\n    \n    # Second ring (12 circles)\n    ring2_radius = 0.095\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * ring1_radius + ring2_radius + 0.001\n        centers[i + 9] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 9] = ring2_radius\n    \n    # Corner circles (4 circles)\n    corner_radius = 0.100\n    centers[21] = [corner_radius, corner_radius]\n    centers[22] = [1 - corner_radius, corner_radius]\n    centers[23] = [corner_radius, 1 - corner_radius]\n    centers[24] = [1 - corner_radius, 1 - corner_radius]\n    radii[21:25] = corner_radius\n    \n    # One extra circle\n    centers[25] = [0.5, 0.15]\n    radii[25] = 0.090\n    \n    return centers, radii\n\n\ndef optimize_nelder_mead(centers, radii, max_iter=1000):\n    \"\"\"\n    Optimizes circle positions and radii using Nelder-Mead method.\n    \"\"\"\n    n = len(centers)\n\n    def objective(x):\n        # Extract centers and radii from flattened array\n        c = x[:2 * n].reshape(n, 2)\n        r = x[2 * n:]\n\n        # Penalty for circles outside the boundaries\n        boundary_penalty = 0.0\n        for i in range(n):\n            boundary_penalty += max(0, (r[i] - c[i, 0]) * 100)  # Left boundary\n            boundary_penalty += max(0, (r[i] + c[i, 0] - 1) * 100)  # Right boundary\n            boundary_penalty += max(0, (r[i] - c[i, 1]) * 100)  # Bottom boundary\n            boundary_penalty += max(0, (r[i] + c[i, 1] - 1) * 100)  # Top boundary\n\n        # Penalty for overlapping circles\n        overlap_penalty = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                overlap = r[i] + r[j] - dist\n                if overlap > 0:\n                    overlap_penalty += overlap * 150  # Increased penalty\n\n        # Objective: Maximize sum of radii (minimize negative sum)\n        return -np.sum(r) + boundary_penalty + overlap_penalty\n\n    # Flatten the centers and radii for optimization\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Set bounds: centers in [0,1], radii in [0.01, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0.01, 0.5)] * n\n\n    # Run optimization with constraints\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='Nelder-Mead',\n            bounds=bounds,\n            options={'maxiter': max_iter, 'adaptive': True}\n        )\n\n        # Extract optimized centers and radii\n        opt_centers = result.x[:2 * n].reshape(n, 2)\n        opt_radii = result.x[2 * n:]\n\n        return opt_centers, opt_radii\n\n    except Exception as e:\n        logging.warning(f\"Nelder-Mead optimization failed: {e}\")\n        return centers, radii\n\n\ndef optimize_basin_hopping(centers, radii, n_iter=20):\n    \"\"\"\n    Optimizes circle positions and radii using Basin-Hopping to escape local minima.\n    \"\"\"\n    n = len(centers)\n\n    def objective(x):\n        # Extract centers and radii from flattened array\n        c = x[:2 * n].reshape(n, 2)\n        r = x[2 * n:]\n\n        # Penalty for circles outside the boundaries\n        boundary_penalty = 0.0\n        for i in range(n):\n            boundary_penalty += max(0, (r[i] - c[i, 0]) * 200)  # Left boundary\n            boundary_penalty += max(0, (r[i] + c[i, 0] - 1) * 200)  # Right boundary\n            boundary_penalty += max(0, (r[i] - c[i, 1]) * 200)  # Bottom boundary\n            boundary_penalty += max(0, (r[i] + c[i, 1] - 1) * 200)  # Top boundary\n\n        # Penalty for overlapping circles\n        overlap_penalty = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                overlap = r[i] + r[j] - dist\n                if overlap > 0:\n                    overlap_penalty += overlap * 200  # Higher penalty for overlaps\n\n        # Objective: Maximize sum of radii (minimize negative sum)\n        return -np.sum(r) + boundary_penalty + overlap_penalty\n\n    # Custom step function for basin hopping\n    def take_step(x):\n        # Extract centers and radii\n        c = x[:2 * n].reshape(n, 2)\n        r = x[2 * n:]\n        \n        # Perturb centers slightly\n        c_new = c + np.random.normal(0, 0.02, c.shape)\n        \n        # Perturb radii slightly\n        r_new = r * (1 + np.random.normal(0, 0.05, r.shape))\n        \n        # Ensure bounds\n        c_new = np.clip(c_new, 0, 1)\n        r_new = np.clip(r_new, 0.01, 0.5)\n        \n        # Flatten and return\n        return np.concatenate([c_new.flatten(), r_new])\n\n    # Flatten the centers and radii for optimization\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Set bounds: centers in [0,1], radii in [0.01, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0.01, 0.5)] * n\n    \n    # Define a minimizer for use within basin-hopping\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": bounds,\n        \"options\": {\"ftol\": 1e-5, \"maxiter\": 100}\n    }\n\n    # Run basin-hopping optimization\n    try:\n        result = basinhopping(\n            objective,\n            x0,\n            niter=n_iter,\n            T=0.5,  # Temperature parameter\n            stepsize=0.1,  # Initial step size\n            take_step=take_step,\n            minimizer_kwargs=minimizer_kwargs,\n            interval=5  # Adjust step size every 5 iterations\n        )\n\n        # Extract optimized centers and radii\n        opt_centers = result.x[:2 * n].reshape(n, 2)\n        opt_radii = result.x[2 * n:]\n\n        return opt_centers, opt_radii\n\n    except Exception as e:\n        logging.warning(f\"Basin-hopping optimization failed: {e}\")\n        return centers, radii\n\n\ndef maximize_radii(centers, radii):\n    \"\"\"\n    Maximizes the radii of all circles while maintaining constraints.\n    Uses an iterative approach with variable growth rates.\n    \"\"\"\n    n = len(centers)\n    new_radii = radii.copy()\n    \n    # First pass: calculate maximum possible radius for each circle\n    for i in range(n):\n        # Maximum radius based on distance to boundaries\n        max_radius_boundary = min(\n            centers[i, 0],              # Distance to left\n            1 - centers[i, 0],          # Distance to right\n            centers[i, 1],              # Distance to bottom\n            1 - centers[i, 1]           # Distance to top\n        )\n        \n        # Maximum radius based on distance to other circles\n        max_radius_circles = float('inf')\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_radius_circles = min(max_radius_circles, dist - new_radii[j])\n        \n        # Set radius to the minimum of the two constraints, with a small safety margin\n        new_radii[i] = min(max_radius_boundary, max_radius_circles) * 0.99\n    \n    # Second pass: iterative growth with conflict resolution\n    # Try to grow circles that have more space around them\n    growth_potential = np.ones(n) * 0.01  # Initial growth rate\n    \n    for _ in range(10):  # More iterations for better results\n        # Grow all radii according to their potential\n        test_radii = new_radii + growth_potential\n        \n        # Check for boundary violations\n        for i in range(n):\n            if (centers[i, 0] - test_radii[i] < 0 or \n                centers[i, 0] + test_radii[i] > 1 or\n                centers[i, 1] - test_radii[i] < 0 or\n                centers[i, 1] + test_radii[i] > 1):\n                # Reset to maximum allowed by boundary\n                max_boundary = min(\n                    centers[i, 0],\n                    1 - centers[i, 0],\n                    centers[i, 1],\n                    1 - centers[i, 1]\n                )\n                test_radii[i] = max_boundary\n                growth_potential[i] = 0  # Stop growing this circle\n        \n        # Check for overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < test_radii[i] + test_radii[j]:\n                    # Resolve conflict by reducing both radii proportionally\n                    overlap = test_radii[i] + test_radii[j] - dist\n                    if growth_potential[i] > 0 and growth_potential[j] > 0:\n                        ratio_i = test_radii[i] / (test_radii[i] + test_radii[j])\n                        ratio_j = test_radii[j] / (test_radii[i] + test_radii[j])\n                        test_radii[i] -= overlap * ratio_i * 1.01\n                        test_radii[j] -= overlap * ratio_j * 1.01\n                        # Reduce growth potential for both\n                        growth_potential[i] *= 0.5\n                        growth_potential[j] *= 0.5\n                    elif growth_potential[i] > 0:\n                        test_radii[i] = dist - test_radii[j]\n                        growth_potential[i] *= 0.5\n                    elif growth_potential[j] > 0:\n                        test_radii[j] = dist - test_radii[i]\n                        growth_potential[j] *= 0.5\n        \n        # Update radii\n        new_radii = test_radii.copy()\n        \n        # Reduce growth potential for next iteration\n        growth_potential *= 0.8\n    \n    # Final safety check to ensure no overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < new_radii[i] + new_radii[j]:\n                # Resolve conflict\n                overlap = new_radii[i] + new_radii[j] - dist\n                ratio_i = new_radii[i] / (new_radii[i] + new_radii[j])\n                ratio_j = new_radii[j] / (new_radii[i] + new_radii[j])\n                new_radii[i] -= overlap * ratio_i * 1.01\n                new_radii[j] -= overlap * ratio_j * 1.01\n    \n    # Final boundary check\n    for i in range(n):\n        new_radii[i] = min(new_radii[i], \n                          centers[i, 0], \n                          1 - centers[i, 0],\n                          centers[i, 1],\n                          1 - centers[i, 1])\n    \n    return np.clip(new_radii, 0.01, 0.5)  # Ensure minimum and maximum radius\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "0c77346c-f42d-4632-b9d3-33891467e48c", "generation": 8, "timestamp": 1750950693.9757447, "iteration_found": 177, "metrics": {"validity": 1.0, "sum_radii": 2.19677369731072, "target_ratio": 0.8336902077080532, "combined_score": 0.8336902077080532, "eval_time": 90.02985644340515}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.413260538868845, "target_ratio": 0.9158484018477591, "combined_score": 0.9158484018477591, "eval_time": 12.85507869720459}, "island": 4}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.645 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.636, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - validity: 1.0000\n- sum_radii: 2.4133\n- target_ratio: 0.9158\n- combined_score: 0.9158\n- eval_time: 12.8551\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: sum_radii, target_ratio, combined_score, eval_time. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.5846, target_ratio: 0.9809, combined_score: 0.9809, eval_time: 183.1378\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.5701, target_ratio: 0.9754, combined_score: 0.9754, eval_time: 184.1761\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6093, target_ratio: 0.9902, combined_score: 0.9902, eval_time: 190.7207\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 9.7633)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6360), Performs well on target_ratio (1.0004), Performs well on combined_score (1.0004), Performs well on eval_time (43.1799)\n\n\n### Program 2 (Score: 39.2621)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using mathematical insights and specialized optimization techniques to maximize the sum of radii toward the target of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6093), Performs well on target_ratio (0.9902), Performs well on combined_score (0.9902), Performs well on eval_time (190.7207)\n\n\n### Program 3 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square, implementing specialized geometric patterns and multi-stage optimization techniques to maximize the sum of radii. This implementation uses hybrid patterns with variable-sized circles, targeted perturbation strategies, and adaptive penalty functions to escape local optima. This version focuses on improved penalty functions, smarter initialization, and adaptive optimization parameters.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef construct_packing():\n# ... (truncated for brevity)\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n\n### Program 4 (Score: 2.2678)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using a multi-stage optimization approach with specialized geometric patterns to maximize the sum of radii toward the target value of 2.645. This implementation leverages mathematical insights from circle packing theory and incorporates a dynamic penalty function.  It uses a simulated annealing approach for escaping local minima and introduces a scaling factor to the penalty function to better handle different stages of the optimization. Further optimizations include a refined custom step function for basin hopping and dynamic temperature adjustments.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6041), Performs well on target_ratio (0.9883), Performs well on combined_score (0.9883), Performs well on eval_time (5.7585)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 4.9888)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This implementation uses a hybrid approach with variable-sized circles, targeted perturbation strategies, and a multi-stage optimization process to maximize the sum of radii toward the theoretical target of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n# ... (truncated)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This implementation focuses on a gradient-free optimization approach combined with carefully tuned initial patterns and radius adjustments to maximize the sum of radii toward the theoretical target of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Start with the most promising patterns first\n    patterns = [\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_specialized_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_corner_optimized_26,\n        initialize_pattern_ring_26\n    ]\n    \n    start_time = time.time()\n    time_limit = 25  # Set a time limit to ensure we don't timeout\n    \n    for pattern_func in patterns:\n        # Check if we're approaching the time limit\n        if time.time() - start_time > time_limit:\n            break\n            \n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function {pattern_func.__name__} returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization\n        try:\n            # Use a gradient-free optimization method\n            centers, radii = optimize_gradient_free(centers, radii)\n\n            # Final refinement\n            radii = maximize_radii(centers, radii)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n        except Exception as e:\n            logging.warning(f\"Optimization failed for {pattern_func.__name__}: {e}\")\n            continue\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26 with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.130\n    \n    # First hexagonal ring (6 circles)\n    inner_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n    \n    # Second partial hexagonal ring (12 circles)\n    middle_radius = 0.095\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * inner_radius + 0.002\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.115\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1 - corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1 - corner_radius]\n    centers[22] = [1 - corner_radius, 1 - corner_radius]\n    radii[19:23] = corner_radius\n    \n    # Edge circles (3 medium circles)\n    edge_radius = 0.090\n    centers[23] = [0.5, edge_radius]\n    centers[24] = [edge_radius, 0.5]\n    centers[25] = [1 - edge_radius, 0.5]\n    radii[23:26] = edge_radius\n    \n    return centers, radii\n\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place 4 large circles in corners\n    corner_radius = 0.123\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.107\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.132\n    \n    # Place 8 circles in inner ring around center\n    inner_radius = 0.102\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n    \n    # Place 6 circles in outer ring\n    outer_radius = 0.076\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi/6\n        dist = 0.40\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = outer_radius\n    \n    # Adjust remaining circles\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.25, 0.25]\n    radii[23:26] = 0.080\n    \n    return centers, radii\n\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.133\n    \n    # Inner ring (6 circles)\n    inner_radius = 0.107\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n    \n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.097\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius + 0.001\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.118\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n    \n    # Edge circles (4 medium circles)\n    edge_radius = 0.092\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n    \n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.077\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = small_radius\n    \n    return centers, radii\n\n\ndef initialize_pattern_corner_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal corner and edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # 4 large corner circles\n    corner_radius = 0.127\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # 4 medium edge circles\n    edge_radius = 0.102\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # 8 smaller edge circles\n    small_edge_radius = 0.087\n    centers[8] = [0.25, small_edge_radius]\n    centers[9] = [0.75, small_edge_radius]\n    centers[10] = [0.25, 1 - small_edge_radius]\n    centers[11] = [0.75, 1 - small_edge_radius]\n    centers[12] = [small_edge_radius, 0.25]\n    centers[13] = [small_edge_radius, 0.75]\n    centers[14] = [1 - small_edge_radius, 0.25]\n    centers[15] = [1 - small_edge_radius, 0.75]\n    radii[8:16] = small_edge_radius\n    \n    # Center circle\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.117\n    \n    # Inner grid (9 circles)\n    inner_radius = 0.082\n    grid_positions = [0.3, 0.5, 0.7]\n    \n    count = 17\n    for x in grid_positions:\n        for y in grid_positions:\n            if not (x == 0.5 and y == 0.5):  # Skip center as it's already placed\n                centers[count] = [x, y]\n                radii[count] = inner_radius\n                count += 1\n                if count >= n:\n                    break\n        if count >= n:\n            break\n    \n    return centers, radii\n\n\ndef initialize_pattern_ring_26():\n    \"\"\"\n    Initialize with concentric rings of circles, optimized for n=26.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.137\n    \n    # First ring (8 circles)\n    ring1_radius = 0.102\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = ring1_radius\n    \n    # Second ring (12 circles)\n    ring2_radius = 0.092\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * ring1_radius + ring2_radius + 0.001\n        centers[i + 9] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 9] = ring2_radius\n    \n    # Corner circles (4 circles)\n    corner_radius = 0.097\n    centers[21] = [corner_radius, corner_radius]\n    centers[22] = [1 - corner_radius, corner_radius]\n    centers[23] = [corner_radius, 1 - corner_radius]\n    centers[24] = [1 - corner_radius, 1 - corner_radius]\n    radii[21:25] = corner_radius\n    \n    # One extra circle\n    centers[25] = [0.5, 0.15]\n    radii[25] = 0.087\n    \n    return centers, radii\n\n\ndef optimize_gradient_free(centers, radii):\n    \"\"\"\n    Optimizes circle positions and radii using a gradient-free optimization method (Nelder-Mead).\n    This method is less sensitive to local optima and doesn't require gradient calculations.\n    \"\"\"\n    n = len(centers)\n\n    def objective(x):\n        # Extract centers and radii from flattened array\n        c = x[:2 * n].reshape(n, 2)\n        r = x[2 * n:]\n\n        # Penalty for circles outside the boundaries\n        boundary_penalty = 0.0\n        for i in range(n):\n            boundary_penalty += max(0, (r[i] - c[i, 0]) * 100)  # Left boundary\n            boundary_penalty += max(0, (r[i] + c[i, 0] - 1) * 100)  # Right boundary\n            boundary_penalty += max(0, (r[i] - c[i, 1]) * 100)  # Bottom boundary\n            boundary_penalty += max(0, (r[i] + c[i, 1] - 1) * 100)  # Top boundary\n\n        # Penalty for overlapping circles\n        overlap_penalty = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                overlap = r[i] + r[j] - dist\n                overlap_penalty += max(0, overlap * 100)  # Increased penalty\n\n        # Objective: Minimize negative sum of radii + penalties\n        return -np.sum(r) + boundary_penalty + overlap_penalty\n\n    # Flatten the centers and radii for optimization\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Set bounds: centers in [0,1], radii in [0.01, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0.01, 0.5)] * n\n\n    # Run optimization with constraints\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='Nelder-Mead',  # Gradient-free method\n            bounds=bounds,\n            options={'maxiter': 2000, 'ftol': 1e-5, 'adaptive': True}  # Adjusted parameters\n        )\n\n        # Extract optimized centers and radii\n        opt_centers = result.x[:2 * n].reshape(n, 2)\n        opt_radii = result.x[2 * n:]\n\n        return opt_centers, opt_radii\n\n    except Exception as e:\n        logging.warning(f\"Gradient-free optimization failed: {e}\")\n        return centers, radii\n\n\ndef adjust_radii_to_prevent_overlaps(centers, radii):\n    \"\"\"\n    Adjusts radii to prevent overlaps between circles and with boundaries.\n    \"\"\"\n    n = len(centers)\n    new_radii = radii.copy()\n    \n    # Check for overlaps between circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                # Reduce both radii proportionally to their original sizes\n                overlap = radii[i] + radii[j] - dist\n                ratio_i = radii[i] / (radii[i] + radii[j])\n                ratio_j = radii[j] / (radii[i] + radii[j])\n                \n                new_radii[i] -= overlap * ratio_i * 0.5 # Reduced reduction\n                new_radii[j] -= overlap * ratio_j * 0.5 # Reduced reduction\n    \n    # Check for boundary overlaps\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - new_radii[i] < 0:\n            new_radii[i] = centers[i, 0]\n        \n        # Right boundary\n        if centers[i, 0] + new_radii[i] > 1:\n            new_radii[i] = 1 - centers[i, 0]\n        \n        # Bottom boundary\n        if centers[i, 1] - new_radii[i] < 0:\n            new_radii[i] = min(new_radii[i], centers[i, 1])\n        \n        # Top boundary\n        if centers[i, 1] + new_radii[i] > 1:\n            new_radii[i] = min(new_radii[i], 1 - centers[i, 1])\n    \n    return np.clip(new_radii, 0.01, 0.5)  # Ensure minimum radius\n\n\ndef maximize_radii(centers, radii):\n    \"\"\"\n    Maximizes the radii of all circles while maintaining constraints.\n    \"\"\"\n    n = len(centers)\n    new_radii = radii.copy()\n    \n    # Calculate the maximum possible radius for each circle\n    for i in range(n):\n        # Maximum radius based on distance to boundaries\n        max_radius_boundary = min(\n            centers[i, 0],              # Distance to left\n            1 - centers[i, 0],          # Distance to right\n            centers[i, 1],              # Distance to bottom\n            1 - centers[i, 1]           # Distance to top\n        )\n        \n        # Maximum radius based on distance to other circles\n        max_radius_circles = float('inf')\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_radius_circles = min(max_radius_circles, (dist - new_radii[j])*0.99) # Slightly reduce to prevent overlap\n        \n        # Set radius to the minimum of the two constraints\n        new_radii[i] = min(max_radius_boundary, max_radius_circles)\n    \n    # Iterative refinement to ensure no overlaps\n    for _ in range(3): # Reduced iterations for speed\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < new_radii[i] + new_radii[j]:\n                    # Reduce both radii proportionally\n                    overlap = new_radii[i] + new_radii[j] - dist\n                    ratio_i = new_radii[i] / (new_radii[i] + new_radii[j])\n                    ratio_j = new_radii[j] / (new_radii[i] + new_radii[j])\n                    \n                    new_radii[i] -= overlap * ratio_i * 1.01  # Slight extra reduction for stability\n                    new_radii[j] -= overlap * ratio_j * 1.01\n    \n    return np.clip(new_radii, 0.01, 0.5)  # Ensure minimum and maximum radius\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["Based on my analysis of the current program and the performance history, I'll rewrite the program to focus on breaking through the plateau and getting closer to the theoretical target of 2.645 for the sum of radii.\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and multi-stage optimization techniques. This implementation leverages mathematical insights from circle packing theory with variable-sized circles, strategic pattern selection, and a hybrid optimization approach to maximize the sum of radii toward the theoretical target of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Start with the most promising patterns\n    patterns = [\n        initialize_pattern_specialized_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_corner_optimized_26,\n        initialize_pattern_ring_26\n    ]\n    \n    start_time = time.time()\n    time_limit = 25  # Set a time limit to ensure we don't timeout\n    \n    for pattern_func in patterns:\n        # Check if we're approaching the time limit\n        if time.time() - start_time > time_limit:\n            break\n            \n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function {pattern_func.__name__} returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization\n        try:\n            # Multi-stage optimization approach\n            # 1. First optimize with Nelder-Mead for rough positioning\n            centers, radii = optimize_nelder_mead(centers, radii)\n            \n            # 2. Apply basin-hopping to escape local minima\n            centers, radii = optimize_basin_hopping(centers, radii)\n            \n            # 3. Final refinement with direct radius maximization\n            radii = maximize_radii(centers, radii)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n        except Exception as e:\n            logging.warning(f\"Optimization failed for {pattern_func.__name__}: {e}\")\n            continue\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26 with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.135\n    \n    # First hexagonal ring (6 circles)\n    inner_radius = 0.108\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n    \n    # Second partial hexagonal ring (12 circles)\n    middle_radius = 0.098\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * inner_radius + 0.002\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.118\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1 - corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1 - corner_radius]\n    centers[22] = [1 - corner_radius, 1 - corner_radius]\n    radii[19:23] = corner_radius\n    \n    # Edge circles (3 medium circles)\n    edge_radius = 0.092\n    centers[23] = [0.5, edge_radius]\n    centers[24] = [edge_radius, 0.5]\n    centers[25] = [1 - edge_radius, 0.5]\n    radii[23:26] = edge_radius\n    \n    return centers, radii\n\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place 4 large circles in corners\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.110\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.135\n    \n    # Place 8 circles in inner ring around center\n    inner_radius = 0.105\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n    \n    # Place 6 circles in outer positions\n    outer_radius = 0.078\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi/6\n        dist = 0.41\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = outer_radius\n    \n    # Adjust remaining circles\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.25, 0.25]\n    radii[23:26] = 0.082\n    \n    return centers, radii\n\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.136\n    \n    # Inner ring (6 circles)\n    inner_radius = 0.110\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n    \n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.100\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius + 0.001\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.120\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n    \n    # Edge circles (4 medium circles)\n    edge_radius = 0.095\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n    \n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.080\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = small_radius\n    \n    return centers, radii\n\n\ndef initialize_pattern_corner_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal corner and edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # 4 large corner circles\n    corner_radius = 0.130\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # 4 medium edge circles\n    edge_radius = 0.105\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # 8 smaller edge circles\n    small_edge_radius = 0.090\n    centers[8] = [0.25, small_edge_radius]\n    centers[9] = [0.75, small_edge_radius]\n    centers[10] = [0.25, 1 - small_edge_radius]\n    centers[11] = [0.75, 1 - small_edge_radius]\n    centers[12] = [small_edge_radius, 0.25]\n    centers[13] = [small_edge_radius, 0.75]\n    centers[14] = [1 - small_edge_radius, 0.25]\n    centers[15] = [1 - small_edge_radius, 0.75]\n    radii[8:16] = small_edge_radius\n    \n    # Center circle\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.120\n    \n    # Inner grid (9 circles)\n    inner_radius = 0.085\n    grid_positions = [0.3, 0.5, 0.7]\n    \n    count = 17\n    for x in grid_positions:\n        for y in grid_positions:\n            if not (x == 0.5 and y == 0.5):  # Skip center as it's already placed\n                centers[count] = [x, y]\n                radii[count] = inner_radius\n                count += 1\n                if count >= n:\n                    break\n        if count >= n:\n            break\n    \n    return centers, radii\n\n\ndef initialize_pattern_ring_26():\n    \"\"\"\n    Initialize with concentric rings of circles, optimized for n=26.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.140\n    \n    # First ring (8 circles)\n    ring1_radius = 0.105\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = ring1_radius\n    \n    # Second ring (12 circles)\n    ring2_radius = 0.095\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * ring1_radius + ring2_radius + 0.001\n        centers[i + 9] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 9] = ring2_radius\n    \n    # Corner circles (4 circles)\n    corner_radius = 0.100\n    centers[21] = [corner_radius, corner_radius]\n    centers[22] = [1 - corner_radius, corner_radius]\n    centers[23] = [corner_radius, 1 - corner_radius]\n    centers[24] = [1 - corner_radius, 1 - corner_radius]\n    radii[21:25] = corner_radius\n    \n    # One extra circle\n    centers[25] = [0.5, 0.15]\n    radii[25] = 0.090\n    \n    return centers, radii\n\n\ndef optimize_nelder_mead(centers, radii, max_iter=1000):\n    \"\"\"\n    Optimizes circle positions and radii using Nelder-Mead method.\n    \"\"\"\n    n = len(centers)\n\n    def objective(x):\n        # Extract centers and radii from flattened array\n        c = x[:2 * n].reshape(n, 2)\n        r = x[2 * n:]\n\n        # Penalty for circles outside the boundaries\n        boundary_penalty = 0.0\n        for i in range(n):\n            boundary_penalty += max(0, (r[i] - c[i, 0]) * 100)  # Left boundary\n            boundary_penalty += max(0, (r[i] + c[i, 0] - 1) * 100)  # Right boundary\n            boundary_penalty += max(0, (r[i] - c[i, 1]) * 100)  # Bottom boundary\n            boundary_penalty += max(0, (r[i] + c[i, 1] - 1) * 100)  # Top boundary\n\n        # Penalty for overlapping circles\n        overlap_penalty = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                overlap = r[i] + r[j] - dist\n                if overlap > 0:\n                    overlap_penalty += overlap * 150  # Increased penalty\n\n        # Objective: Maximize sum of radii (minimize negative sum)\n        return -np.sum(r) + boundary_penalty + overlap_penalty\n\n    # Flatten the centers and radii for optimization\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Set bounds: centers in [0,1], radii in [0.01, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0.01, 0.5)] * n\n\n    # Run optimization with constraints\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='Nelder-Mead',\n            bounds=bounds,\n            options={'maxiter': max_iter, 'adaptive': True}\n        )\n\n        # Extract optimized centers and radii\n        opt_centers = result.x[:2 * n].reshape(n, 2)\n        opt_radii = result.x[2 * n:]\n\n        return opt_centers, opt_radii\n\n    except Exception as e:\n        logging.warning(f\"Nelder-Mead optimization failed: {e}\")\n        return centers, radii\n\n\ndef optimize_basin_hopping(centers, radii, n_iter=20):\n    \"\"\"\n    Optimizes circle positions and radii using Basin-Hopping to escape local minima.\n    \"\"\"\n    n = len(centers)\n\n    def objective(x):\n        # Extract centers and radii from flattened array\n        c = x[:2 * n].reshape(n, 2)\n        r = x[2 * n:]\n\n        # Penalty for circles outside the boundaries\n        boundary_penalty = 0.0\n        for i in range(n):\n            boundary_penalty += max(0, (r[i] - c[i, 0]) * 200)  # Left boundary\n            boundary_penalty += max(0, (r[i] + c[i, 0] - 1) * 200)  # Right boundary\n            boundary_penalty += max(0, (r[i] - c[i, 1]) * 200)  # Bottom boundary\n            boundary_penalty += max(0, (r[i] + c[i, 1] - 1) * 200)  # Top boundary\n\n        # Penalty for overlapping circles\n        overlap_penalty = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                overlap = r[i] + r[j] - dist\n                if overlap > 0:\n                    overlap_penalty += overlap * 200  # Higher penalty for overlaps\n\n        # Objective: Maximize sum of radii (minimize negative sum)\n        return -np.sum(r) + boundary_penalty + overlap_penalty\n\n    # Custom step function for basin hopping\n    def take_step(x):\n        # Extract centers and radii\n        c = x[:2 * n].reshape(n, 2)\n        r = x[2 * n:]\n        \n        # Perturb centers slightly\n        c_new = c + np.random.normal(0, 0.02, c.shape)\n        \n        # Perturb radii slightly\n        r_new = r * (1 + np.random.normal(0, 0.05, r.shape))\n        \n        # Ensure bounds\n        c_new = np.clip(c_new, 0, 1)\n        r_new = np.clip(r_new, 0.01, 0.5)\n        \n        # Flatten and return\n        return np.concatenate([c_new.flatten(), r_new])\n\n    # Flatten the centers and radii for optimization\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Set bounds: centers in [0,1], radii in [0.01, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0.01, 0.5)] * n\n    \n    # Define a minimizer for use within basin-hopping\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": bounds,\n        \"options\": {\"ftol\": 1e-5, \"maxiter\": 100}\n    }\n\n    # Run basin-hopping optimization\n    try:\n        result = basinhopping(\n            objective,\n            x0,\n            niter=n_iter,\n            T=0.5,  # Temperature parameter\n            stepsize=0.1,  # Initial step size\n            take_step=take_step,\n            minimizer_kwargs=minimizer_kwargs,\n            interval=5  # Adjust step size every 5 iterations\n        )\n\n        # Extract optimized centers and radii\n        opt_centers = result.x[:2 * n].reshape(n, 2)\n        opt_radii = result.x[2 * n:]\n\n        return opt_centers, opt_radii\n\n    except Exception as e:\n        logging.warning(f\"Basin-hopping optimization failed: {e}\")\n        return centers, radii\n\n\ndef maximize_radii(centers, radii):\n    \"\"\"\n    Maximizes the radii of all circles while maintaining constraints.\n    Uses an iterative approach with variable growth rates.\n    \"\"\"\n    n = len(centers)\n    new_radii = radii.copy()\n    \n    # First pass: calculate maximum possible radius for each circle\n    for i in range(n):\n        # Maximum radius based on distance to boundaries\n        max_radius_boundary = min(\n            centers[i, 0],              # Distance to left\n            1 - centers[i, 0],          # Distance to right\n            centers[i, 1],              # Distance to bottom\n            1 - centers[i, 1]           # Distance to top\n        )\n        \n        # Maximum radius based on distance to other circles\n        max_radius_circles = float('inf')\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_radius_circles = min(max_radius_circles, dist - new_radii[j])\n        \n        # Set radius to the minimum of the two constraints, with a small safety margin\n        new_radii[i] = min(max_radius_boundary, max_radius_circles) * 0.99\n    \n    # Second pass: iterative growth with conflict resolution\n    # Try to grow circles that have more space around them\n    growth_potential = np.ones(n) * 0.01  # Initial growth rate\n    \n    for _ in range(10):  # More iterations for better results\n        # Grow all radii according to their potential\n        test_radii = new_radii + growth_potential\n        \n        # Check for boundary violations\n        for i in range(n):\n            if (centers[i, 0] - test_radii[i] < 0 or \n                centers[i, 0] + test_radii[i] > 1 or\n                centers[i, 1] - test_radii[i] < 0 or\n                centers[i, 1] + test_radii[i] > 1):\n                # Reset to maximum allowed by boundary\n                max_boundary = min(\n                    centers[i, 0],\n                    1 - centers[i, 0],\n                    centers[i, 1],\n                    1 - centers[i, 1]\n                )\n                test_radii[i] = max_boundary\n                growth_potential[i] = 0  # Stop growing this circle\n        \n        # Check for overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < test_radii[i] + test_radii[j]:\n                    # Resolve conflict by reducing both radii proportionally\n                    overlap = test_radii[i] + test_radii[j] - dist\n                    if growth_potential[i] > 0 and growth_potential[j] > 0:\n                        ratio_i = test_radii[i] / (test_radii[i] + test_radii[j])\n                        ratio_j = test_radii[j] / (test_radii[i] + test_radii[j])\n                        test_radii[i] -= overlap * ratio_i * 1.01\n                        test_radii[j] -= overlap * ratio_j * 1.01\n                        # Reduce growth potential for both\n                        growth_potential[i] *= 0.5\n                        growth_potential[j] *= 0.5\n                    elif growth_potential[i] > 0:\n                        test_radii[i] = dist - test_radii[j]\n                        growth_potential[i] *= 0.5\n                    elif growth_potential[j] > 0:\n                        test_radii[j] = dist - test_radii[i]\n                        growth_potential[j] *= 0.5\n        \n        # Update radii\n        new_radii = test_radii.copy()\n        \n        # Reduce growth potential for next iteration\n        growth_potential *= 0.8\n    \n    # Final safety check to ensure no overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < new_radii[i] + new_radii[j]:\n                # Resolve conflict\n                overlap = new_radii[i] + new_radii[j] - dist\n                ratio_i = new_radii[i] / (new_radii[i] + new_radii[j])\n                ratio_j = new_radii[j] / (new_radii[i] + new_radii[j])\n                new_radii[i] -= overlap * ratio_i * 1.01\n                new_radii[j] -= overlap * ratio_j * 1.01\n    \n    # Final boundary check\n    for i in range(n):\n        new_radii[i] = min(new_radii[i], \n                          centers[i, 0], \n                          1 - centers[i, 0],\n                          centers[i, 1],\n                          1 - centers[i, 1])\n    \n    return np.clip(new_radii, 0.01, 0.5)  # Ensure minimum and maximum radius\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```"]}}}