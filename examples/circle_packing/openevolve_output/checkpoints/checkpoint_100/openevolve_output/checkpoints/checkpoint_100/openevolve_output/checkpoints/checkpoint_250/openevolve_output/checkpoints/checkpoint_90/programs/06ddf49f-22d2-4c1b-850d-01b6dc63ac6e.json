{"id": "06ddf49f-22d2-4c1b-850d-01b6dc63ac6e", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using highly optimized patterns and mathematical insights to maximize the sum of radii toward the theoretical optimal value of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Prioritize patterns known to perform well for n=26\n    # Ordered from most promising to least promising based on previous results\n    patterns = [\n        initialize_hexagonal_26,\n        initialize_pattern_specialized_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_corner_optimized_26\n    ]\n    \n    start_time = time.time()\n    max_time = 180  # Maximum seconds to spend on optimization\n    \n    for pattern_idx, pattern_func in enumerate(patterns):\n        remaining_time = max_time - (time.time() - start_time)\n        if remaining_time < 10:  # Need at least 10 seconds for optimization\n            break\n            \n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization with time limit\n        try:\n            centers, radii = optimize_pattern(centers, radii, time_limit=remaining_time/2)\n            \n            # Refine the result with a second optimization pass\n            centers, radii = refine_optimization(centers, radii, time_limit=remaining_time/4)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n        except Exception as e:\n            # If optimization fails, continue with the next pattern\n            continue\n    \n    # If we didn't find any valid solution, use a fallback pattern\n    if best_centers is None:\n        best_centers, best_radii = initialize_hexagonal_26()\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26 with variable-sized circles.\n    This pattern is based on the densest known circle packing in a square.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Four corner circles\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Four edge circles\n    edge_radius = 0.105\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Center circle\n    center_radius = 0.135\n    centers[8] = [0.5, 0.5]\n    radii[8] = center_radius\n    \n    # Inner ring (6 circles)\n    inner_radius = 0.102\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = center_radius + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n    \n    # Outer ring (10 circles)\n    outer_radius = 0.084\n    for i in range(10):\n        angle = 2 * np.pi * i / 10 + np.pi/10\n        dist = 0.38\n        centers[15 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[15 + i] = outer_radius\n    \n    # Additional circles in gaps\n    gap_radius = 0.068\n    centers[25] = [0.25, 0.25]\n    radii[25] = gap_radius\n    \n    return centers, radii\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.123\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.108\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.132\n\n    # Place 6 circles in inner ring around center\n    inner_radius = 0.102\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[8] + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n\n    # Place 10 circles in outer ring\n    outer_radius = 0.078\n    for i in range(10):\n        angle = 2 * np.pi * i / 10 + np.pi/10\n        dist = 0.39\n        centers[15 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[15 + i] = outer_radius\n\n    # Additional circles in gaps\n    gap_radius = 0.066\n    centers[25] = [0.25, 0.25]\n    radii[25] = gap_radius\n\n    return centers, radii\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.134\n\n    # Inner ring (6 circles)\n    inner_radius = 0.104\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n\n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.092\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n\n    # Corner circles (4 larger circles)\n    corner_radius = 0.118\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n\n    # Edge circles (4 medium circles)\n    edge_radius = 0.094\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n\n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.076\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.25, 0.75]\n    radii[23:26] = small_radius\n\n    return centers, radii\n\ndef initialize_pattern_corner_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal corner and edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.127\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.103\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # 8 smaller edge circles\n    small_edge_radius = 0.088\n    centers[8] = [0.25, small_edge_radius]\n    centers[9] = [0.75, small_edge_radius]\n    centers[10] = [0.25, 1 - small_edge_radius]\n    centers[11] = [0.75, 1 - small_edge_radius]\n    centers[12] = [small_edge_radius, 0.25]\n    centers[13] = [small_edge_radius, 0.75]\n    centers[14] = [1 - small_edge_radius, 0.25]\n    centers[15] = [1 - small_edge_radius, 0.75]\n    radii[8:16] = small_edge_radius\n\n    # Center circle\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.116\n\n    # Inner grid (9 circles)\n    inner_radius = 0.083\n    grid_positions = [0.3, 0.5, 0.7]\n    \n    count = 17\n    for x in grid_positions:\n        for y in grid_positions:\n            if x == 0.5 and y == 0.5:\n                continue  # Skip center, already placed\n            centers[count] = [x, y]\n            radii[count] = inner_radius\n            count += 1\n            if count >= n:\n                break\n\n    return centers, radii\n\ndef optimize_pattern(centers, radii, time_limit=60):\n    \"\"\"\n    Optimize circle positions and radii using sequential optimization.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        time_limit: Maximum time in seconds to spend on optimization\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    start_time = time.time()\n    \n    # Define bounds for center coordinates and radii\n    # Tighter bounds for faster convergence\n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.05, 0.15)] * n\n    \n    def objective_function(x):\n        \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n        current_centers = x[:2 * n].reshape(n, 2)\n        current_radii = x[2 * n:]\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -np.sum(current_radii) + penalty\n    \n    # Initial guess\n    initial_guess = np.concatenate([centers.flatten(), radii])\n    \n    # First optimization pass - focus on positioning\n    options = {'maxiter': 200, 'ftol': 1e-6}\n    result = minimize(objective_function, initial_guess, method='L-BFGS-B', \n                      bounds=bounds, options=options)\n    \n    # Check if we have time for more optimization\n    if time.time() - start_time < time_limit - 5:\n        # Second pass - focus on radius optimization\n        optimized_centers = result.x[:2 * n].reshape(n, 2)\n        optimized_radii = result.x[2 * n:]\n        \n        # Adjust bounds to focus on radii\n        bounds_centers = [(max(0.0, c - 0.03), min(1.0, c + 0.03)) for c in optimized_centers.flatten()]\n        bounds_radii = [(max(0.05, r - 0.01), min(0.15, r + 0.02)) for r in optimized_radii]\n        bounds = bounds_centers + bounds_radii\n        \n        # Reoptimize with tighter bounds\n        initial_guess = np.concatenate([optimized_centers.flatten(), optimized_radii])\n        options = {'maxiter': 300, 'ftol': 1e-7}\n        result = minimize(objective_function, initial_guess, method='L-BFGS-B', \n                          bounds=bounds, options=options)\n    \n    # Extract final results\n    optimized_centers = result.x[:2 * n].reshape(n, 2)\n    optimized_radii = result.x[2 * n:]\n    \n    # Ensure all circles are valid\n    optimized_centers, optimized_radii = validate_and_adjust(optimized_centers, optimized_radii)\n    \n    return optimized_centers, optimized_radii\n\ndef refine_optimization(centers, radii, time_limit=30):\n    \"\"\"\n    Refine the optimization by focusing on specific circles and using perturbation.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        time_limit: Maximum time in seconds to spend on refinement\n        \n    Returns:\n        Tuple of (refined_centers, refined_radii)\n    \"\"\"\n    n = len(centers)\n    start_time = time.time()\n    \n    # Sort circles by radius to identify smaller ones for potential improvement\n    sorted_indices = np.argsort(radii)\n    \n    # Focus on the smallest 8 circles first\n    focus_indices = sorted_indices[:8]\n    \n    # Create a mask for the parameters we want to optimize\n    # Initially, we'll only optimize the smallest circles\n    param_mask = np.zeros(2 * n + n, dtype=bool)\n    for idx in focus_indices:\n        param_mask[2 * idx] = True      # x-coordinate\n        param_mask[2 * idx + 1] = True  # y-coordinate\n        param_mask[2 * n + idx] = True  # radius\n    \n    # Initial guess with only the parameters we're optimizing\n    full_params = np.concatenate([centers.flatten(), radii])\n    initial_guess = full_params[param_mask]\n    \n    def masked_objective(x):\n        \"\"\"Objective function that only varies the selected parameters.\"\"\"\n        full_x = full_params.copy()\n        full_x[param_mask] = x\n        current_centers = full_x[:2 * n].reshape(n, 2)\n        current_radii = full_x[2 * n:]\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -np.sum(current_radii) + penalty\n    \n    # Define bounds for the parameters we're optimizing\n    bounds = []\n    param_idx = 0\n    for i in range(2 * n + n):\n        if param_mask[i]:\n            if i < 2 * n:  # Center coordinate\n                bounds.append((max(0.0, full_params[i] - 0.05), min(1.0, full_params[i] + 0.05)))\n            else:  # Radius\n                circle_idx = i - 2 * n\n                bounds.append((max(0.05, radii[circle_idx] - 0.01), min(0.15, radii[circle_idx] + 0.03)))\n            param_idx += 1\n    \n    # Optimize the selected parameters\n    options = {'maxiter': 200, 'ftol': 1e-7}\n    result = minimize(masked_objective, initial_guess, method='L-BFGS-B', \n                      bounds=bounds, options=options)\n    \n    # Update the full parameter set\n    full_params[param_mask] = result.x\n    \n    # Check if we have time for more optimization\n    if time.time() - start_time < time_limit - 5:\n        # Second pass - focus on all circles\n        param_mask = np.ones(2 * n + n, dtype=bool)\n        initial_guess = full_params\n        \n        # Define bounds for all parameters\n        bounds = []\n        for i in range(2 * n):  # Center coordinates\n            bounds.append((max(0.0, initial_guess[i] - 0.03), min(1.0, initial_guess[i] + 0.03)))\n        for i in range(n):  # Radii\n            bounds.append((max(0.05, initial_guess[2 * n + i] - 0.01), min(0.15, initial_guess[2 * n + i] + 0.02)))\n        \n        # Final optimization\n        options = {'maxiter': 150, 'ftol': 1e-8}\n        result = minimize(masked_objective, initial_guess, method='L-BFGS-B', \n                          bounds=bounds, options=options)\n        full_params = result.x\n    \n    # Extract final results\n    refined_centers = full_params[:2 * n].reshape(n, 2)\n    refined_radii = full_params[2 * n:]\n    \n    # Ensure all circles are valid\n    refined_centers, refined_radii = validate_and_adjust(refined_centers, refined_radii)\n    \n    return refined_centers, refined_radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Used for optimization with an improved penalty function that better guides the optimizer.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    \n    # Penalty factors - tuned for optimal performance\n    overlap_penalty_factor = 800\n    boundary_penalty_factor = 800\n    \n    # Penalty for overlapping circles - quadratic penalty with radius scaling\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                # Scale penalty by the radii to prioritize larger circles\n                penalty += overlap_penalty_factor * overlap**2 * (radii[i] + radii[j])\n    \n    # Penalty for circles outside the unit square - stronger boundary enforcement\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n    \n    return penalty\n\ndef validate_and_adjust(centers, radii):\n    \"\"\"\n    Ensure all circles are valid by adjusting positions and radii if needed.\n    \n    Args:\n        centers: Circle centers\n        radii: Circle radii\n        \n    Returns:\n        Tuple of (adjusted_centers, adjusted_radii)\n    \"\"\"\n    n = len(centers)\n    adjusted_centers = centers.copy()\n    adjusted_radii = radii.copy()\n    \n    # Clip radii to valid range\n    adjusted_radii = np.clip(adjusted_radii, 0.05, 0.15)\n    \n    # Adjust centers to ensure circles are within bounds\n    for i in range(n):\n        # Ensure x-coordinate is valid\n        adjusted_centers[i, 0] = np.clip(adjusted_centers[i, 0], \n                                         adjusted_radii[i], \n                                         1.0 - adjusted_radii[i])\n        \n        # Ensure y-coordinate is valid\n        adjusted_centers[i, 1] = np.clip(adjusted_centers[i, 1], \n                                         adjusted_radii[i], \n                                         1.0 - adjusted_radii[i])\n    \n    # Check for overlaps and adjust radii if needed\n    max_iterations = 5\n    for _ in range(max_iterations):\n        overlap_found = False\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(adjusted_centers[i] - adjusted_centers[j])\n                overlap = adjusted_radii[i] + adjusted_radii[j] - dist\n                \n                if overlap > 1e-6:  # Small tolerance for numerical issues\n                    overlap_found = True\n                    \n                    # Reduce the radius of the smaller circle\n                    if adjusted_radii[i] <= adjusted_radii[j]:\n                        adjusted_radii[i] = max(0.05, adjusted_radii[i] - overlap/2)\n                    else:\n                        adjusted_radii[j] = max(0.05, adjusted_radii[j] - overlap/2)\n        \n        if not overlap_found:\n            break\n    \n    return adjusted_centers, adjusted_radii\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "aa303664-c59a-4f54-8b0f-761e7bb2a051", "generation": 8, "timestamp": 1750933267.2792563, "iteration_found": 71, "metrics": {"validity": 0.0, "sum_radii": 0.0, "target_ratio": 0.0, "combined_score": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"stage1_passed": 0.0, "error": 0.0, "timeout": true}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.645 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.636, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - stage1_passed: 0.0000\n- error: 0.0000\n- timeout: 1.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n## Last Execution Output\n\n### timeout\n```\nTrue\n```\n\n### timeout_duration\n```\n200\n```\n\n### failure_stage\n```\nstage1\n```\n\n### error_type\n```\ntimeout\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6202, target_ratio: 0.9944, combined_score: 0.9944, eval_time: 43.5821\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6228, target_ratio: 0.9954, combined_score: 0.9954, eval_time: 117.8238\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6073, target_ratio: 0.9895, combined_score: 0.9895, eval_time: 132.5911\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 9.7633)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6360), Performs well on target_ratio (1.0004), Performs well on combined_score (1.0004), Performs well on eval_time (43.1799)\n\n\n### Program 2 (Score: 27.6355)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6073), Performs well on target_ratio (0.9895), Performs well on combined_score (0.9895), Performs well on eval_time (132.5911)\n\n\n### Program 3 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square, implementing specialized geometric patterns and multi-stage optimization techniques to maximize the sum of radii. This implementation uses hybrid patterns with variable-sized circles, targeted perturbation strategies, and adaptive penalty functions to escape local optima.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n# ... (truncated for brevity)\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n\n### Program 4 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on error (Program execution failed: name 'INFO' is not defined)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square, implementing specialized geometric patterns and multi-stage optimization techniques to maximize the sum of radii. This implementation focuses on a simplified penalty function, aggressive radius adjustment, and a refined basin hopping optimization. Includes a dynamic radius scaling factor and individual radius scaling to fine-tune the sizes. Addressing stagnation by focusing on dynamic radius adjustment and more robust initialization. Removing proximity penalty and simplifying bounds.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n# ... (truncated)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using multi-stage optimization with specialized patterns and mathematical insights to maximize the sum of radii toward the theoretical optimal value of 2.645. This version introduces a more efficient optimization strategy and refined penalty function.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n\n    # Prioritize patterns known to perform well\n    patterns = [\n        initialize_pattern_specialized_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_corner_optimized_26,\n        initialize_pattern_ring_26,\n        initialize_pattern_billiard_26,\n        initialize_pattern_optimized_grid_26,\n        initialize_pattern_greedy_26\n    ]\n\n    for pattern_func in patterns:\n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function {pattern_func.__name__} returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization\n        try:\n            centers, radii = optimize_pattern(centers, radii)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            print(f\"Optimization failed for {pattern_func.__name__}: {e}\")\n            continue\n\n    return best_centers, best_radii, best_sum\n\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.121\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.106\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.127\n\n    # Place 8 circles in inner ring around center\n    inner_radius = 0.101\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n\n    # Place 6 circles in outer ring (adjusted from 10 to 9 to ensure we have exactly 26 circles)\n    outer_radius = 0.074\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi/6\n        dist = 0.40\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = outer_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.131\n\n    # Inner ring (6 circles)\n    inner_radius = 0.106\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n\n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.096\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius + 0.001\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n\n    # Corner circles (4 larger circles)\n    corner_radius = 0.116\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n\n    # Edge circles (4 medium circles)\n    edge_radius = 0.091\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n\n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.076\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = small_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_billiard_26():\n    \"\"\"\n    Initialize with a billiard-table inspired pattern with circles along the edges\n    and a triangular pattern in the center.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 corner circles\n    corner_radius = 0.116\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # 8 edge circles (2 on each edge)\n    edge_radius = 0.096\n    edge_positions = [0.3, 0.7]\n\n    # Bottom edge\n    centers[4] = [edge_positions[0], edge_radius]\n    centers[5] = [edge_positions[1], edge_radius]\n\n    # Top edge\n    centers[6] = [edge_positions[0], 1 - edge_radius]\n    centers[7] = [edge_positions[1], 1 - edge_radius]\n\n    # Left edge\n    centers[8] = [edge_radius, edge_positions[0]]\n    centers[9] = [edge_radius, edge_positions[1]]\n\n    # Right edge\n    centers[10] = [1 - edge_radius, edge_positions[0]]\n    centers[11] = [1 - edge_radius, edge_positions[1]]\n\n    radii[4:12] = edge_radius\n\n    # Triangular pattern in center (14 circles)\n    inner_radius = 0.086\n\n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.106  # Slightly larger center circle\n\n    # Inner hexagon (6 circles)\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[12] + inner_radius + 0.001\n        centers[13 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[13 + i] = inner_radius\n\n    # Outer partial ring (7 circles)\n    outer_radius = 0.081\n    for i in range(7):\n        angle = 2 * np.pi * i / 7 + np.pi / 7\n        dist = radii[12] + 2 * inner_radius + outer_radius + 0.001\n        centers[19 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[19 + i] = outer_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_corner_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal corner and edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.126\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.101\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # 8 smaller edge circles\n    small_edge_radius = 0.086\n    centers[8] = [0.25, small_edge_radius]\n    centers[9] = [0.75, small_edge_radius]\n    centers[10] = [0.25, 1 - small_edge_radius]\n    centers[11] = [0.75, 1 - small_edge_radius]\n    centers[12] = [small_edge_radius, 0.25]\n    centers[13] = [small_edge_radius, 0.75]\n    centers[14] = [1 - small_edge_radius, 0.25]\n    centers[15] = [1 - small_edge_radius, 0.75]\n    radii[8:16] = small_edge_radius\n\n    # Inner grid (10 circles)\n    inner_radius = 0.081\n    grid_positions = [0.3, 0.5, 0.7]\n    \n    count = 16\n    grid_points = []\n    for x in grid_positions:\n        for y in grid_positions:\n            grid_points.append((x, y))\n    \n    # Ensure we don't exceed 26 circles\n    for x, y in grid_points[:n-count]:\n        if x == 0.5 and y == 0.5:\n            # Larger circle in the center\n            centers[count] = [x, y]\n            radii[count] = 0.116\n        else:\n            centers[count] = [x, y]\n            radii[count] = inner_radius\n        count += 1\n\n    return centers, radii\n\n\ndef initialize_pattern_ring_26():\n    \"\"\"\n    Initialize with concentric rings of circles, optimized for n=26.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.136\n\n    # First ring (8 circles)\n    ring1_radius = 0.101\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = ring1_radius\n\n    # Second ring (12 circles)\n    ring2_radius = 0.091\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * ring1_radius + ring2_radius + 0.001\n        centers[i + 9] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 9] = ring2_radius\n\n    # Corner circles (4 circles)\n    corner_radius = 0.096\n    centers[21] = [corner_radius, corner_radius]\n    centers[22] = [1 - corner_radius, corner_radius]\n    centers[23] = [corner_radius, 1 - corner_radius]\n    centers[24] = [1 - corner_radius, 1 - corner_radius]\n    radii[21:25] = corner_radius\n\n    # One extra circle\n    centers[25] = [0.5, 0.15]\n    radii[25] = 0.086\n\n    return centers, radii\n\ndef initialize_pattern_optimized_grid_26():\n    \"\"\"\n    Initializes circles in an optimized grid-like pattern, focusing on even distribution and space filling.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Start with a rough grid\n    num_x = 6\n    num_y = 5  # Adjusted for 26 circles\n    \n    x_coords = np.linspace(0.1, 0.9, num_x)\n    y_coords = np.linspace(0.1, 0.9, num_y)\n\n    count = 0\n    for i in range(num_y):\n        for j in range(num_x):\n            if count < n:\n                centers[count, 0] = x_coords[j]\n                centers[count, 1] = y_coords[i]\n                radii[count] = 0.086  # Initial radius\n                count += 1\n            else:\n                break\n        if count >= n:\n            break\n            \n    # Adjust radii based on location - corners slightly larger\n    for i in range(n):\n        if (centers[i, 0] < 0.2 and centers[i, 1] < 0.2) or \\\n           (centers[i, 0] > 0.8 and centers[i, 1] < 0.2) or \\\n           (centers[i, 0] < 0.2 and centers[i, 1] > 0.8) or \\\n           (centers[i, 0] > 0.8 and centers[i, 1] > 0.8):\n            radii[i] = 0.091  # Slightly larger in the corners\n        elif centers[i, 0] == 0.5 and centers[i, 1] == 0.5:\n            radii[i] = 0.106  # Largest radius in the very center\n        else:\n            radii[i] = 0.081\n\n    return centers, radii\n\n\ndef initialize_pattern_greedy_26():\n    \"\"\"\n    Initialize with a greedy approach that places larger circles first\n    and then fills in with smaller ones.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Define initial positions for the first 5 circles (corners and center)\n    initial_positions = [\n        (0.126, 0.126),       # Bottom left corner\n        (0.874, 0.126),       # Bottom right corner\n        (0.126, 0.874),       # Top left corner\n        (0.874, 0.874),       # Top right corner\n        (0.5, 0.5)          # Center\n    ]\n    \n    # Initial radii for the first 5 circles\n    initial_radii = [0.126, 0.126, 0.126, 0.126, 0.146]\n    \n    for i in range(min(5, n)):\n        centers[i] = initial_positions[i]\n        radii[i] = initial_radii[i]\n    \n    # Place circles along the edges\n    edge_positions = [\n        (0.5, 0.1),         # Bottom edge\n        (0.5, 0.9),         # Top edge\n        (0.1, 0.5),         # Left edge\n        (0.9, 0.5),         # Right edge\n        (0.3, 0.1),         # Bottom edge\n        (0.7, 0.1),         # Bottom edge\n        (0.3, 0.9),         # Top edge\n        (0.7, 0.9),         # Top edge\n        (0.1, 0.3),         # Left edge\n        (0.1, 0.7),         # Left edge\n        (0.9, 0.3),         # Right edge\n        (0.9, 0.7)          # Right edge\n    ]\n    \n    edge_radii = [0.106, 0.106, 0.106, 0.106, 0.096, 0.096, 0.096, 0.096, 0.096, 0.096, 0.096, 0.096]\n    \n    for i in range(min(len(edge_positions), n-5)):\n        centers[i+5] = edge_positions[i]\n        radii[i+5] = edge_radii[i]\n    \n    # Place inner circles in a grid-like pattern\n    inner_positions = [\n        (0.3, 0.3),\n        (0.5, 0.3),\n        (0.7, 0.3),\n        (0.3, 0.5),\n        (0.7, 0.5),\n        (0.3, 0.7),\n        (0.5, 0.7),\n        (0.7, 0.7),\n        (0.4, 0.4)\n    ]\n    \n    inner_radii = [0.096, 0.096, 0.096, 0.096, 0.096, 0.096, 0.096, 0.096, 0.086]\n    \n    remaining_circles = n - (5 + len(edge_positions))\n    for i in range(min(len(inner_positions), remaining_circles)):\n        centers[i+5+len(edge_positions)] = inner_positions[i]\n        radii[i+5+len(edge_positions)] = inner_radii[i]\n    \n    return centers, radii\n\n\ndef optimize_pattern(centers, radii):\n    \"\"\"Optimize circle positions and radii using a combination of techniques.\"\"\"\n    n = len(centers)\n\n    # Define bounds for center coordinates and radii\n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.03, 0.2)] * n  # Radius bounds\n\n    def objective_function(x):\n        \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n        current_centers = x[:2 * n].reshape(n, 2)\n        current_radii = x[2 * n:]\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -np.sum(current_radii) + penalty  # Minimize -sum(radii) + penalty\n\n    # Initial guess\n    initial_guess = np.concatenate([centers.flatten(), radii])\n\n    # Optimization using L-BFGS-B\n    result = minimize(objective_function, initial_guess, method='L-BFGS-B', bounds=bounds,\n                       options={'maxiter': 1500, 'ftol': 1e-7, 'gtol': 1e-8})  # Increased iterations and tighter tolerance\n\n    optimized_centers = result.x[:2 * n].reshape(n, 2)\n    optimized_radii = result.x[2 * n:]\n\n    # Clip values to ensure validity\n    optimized_radii = np.clip(optimized_radii, 0.03, 0.2)\n    optimized_centers = np.clip(optimized_centers, optimized_radii.reshape(-1, 1), 1.0 - optimized_radii.reshape(-1, 1))\n\n    return optimized_centers, optimized_radii\n\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Used for optimization.  Increased penalty magnitude and added radius-dependent term.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    overlap_penalty_factor = 600  # Increased penalty\n    boundary_penalty_factor = 600 # Increased penalty\n    proximity_penalty_factor = 50\n\n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                penalty += overlap_penalty_factor * overlap**2 * (radii[i] + radii[j])\n\n    # Penalty for circles outside the unit square\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n\n    # Proximity penalty (discourage circles from being too close without overlapping)\n    min_distance_threshold = 0.005  # Tune this value\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            expected_distance = radii[i] + radii[j]\n            if dist < expected_distance + min_distance_threshold and dist > expected_distance:\n                 penalty += proximity_penalty_factor * (expected_distance + min_distance_threshold - dist)**2\n\n    return penalty\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["I'll rewrite the program to significantly improve its performance, focusing on breaking through the current plateau by using more advanced optimization techniques and specialized patterns for n=26 circles.\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using highly optimized patterns and mathematical insights to maximize the sum of radii toward the theoretical optimal value of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Prioritize patterns known to perform well for n=26\n    # Ordered from most promising to least promising based on previous results\n    patterns = [\n        initialize_hexagonal_26,\n        initialize_pattern_specialized_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_corner_optimized_26\n    ]\n    \n    start_time = time.time()\n    max_time = 180  # Maximum seconds to spend on optimization\n    \n    for pattern_idx, pattern_func in enumerate(patterns):\n        remaining_time = max_time - (time.time() - start_time)\n        if remaining_time < 10:  # Need at least 10 seconds for optimization\n            break\n            \n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization with time limit\n        try:\n            centers, radii = optimize_pattern(centers, radii, time_limit=remaining_time/2)\n            \n            # Refine the result with a second optimization pass\n            centers, radii = refine_optimization(centers, radii, time_limit=remaining_time/4)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n        except Exception as e:\n            # If optimization fails, continue with the next pattern\n            continue\n    \n    # If we didn't find any valid solution, use a fallback pattern\n    if best_centers is None:\n        best_centers, best_radii = initialize_hexagonal_26()\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26 with variable-sized circles.\n    This pattern is based on the densest known circle packing in a square.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Four corner circles\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Four edge circles\n    edge_radius = 0.105\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Center circle\n    center_radius = 0.135\n    centers[8] = [0.5, 0.5]\n    radii[8] = center_radius\n    \n    # Inner ring (6 circles)\n    inner_radius = 0.102\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = center_radius + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n    \n    # Outer ring (10 circles)\n    outer_radius = 0.084\n    for i in range(10):\n        angle = 2 * np.pi * i / 10 + np.pi/10\n        dist = 0.38\n        centers[15 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[15 + i] = outer_radius\n    \n    # Additional circles in gaps\n    gap_radius = 0.068\n    centers[25] = [0.25, 0.25]\n    radii[25] = gap_radius\n    \n    return centers, radii\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.123\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.108\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.132\n\n    # Place 6 circles in inner ring around center\n    inner_radius = 0.102\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[8] + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n\n    # Place 10 circles in outer ring\n    outer_radius = 0.078\n    for i in range(10):\n        angle = 2 * np.pi * i / 10 + np.pi/10\n        dist = 0.39\n        centers[15 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[15 + i] = outer_radius\n\n    # Additional circles in gaps\n    gap_radius = 0.066\n    centers[25] = [0.25, 0.25]\n    radii[25] = gap_radius\n\n    return centers, radii\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.134\n\n    # Inner ring (6 circles)\n    inner_radius = 0.104\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n\n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.092\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n\n    # Corner circles (4 larger circles)\n    corner_radius = 0.118\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n\n    # Edge circles (4 medium circles)\n    edge_radius = 0.094\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n\n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.076\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.25, 0.75]\n    radii[23:26] = small_radius\n\n    return centers, radii\n\ndef initialize_pattern_corner_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal corner and edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.127\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.103\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # 8 smaller edge circles\n    small_edge_radius = 0.088\n    centers[8] = [0.25, small_edge_radius]\n    centers[9] = [0.75, small_edge_radius]\n    centers[10] = [0.25, 1 - small_edge_radius]\n    centers[11] = [0.75, 1 - small_edge_radius]\n    centers[12] = [small_edge_radius, 0.25]\n    centers[13] = [small_edge_radius, 0.75]\n    centers[14] = [1 - small_edge_radius, 0.25]\n    centers[15] = [1 - small_edge_radius, 0.75]\n    radii[8:16] = small_edge_radius\n\n    # Center circle\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.116\n\n    # Inner grid (9 circles)\n    inner_radius = 0.083\n    grid_positions = [0.3, 0.5, 0.7]\n    \n    count = 17\n    for x in grid_positions:\n        for y in grid_positions:\n            if x == 0.5 and y == 0.5:\n                continue  # Skip center, already placed\n            centers[count] = [x, y]\n            radii[count] = inner_radius\n            count += 1\n            if count >= n:\n                break\n\n    return centers, radii\n\ndef optimize_pattern(centers, radii, time_limit=60):\n    \"\"\"\n    Optimize circle positions and radii using sequential optimization.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        time_limit: Maximum time in seconds to spend on optimization\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    start_time = time.time()\n    \n    # Define bounds for center coordinates and radii\n    # Tighter bounds for faster convergence\n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.05, 0.15)] * n\n    \n    def objective_function(x):\n        \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n        current_centers = x[:2 * n].reshape(n, 2)\n        current_radii = x[2 * n:]\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -np.sum(current_radii) + penalty\n    \n    # Initial guess\n    initial_guess = np.concatenate([centers.flatten(), radii])\n    \n    # First optimization pass - focus on positioning\n    options = {'maxiter': 200, 'ftol': 1e-6}\n    result = minimize(objective_function, initial_guess, method='L-BFGS-B', \n                      bounds=bounds, options=options)\n    \n    # Check if we have time for more optimization\n    if time.time() - start_time < time_limit - 5:\n        # Second pass - focus on radius optimization\n        optimized_centers = result.x[:2 * n].reshape(n, 2)\n        optimized_radii = result.x[2 * n:]\n        \n        # Adjust bounds to focus on radii\n        bounds_centers = [(max(0.0, c - 0.03), min(1.0, c + 0.03)) for c in optimized_centers.flatten()]\n        bounds_radii = [(max(0.05, r - 0.01), min(0.15, r + 0.02)) for r in optimized_radii]\n        bounds = bounds_centers + bounds_radii\n        \n        # Reoptimize with tighter bounds\n        initial_guess = np.concatenate([optimized_centers.flatten(), optimized_radii])\n        options = {'maxiter': 300, 'ftol': 1e-7}\n        result = minimize(objective_function, initial_guess, method='L-BFGS-B', \n                          bounds=bounds, options=options)\n    \n    # Extract final results\n    optimized_centers = result.x[:2 * n].reshape(n, 2)\n    optimized_radii = result.x[2 * n:]\n    \n    # Ensure all circles are valid\n    optimized_centers, optimized_radii = validate_and_adjust(optimized_centers, optimized_radii)\n    \n    return optimized_centers, optimized_radii\n\ndef refine_optimization(centers, radii, time_limit=30):\n    \"\"\"\n    Refine the optimization by focusing on specific circles and using perturbation.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        time_limit: Maximum time in seconds to spend on refinement\n        \n    Returns:\n        Tuple of (refined_centers, refined_radii)\n    \"\"\"\n    n = len(centers)\n    start_time = time.time()\n    \n    # Sort circles by radius to identify smaller ones for potential improvement\n    sorted_indices = np.argsort(radii)\n    \n    # Focus on the smallest 8 circles first\n    focus_indices = sorted_indices[:8]\n    \n    # Create a mask for the parameters we want to optimize\n    # Initially, we'll only optimize the smallest circles\n    param_mask = np.zeros(2 * n + n, dtype=bool)\n    for idx in focus_indices:\n        param_mask[2 * idx] = True      # x-coordinate\n        param_mask[2 * idx + 1] = True  # y-coordinate\n        param_mask[2 * n + idx] = True  # radius\n    \n    # Initial guess with only the parameters we're optimizing\n    full_params = np.concatenate([centers.flatten(), radii])\n    initial_guess = full_params[param_mask]\n    \n    def masked_objective(x):\n        \"\"\"Objective function that only varies the selected parameters.\"\"\"\n        full_x = full_params.copy()\n        full_x[param_mask] = x\n        current_centers = full_x[:2 * n].reshape(n, 2)\n        current_radii = full_x[2 * n:]\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -np.sum(current_radii) + penalty\n    \n    # Define bounds for the parameters we're optimizing\n    bounds = []\n    param_idx = 0\n    for i in range(2 * n + n):\n        if param_mask[i]:\n            if i < 2 * n:  # Center coordinate\n                bounds.append((max(0.0, full_params[i] - 0.05), min(1.0, full_params[i] + 0.05)))\n            else:  # Radius\n                circle_idx = i - 2 * n\n                bounds.append((max(0.05, radii[circle_idx] - 0.01), min(0.15, radii[circle_idx] + 0.03)))\n            param_idx += 1\n    \n    # Optimize the selected parameters\n    options = {'maxiter': 200, 'ftol': 1e-7}\n    result = minimize(masked_objective, initial_guess, method='L-BFGS-B', \n                      bounds=bounds, options=options)\n    \n    # Update the full parameter set\n    full_params[param_mask] = result.x\n    \n    # Check if we have time for more optimization\n    if time.time() - start_time < time_limit - 5:\n        # Second pass - focus on all circles\n        param_mask = np.ones(2 * n + n, dtype=bool)\n        initial_guess = full_params\n        \n        # Define bounds for all parameters\n        bounds = []\n        for i in range(2 * n):  # Center coordinates\n            bounds.append((max(0.0, initial_guess[i] - 0.03), min(1.0, initial_guess[i] + 0.03)))\n        for i in range(n):  # Radii\n            bounds.append((max(0.05, initial_guess[2 * n + i] - 0.01), min(0.15, initial_guess[2 * n + i] + 0.02)))\n        \n        # Final optimization\n        options = {'maxiter': 150, 'ftol': 1e-8}\n        result = minimize(masked_objective, initial_guess, method='L-BFGS-B', \n                          bounds=bounds, options=options)\n        full_params = result.x\n    \n    # Extract final results\n    refined_centers = full_params[:2 * n].reshape(n, 2)\n    refined_radii = full_params[2 * n:]\n    \n    # Ensure all circles are valid\n    refined_centers, refined_radii = validate_and_adjust(refined_centers, refined_radii)\n    \n    return refined_centers, refined_radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Used for optimization with an improved penalty function that better guides the optimizer.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    \n    # Penalty factors - tuned for optimal performance\n    overlap_penalty_factor = 800\n    boundary_penalty_factor = 800\n    \n    # Penalty for overlapping circles - quadratic penalty with radius scaling\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                # Scale penalty by the radii to prioritize larger circles\n                penalty += overlap_penalty_factor * overlap**2 * (radii[i] + radii[j])\n    \n    # Penalty for circles outside the unit square - stronger boundary enforcement\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n    \n    return penalty\n\ndef validate_and_adjust(centers, radii):\n    \"\"\"\n    Ensure all circles are valid by adjusting positions and radii if needed.\n    \n    Args:\n        centers: Circle centers\n        radii: Circle radii\n        \n    Returns:\n        Tuple of (adjusted_centers, adjusted_radii)\n    \"\"\"\n    n = len(centers)\n    adjusted_centers = centers.copy()\n    adjusted_radii = radii.copy()\n    \n    # Clip radii to valid range\n    adjusted_radii = np.clip(adjusted_radii, 0.05, 0.15)\n    \n    # Adjust centers to ensure circles are within bounds\n    for i in range(n):\n        # Ensure x-coordinate is valid\n        adjusted_centers[i, 0] = np.clip(adjusted_centers[i, 0], \n                                         adjusted_radii[i], \n                                         1.0 - adjusted_radii[i])\n        \n        # Ensure y-coordinate is valid\n        adjusted_centers[i, 1] = np.clip(adjusted_centers[i, 1], \n                                         adjusted_radii[i], \n                                         1.0 - adjusted_radii[i])\n    \n    # Check for overlaps and adjust radii if needed\n    max_iterations = 5\n    for _ in range(max_iterations):\n        overlap_found = False\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(adjusted_centers[i] - adjusted_centers[j])\n                overlap = adjusted_radii[i] + adjusted_radii[j] - dist\n                \n                if overlap > 1e-6:  # Small tolerance for numerical issues\n                    overlap_found = True\n                    \n                    # Reduce the radius of the smaller circle\n                    if adjusted_radii[i] <= adjusted_radii[j]:\n                        adjusted_radii[i] = max(0.05, adjusted_radii[i] - overlap/2)\n                    else:\n                        adjusted_radii[j] = max(0.05, adjusted_radii[j] - overlap/2)\n        \n        if not overlap_found:\n            break\n    \n    return adjusted_centers, adjusted_radii\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```\n\nThe key improvements in this rewritten program include:\n\n1. **Streamlined Optimization Strategy**: \n   - Implemented a multi-stage optimization approach with time limits to ensure the program completes within the timeout\n   - Added a focused refinement phase that targets the smallest circles first to improve overall packing density\n\n2. **Improved Initial Patterns**:\n   - Created a new hexagonal pattern that better leverages mathematical insights from optimal circle packing research\n   - Refined the specialized patterns with more precise initial placements\n   - Reduced the number of patterns to focus only on the most promising ones\n\n3. **Enhanced Penalty Function**:\n   - Strengthened the penalty factors for better convergence\n   - Improved scaling of penalties based on circle sizes\n\n4. **Validation and Adjustment**:\n   - Added a robust validation function that ensures all circles remain valid\n   - Implemented an iterative adjustment procedure to resolve overlaps\n\n5. **Efficiency Improvements**:\n   - Removed unnecessary logging that was slowing down execution\n   - Optimized the number of iterations in each optimization phase\n   - Added time limits to ensure the program completes within the timeout constraint\n\nThese changes should help break through the current plateau and push the sum of radii closer to the target of 2.645."]}}}