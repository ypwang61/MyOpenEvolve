{"id": "710ca863-c3ea-4d3a-88bb-e3444cec5c4a", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n\n    # Prioritize patterns known to perform well\n    patterns = [\n        initialize_pattern_specialized_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_corner_optimized_26,\n        initialize_pattern_ring_26,\n        initialize_pattern_billiard_26,\n        initialize_pattern_optimized_grid_26,\n        initialize_pattern_greedy_26\n    ]\n\n    for pattern_func in patterns:\n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function {pattern_func.__name__} returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization\n        try:\n            centers, radii = optimize_with_scipy(centers, radii)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            print(f\"Optimization failed for {pattern_func.__name__}: {e}\")\n            continue\n\n    return best_centers, best_radii, best_sum\n\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.118\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.103\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.124\n\n    # Place 8 circles in inner ring around center\n    inner_radius = 0.098\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n\n    # Place 2 circles in outer ring (adjusted from 10 to 9 to ensure we have exactly 26 circles)\n    outer_radius = 0.083\n    for i in range(2):\n        angle = 2 * np.pi * i / 2 + np.pi/2\n        dist = radii[8] + 2 * inner_radius + outer_radius + 0.01\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = outer_radius\n\n    # Place 6 circles in outer ring (adjusted from 10 to 9 to ensure we have exactly 26 circles)\n    outer_radius = 0.071\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi/6\n        dist = 0.25\n        centers[19 + i] = [0.15 + dist * np.cos(angle), 0.15 + dist * np.sin(angle)]\n        radii[19 + i] = outer_radius\n\n    # Place 3 circles in outer ring (adjusted from 10 to 9 to ensure we have exactly 26 circles)\n    outer_radius = 0.076\n    for i in range(3):\n        angle = 2 * np.pi * i / 3 + np.pi/3\n        dist = 0.25\n        centers[25 - 2 + i] = [0.85 + dist * np.cos(angle), 0.85 + dist * np.sin(angle)]\n        radii[25 - 2 + i] = outer_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.128\n\n    # Inner ring (6 circles)\n    inner_radius = 0.103\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n\n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.093\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n\n    # Corner circles (4 larger circles)\n    corner_radius = 0.113\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n\n    # Edge circles (4 medium circles)\n    edge_radius = 0.088\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n\n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.073\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.25, 0.75]\n    radii[23:26] = small_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_billiard_26():\n    \"\"\"\n    Initialize with a billiard-table inspired pattern with circles along the edges\n    and a triangular pattern in the center.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 corner circles\n    corner_radius = 0.113\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # 8 edge circles (2 on each edge)\n    edge_radius = 0.093\n    edge_positions = [0.3, 0.7]\n\n    # Bottom edge\n    centers[4] = [edge_positions[0], edge_radius]\n    centers[5] = [edge_positions[1], edge_radius]\n\n    # Top edge\n    centers[6] = [edge_positions[0], 1 - edge_radius]\n    centers[7] = [edge_positions[1], 1 - edge_radius]\n\n    # Left edge\n    centers[8] = [edge_radius, edge_positions[0]]\n    centers[9] = [edge_radius, edge_positions[1]]\n\n    # Right edge\n    centers[10] = [1 - edge_radius, edge_positions[0]]\n    centers[11] = [1 - edge_radius, edge_positions[1]]\n\n    radii[4:12] = edge_radius\n\n    # Triangular pattern in center (14 circles)\n    inner_radius = 0.083\n\n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.103  # Slightly larger center circle\n\n    # Inner hexagon (6 circles)\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[12] + inner_radius\n        centers[13 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[13 + i] = inner_radius\n\n    # Outer partial ring (7 circles)\n    outer_radius = 0.078\n    for i in range(7):\n        angle = 2 * np.pi * i / 7 + np.pi / 7\n        dist = radii[12] + 2 * inner_radius + outer_radius\n        centers[19 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[19 + i] = outer_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_corner_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal corner and edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.123\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.098\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # 8 smaller edge circles\n    small_edge_radius = 0.083\n    centers[8] = [0.25, small_edge_radius]\n    centers[9] = [0.75, small_edge_radius]\n    centers[10] = [0.25, 1 - small_edge_radius]\n    centers[11] = [0.75, 1 - small_edge_radius]\n    centers[12] = [small_edge_radius, 0.25]\n    centers[13] = [small_edge_radius, 0.75]\n    centers[14] = [1 - small_edge_radius, 0.25]\n    centers[15] = [1 - small_edge_radius, 0.75]\n    radii[8:16] = small_edge_radius\n\n    # Inner grid (10 circles)\n    inner_radius = 0.078\n    grid_positions = [0.3, 0.5, 0.7]\n    \n    count = 16\n    grid_points = []\n    for x in grid_positions:\n        for y in grid_positions:\n            grid_points.append((x, y))\n    \n    # Ensure we don't exceed 26 circles\n    for x, y in grid_points[:n-count]:\n        if x == 0.5 and y == 0.5:\n            # Larger circle in the center\n            centers[count] = [x, y]\n            radii[count] = 0.113\n        else:\n            centers[count] = [x, y]\n            radii[count] = inner_radius\n        count += 1\n\n    # Fill any remaining slots\n    while count < n:\n        centers[count] = [0.4 + 0.2 * (count - 16) / 10, 0.4 + 0.2 * ((count - 16) % 3) / 3]\n        radii[count] = 0.073\n        count += 1\n\n    return centers, radii\n\n\ndef initialize_pattern_ring_26():\n    \"\"\"\n    Initialize with concentric rings of circles, optimized for n=26.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.133\n\n    # First ring (8 circles)\n    ring1_radius = 0.098\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_radius\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = ring1_radius\n\n    # Second ring (12 circles)\n    ring2_radius = 0.088\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * ring1_radius + ring2_radius\n        centers[i + 9] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 9] = ring2_radius\n\n    # Corner circles (4 circles)\n    corner_radius = 0.093\n    centers[21] = [corner_radius, corner_radius]\n    centers[22] = [1 - corner_radius, corner_radius]\n    centers[23] = [corner_radius, 1 - corner_radius]\n    centers[24] = [1 - corner_radius, 1 - corner_radius]\n    radii[21:25] = corner_radius\n\n    # One extra circle\n    centers[25] = [0.5, 0.15]\n    radii[25] = 0.083\n\n    return centers, radii\n\ndef initialize_pattern_optimized_grid_26():\n    \"\"\"\n    Initializes circles in an optimized grid-like pattern, focusing on even distribution and space filling.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Start with a rough grid\n    num_x = 6\n    num_y = 5  # Adjusted for 26 circles\n    \n    x_coords = np.linspace(0.1, 0.9, num_x)\n    y_coords = np.linspace(0.1, 0.9, num_y)\n\n    count = 0\n    for i in range(num_y):\n        for j in range(num_x):\n            if count < n:\n                centers[count, 0] = x_coords[j]\n                centers[count, 1] = y_coords[i]\n                radii[count] = 0.083  # Initial radius\n                count += 1\n            else:\n                break\n        if count >= n:\n            break\n            \n    # Adjust radii based on location - corners slightly larger\n    for i in range(n):\n        if (centers[i, 0] < 0.2 and centers[i, 1] < 0.2) or \\\n           (centers[i, 0] > 0.8 and centers[i, 1] < 0.2) or \\\n           (centers[i, 0] < 0.2 and centers[i, 1] > 0.8) or \\\n           (centers[i, 0] > 0.8 and centers[i, 1] > 0.8):\n            radii[i] = 0.088  # Slightly larger in the corners\n        elif centers[i, 0] == 0.5 and centers[i, 1] == 0.5:\n            radii[i] = 0.103  # Largest radius in the very center\n        else:\n            radii[i] = 0.078\n\n    return centers, radii\n\n\ndef initialize_pattern_greedy_26():\n    \"\"\"\n    Initialize with a greedy approach that places larger circles first\n    and then fills in with smaller ones.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Define initial positions for the first 5 circles (corners and center)\n    initial_positions = [\n        (0.123, 0.123),       # Bottom left corner\n        (0.877, 0.123),       # Bottom right corner\n        (0.123, 0.877),       # Top left corner\n        (0.877, 0.877),       # Top right corner\n        (0.5, 0.5)          # Center\n    ]\n    \n    # Initial radii for the first 5 circles\n    initial_radii = [0.123, 0.123, 0.123, 0.123, 0.143]\n    \n    for i in range(min(5, n)):\n        centers[i] = initial_positions[i]\n        radii[i] = initial_radii[i]\n    \n    # Place circles along the edges\n    edge_positions = [\n        (0.5, 0.1),         # Bottom edge\n        (0.5, 0.9),         # Top edge\n        (0.1, 0.5),         # Left edge\n        (0.9, 0.5),         # Right edge\n        (0.3, 0.1),         # Bottom edge\n        (0.7, 0.1),         # Bottom edge\n        (0.3, 0.9),         # Top edge\n        (0.7, 0.9),         # Top edge\n        (0.1, 0.3),         # Left edge\n        (0.1, 0.7),         # Left edge\n        (0.9, 0.3),         # Right edge\n        (0.9, 0.7)          # Right edge\n    ]\n    \n    edge_radii = [0.103, 0.103, 0.103, 0.103, 0.093, 0.093, 0.093, 0.093, 0.093, 0.093, 0.093, 0.093]\n    \n    for i in range(min(len(edge_positions), n-5)):\n        centers[i+5] = edge_positions[i]\n        radii[i+5] = edge_radii[i]\n    \n    # Place inner circles in a grid-like pattern\n    inner_positions = [\n        (0.3, 0.3),\n        (0.5, 0.3),\n        (0.7, 0.3),\n        (0.3, 0.5),\n        (0.7, 0.5),\n        (0.3, 0.7),\n        (0.5, 0.7),\n        (0.7, 0.7),\n        (0.4, 0.4)\n    ]\n    \n    inner_radii = [0.093, 0.093, 0.093, 0.093, 0.093, 0.093, 0.093, 0.093, 0.083]\n    \n    remaining_circles = n - (5 + len(edge_positions))\n    for i in range(min(len(inner_positions), remaining_circles)):\n        centers[i+5+len(edge_positions)] = inner_positions[i]\n        radii[i+5+len(edge_positions)] = inner_radii[i]\n    \n    return centers, radii\n\n\ndef optimize_with_scipy(centers, radii):\n    \"\"\"\n    Optimize circle positions and radii using scipy.optimize.minimize.\n    Uses a multi-stage approach to avoid local minima.\n    \"\"\"\n    n = len(centers)\n    \n    # Stage 1: Optimize positions with fixed radii - Reduced iterations for speed\n    def objective_positions(x):\n        \"\"\"Objective function for position optimization.\"\"\"\n        current_centers = x.reshape((n, 2))\n        return calculate_penalty(current_centers, radii)\n    \n    x0_positions = centers.flatten()\n    bounds_positions = [(0, 1) for _ in range(2*n)]\n    \n    res_positions = minimize(\n        objective_positions, \n        x0_positions, \n        method='L-BFGS-B',\n        bounds=bounds_positions,\n        options={'maxiter': 150, 'ftol': 1e-6} # Adjusted maxiter and ftol\n    )\n    \n    improved_centers = res_positions.x.reshape((n, 2))\n    \n    # Stage 2: Optimize radii with fixed positions - Increased iterations and adjusted bounds\n    def objective_radii(r):\n        \"\"\"Objective function for radii optimization (negative sum of radii).\"\"\"\n        return -np.sum(r)\n    \n    def constraint_radii(r):\n        \"\"\"Constraints for radii optimization.\"\"\"\n        constraints = []\n        \n        # No overlapping circles\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(improved_centers[i] - improved_centers[j])\n                constraints.append(dist - r[i] - r[j])\n        \n        # Circles within the unit square\n        for i in range(n):\n            constraints.append(improved_centers[i, 0] - r[i])  # x >= r\n            constraints.append(1 - improved_centers[i, 0] - r[i])  # x <= 1 - r\n            constraints.append(improved_centers[i, 1] - r[i])  # y >= r\n            constraints.append(1 - improved_centers[i, 1] - r[i])  # y <= 1 - r\n        \n        return np.array(constraints)\n    \n    cons_radii = {'type': 'ineq', 'fun': constraint_radii}\n    \n    res_radii = minimize(\n        objective_radii, \n        radii, \n        method='SLSQP',\n        constraints=cons_radii,\n        bounds=[(0.03, 0.2) for _ in range(n)], # Adjusted bounds\n        options={'maxiter': 500, 'ftol': 1e-7} # Increased maxiter and ftol\n    )\n    \n    improved_radii = res_radii.x\n    \n    # Stage 3: Final joint optimization - Increased iterations, tighter tolerance, and refined bounds\n    def objective_joint(x):\n        \"\"\"Objective function to minimize (negative sum of radii).\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        return -np.sum(current_radii)\n    \n    def constraint_joint(x):\n        \"\"\"Constraints: no overlapping circles, circles within the unit square.\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        constraints = []\n        \n        # No overlapping circles\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(current_centers[i] - current_centers[j])\n                constraints.append(dist - current_radii[i] - current_radii[j])\n        \n        # Circles within the unit square\n        for i in range(n):\n            constraints.append(current_centers[i, 0] - current_radii[i])  # x >= r\n            constraints.append(1 - current_centers[i, 0] - current_radii[i])  # x <= 1 - r\n            constraints.append(current_centers[i, 1] - current_radii[i])  # y >= r\n            constraints.append(1 - current_centers[i, 1] - current_radii[i])  # y <= 1 - r\n        \n        return np.array(constraints)\n    \n    x0_joint = np.concatenate([improved_centers.flatten(), improved_radii])\n    bounds_joint = [(0.02, 0.98) for _ in range(2*n)] + [(0.03, 0.2) for _ in range(n)] # Adjusted bounds\n    cons_joint = {'type': 'ineq', 'fun': constraint_joint}\n    \n    res_joint = minimize(\n        objective_joint, \n        x0_joint, \n        method='SLSQP',\n        constraints=cons_joint,\n        bounds=bounds_joint,\n        options={'maxiter': 800, 'ftol': 1e-8} # Increased maxiter and tighter tolerance\n    )\n    \n    final_centers = res_joint.x[:2*n].reshape((n, 2))\n    final_radii = res_joint.x[2*n:]\n    \n    return final_centers, final_radii\n\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Used for optimization.  Increased penalty magnitude and added radius-dependent term.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    overlap_penalty_factor = 300  # Increased penalty\n    boundary_penalty_factor = 300 # Increased penalty\n\n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                penalty += overlap_penalty_factor * overlap**2 * (radii[i] + radii[j])  # Radius-dependent penalty\n\n    # Penalty for circles outside the unit square\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n    \n    return penalty\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": null, "generation": 0, "timestamp": 1750921844.478317, "iteration_found": 0, "metrics": {"validity": 1.0, "sum_radii": 2.6359773947566274, "target_ratio": 1.0003709278013766, "combined_score": 1.0003709278013766, "eval_time": 43.179890632629395}, "complexity": 0.0, "diversity": 0.0, "metadata": {"island": 0}, "artifacts_json": null, "artifact_dir": null}