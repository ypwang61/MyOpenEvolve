{"id": "0c77346c-f42d-4632-b9d3-33891467e48c", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This implementation focuses on a gradient-free optimization approach combined with carefully tuned initial patterns and radius adjustments to maximize the sum of radii toward the theoretical target of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Start with the most promising patterns first\n    patterns = [\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_specialized_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_corner_optimized_26,\n        initialize_pattern_ring_26\n    ]\n    \n    start_time = time.time()\n    time_limit = 25  # Set a time limit to ensure we don't timeout\n    \n    for pattern_func in patterns:\n        # Check if we're approaching the time limit\n        if time.time() - start_time > time_limit:\n            break\n            \n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function {pattern_func.__name__} returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization\n        try:\n            # Use a gradient-free optimization method\n            centers, radii = optimize_gradient_free(centers, radii)\n\n            # Final refinement\n            radii = maximize_radii(centers, radii)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n        except Exception as e:\n            logging.warning(f\"Optimization failed for {pattern_func.__name__}: {e}\")\n            continue\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26 with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.130\n    \n    # First hexagonal ring (6 circles)\n    inner_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n    \n    # Second partial hexagonal ring (12 circles)\n    middle_radius = 0.095\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * inner_radius + 0.002\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.115\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1 - corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1 - corner_radius]\n    centers[22] = [1 - corner_radius, 1 - corner_radius]\n    radii[19:23] = corner_radius\n    \n    # Edge circles (3 medium circles)\n    edge_radius = 0.090\n    centers[23] = [0.5, edge_radius]\n    centers[24] = [edge_radius, 0.5]\n    centers[25] = [1 - edge_radius, 0.5]\n    radii[23:26] = edge_radius\n    \n    return centers, radii\n\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place 4 large circles in corners\n    corner_radius = 0.123\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.107\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.132\n    \n    # Place 8 circles in inner ring around center\n    inner_radius = 0.102\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n    \n    # Place 6 circles in outer ring\n    outer_radius = 0.076\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi/6\n        dist = 0.40\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = outer_radius\n    \n    # Adjust remaining circles\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.25, 0.25]\n    radii[23:26] = 0.080\n    \n    return centers, radii\n\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.133\n    \n    # Inner ring (6 circles)\n    inner_radius = 0.107\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n    \n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.097\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius + 0.001\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.118\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n    \n    # Edge circles (4 medium circles)\n    edge_radius = 0.092\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n    \n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.077\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = small_radius\n    \n    return centers, radii\n\n\ndef initialize_pattern_corner_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal corner and edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # 4 large corner circles\n    corner_radius = 0.127\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # 4 medium edge circles\n    edge_radius = 0.102\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # 8 smaller edge circles\n    small_edge_radius = 0.087\n    centers[8] = [0.25, small_edge_radius]\n    centers[9] = [0.75, small_edge_radius]\n    centers[10] = [0.25, 1 - small_edge_radius]\n    centers[11] = [0.75, 1 - small_edge_radius]\n    centers[12] = [small_edge_radius, 0.25]\n    centers[13] = [small_edge_radius, 0.75]\n    centers[14] = [1 - small_edge_radius, 0.25]\n    centers[15] = [1 - small_edge_radius, 0.75]\n    radii[8:16] = small_edge_radius\n    \n    # Center circle\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.117\n    \n    # Inner grid (9 circles)\n    inner_radius = 0.082\n    grid_positions = [0.3, 0.5, 0.7]\n    \n    count = 17\n    for x in grid_positions:\n        for y in grid_positions:\n            if not (x == 0.5 and y == 0.5):  # Skip center as it's already placed\n                centers[count] = [x, y]\n                radii[count] = inner_radius\n                count += 1\n                if count >= n:\n                    break\n        if count >= n:\n            break\n    \n    return centers, radii\n\n\ndef initialize_pattern_ring_26():\n    \"\"\"\n    Initialize with concentric rings of circles, optimized for n=26.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.137\n    \n    # First ring (8 circles)\n    ring1_radius = 0.102\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = ring1_radius\n    \n    # Second ring (12 circles)\n    ring2_radius = 0.092\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * ring1_radius + ring2_radius + 0.001\n        centers[i + 9] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 9] = ring2_radius\n    \n    # Corner circles (4 circles)\n    corner_radius = 0.097\n    centers[21] = [corner_radius, corner_radius]\n    centers[22] = [1 - corner_radius, corner_radius]\n    centers[23] = [corner_radius, 1 - corner_radius]\n    centers[24] = [1 - corner_radius, 1 - corner_radius]\n    radii[21:25] = corner_radius\n    \n    # One extra circle\n    centers[25] = [0.5, 0.15]\n    radii[25] = 0.087\n    \n    return centers, radii\n\n\ndef optimize_gradient_free(centers, radii):\n    \"\"\"\n    Optimizes circle positions and radii using a gradient-free optimization method (Nelder-Mead).\n    This method is less sensitive to local optima and doesn't require gradient calculations.\n    \"\"\"\n    n = len(centers)\n\n    def objective(x):\n        # Extract centers and radii from flattened array\n        c = x[:2 * n].reshape(n, 2)\n        r = x[2 * n:]\n\n        # Penalty for circles outside the boundaries\n        boundary_penalty = 0.0\n        for i in range(n):\n            boundary_penalty += max(0, (r[i] - c[i, 0]) * 100)  # Left boundary\n            boundary_penalty += max(0, (r[i] + c[i, 0] - 1) * 100)  # Right boundary\n            boundary_penalty += max(0, (r[i] - c[i, 1]) * 100)  # Bottom boundary\n            boundary_penalty += max(0, (r[i] + c[i, 1] - 1) * 100)  # Top boundary\n\n        # Penalty for overlapping circles\n        overlap_penalty = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                overlap = r[i] + r[j] - dist\n                overlap_penalty += max(0, overlap * 100)  # Increased penalty\n\n        # Objective: Minimize negative sum of radii + penalties\n        return -np.sum(r) + boundary_penalty + overlap_penalty\n\n    # Flatten the centers and radii for optimization\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Set bounds: centers in [0,1], radii in [0.01, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0.01, 0.5)] * n\n\n    # Run optimization with constraints\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='Nelder-Mead',  # Gradient-free method\n            bounds=bounds,\n            options={'maxiter': 2000, 'ftol': 1e-5, 'adaptive': True}  # Adjusted parameters\n        )\n\n        # Extract optimized centers and radii\n        opt_centers = result.x[:2 * n].reshape(n, 2)\n        opt_radii = result.x[2 * n:]\n\n        return opt_centers, opt_radii\n\n    except Exception as e:\n        logging.warning(f\"Gradient-free optimization failed: {e}\")\n        return centers, radii\n\n\ndef adjust_radii_to_prevent_overlaps(centers, radii):\n    \"\"\"\n    Adjusts radii to prevent overlaps between circles and with boundaries.\n    \"\"\"\n    n = len(centers)\n    new_radii = radii.copy()\n    \n    # Check for overlaps between circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                # Reduce both radii proportionally to their original sizes\n                overlap = radii[i] + radii[j] - dist\n                ratio_i = radii[i] / (radii[i] + radii[j])\n                ratio_j = radii[j] / (radii[i] + radii[j])\n                \n                new_radii[i] -= overlap * ratio_i * 0.5 # Reduced reduction\n                new_radii[j] -= overlap * ratio_j * 0.5 # Reduced reduction\n    \n    # Check for boundary overlaps\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - new_radii[i] < 0:\n            new_radii[i] = centers[i, 0]\n        \n        # Right boundary\n        if centers[i, 0] + new_radii[i] > 1:\n            new_radii[i] = 1 - centers[i, 0]\n        \n        # Bottom boundary\n        if centers[i, 1] - new_radii[i] < 0:\n            new_radii[i] = min(new_radii[i], centers[i, 1])\n        \n        # Top boundary\n        if centers[i, 1] + new_radii[i] > 1:\n            new_radii[i] = min(new_radii[i], 1 - centers[i, 1])\n    \n    return np.clip(new_radii, 0.01, 0.5)  # Ensure minimum radius\n\n\ndef maximize_radii(centers, radii):\n    \"\"\"\n    Maximizes the radii of all circles while maintaining constraints.\n    \"\"\"\n    n = len(centers)\n    new_radii = radii.copy()\n    \n    # Calculate the maximum possible radius for each circle\n    for i in range(n):\n        # Maximum radius based on distance to boundaries\n        max_radius_boundary = min(\n            centers[i, 0],              # Distance to left\n            1 - centers[i, 0],          # Distance to right\n            centers[i, 1],              # Distance to bottom\n            1 - centers[i, 1]           # Distance to top\n        )\n        \n        # Maximum radius based on distance to other circles\n        max_radius_circles = float('inf')\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_radius_circles = min(max_radius_circles, (dist - new_radii[j])*0.99) # Slightly reduce to prevent overlap\n        \n        # Set radius to the minimum of the two constraints\n        new_radii[i] = min(max_radius_boundary, max_radius_circles)\n    \n    # Iterative refinement to ensure no overlaps\n    for _ in range(3): # Reduced iterations for speed\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < new_radii[i] + new_radii[j]:\n                    # Reduce both radii proportionally\n                    overlap = new_radii[i] + new_radii[j] - dist\n                    ratio_i = new_radii[i] / (new_radii[i] + new_radii[j])\n                    ratio_j = new_radii[j] / (new_radii[i] + new_radii[j])\n                    \n                    new_radii[i] -= overlap * ratio_i * 1.01  # Slight extra reduction for stability\n                    new_radii[j] -= overlap * ratio_j * 1.01\n    \n    return np.clip(new_radii, 0.01, 0.5)  # Ensure minimum and maximum radius\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "7eb56b9a-e46b-4642-aedb-2a4b35f78518", "generation": 7, "timestamp": 1750947351.6850867, "iteration_found": 158, "metrics": {"validity": 1.0, "sum_radii": 2.413260538868845, "target_ratio": 0.9158484018477591, "combined_score": 0.9158484018477591, "eval_time": 12.85507869720459}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.580814051428759, "target_ratio": 0.9794360726484855, "combined_score": 0.9794360726484855, "eval_time": 19.40416407585144}, "island": 4}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.645 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.636, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - validity: 1.0000\n- sum_radii: 2.5808\n- target_ratio: 0.9794\n- combined_score: 0.9794\n- eval_time: 19.4042\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: sum_radii, target_ratio, combined_score, eval_time. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6295, target_ratio: 0.9979, combined_score: 0.9979, eval_time: 174.5711\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.5846, target_ratio: 0.9809, combined_score: 0.9809, eval_time: 183.1378\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6093, target_ratio: 0.9902, combined_score: 0.9902, eval_time: 190.7207\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 9.7633)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6360), Performs well on target_ratio (1.0004), Performs well on combined_score (1.0004), Performs well on eval_time (43.1799)\n\n\n### Program 2 (Score: 39.2621)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using mathematical insights and specialized optimization techniques to maximize the sum of radii toward the target of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6093), Performs well on target_ratio (0.9902), Performs well on combined_score (0.9902), Performs well on eval_time (190.7207)\n\n\n### Program 3 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using multi-stage optimization with specialized patterns and mathematical insights to maximize the sum of radii toward the theoretical optimal value of 2.645. This version introduces a new optimization strategy using trust-region methods and adaptive radius scaling to escape local optima. It also incorporates a refined penalty function with dynamic adjustment of penalty factors based on the optimization progress.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n\n### Program 4 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy. This version focuses on a more robust gradient-based optimization refinement step, a dynamic penalty function, and a more sophisticated initial pattern selection.  It also introduces a more granular radius adjustment mechanism during gradient refinement and a more sophisticated penalty function that considers both overlap and proximity.  Furthermore, it now uses a mixed integer programming approach to find an initial configuration and improves the optimization routine with basinhopping to avoid local minima.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport logging\nfrom scipy.optimize import LinearConstraint\nfrom itertools import combinations\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n# ... (truncated for brevity)\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using multi-stage optimization with variable-sized circles, specialized mathematical patterns, and adaptive optimization techniques to maximize the sum of radii toward the theoretical optimal value of 2.645. This version focuses on enhanced penalty functions, refined initialization strategies, and more aggressive optimization techniques to break through the 2.636 plateau. This version introduces a new penalty function based on the Lennard-Jones potential, a more sophisticated initialization using a combination of hexagonal and random placements, and a refined optimization strategy that alternates between position and radius optimization. It also reduces the number of iterations in each stage to avoid timeouts and incorporates simulated annealing in the initial position optimization.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n# ... (truncated)\n```\nKey features: Alternative approach to stage1_passed, Alternative approach to error\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This implementation uses a hybrid approach with variable-sized circles, targeted perturbation strategies, and a multi-stage optimization process to maximize the sum of radii toward the theoretical target of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Start with the most promising patterns first\n    patterns = [\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_specialized_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_corner_optimized_26,\n        initialize_pattern_ring_26\n    ]\n    \n    start_time = time.time()\n    time_limit = 25  # Set a time limit to ensure we don't timeout\n    \n    for pattern_func in patterns:\n        # Check if we're approaching the time limit\n        if time.time() - start_time > time_limit:\n            break\n            \n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function {pattern_func.__name__} returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization\n        try:\n            # First optimize with a quick physics-based approach\n            centers, radii = optimize_with_physics(centers, radii, iterations=500)  # Reduced iterations for speed\n            \n            # Then use more precise mathematical optimization\n            centers, radii = optimize_mathematically(centers, radii)\n            \n            # Final refinement\n            radii = maximize_radii(centers, radii)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n        except Exception as e:\n            logging.warning(f\"Optimization failed for {pattern_func.__name__}: {e}\")\n            continue\n    \n    return best_centers, best_radii, best_sum\n\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26 with variable-sized circles.\n    This pattern is based on mathematical research showing hexagonal arrangements \n    often provide optimal density.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.130\n    \n    # First hexagonal ring (6 circles)\n    inner_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n    \n    # Second partial hexagonal ring (12 circles)\n    middle_radius = 0.095\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * inner_radius + 0.002\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.115\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1 - corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1 - corner_radius]\n    centers[22] = [1 - corner_radius, 1 - corner_radius]\n    radii[19:23] = corner_radius\n    \n    # Edge circles (3 medium circles)\n    edge_radius = 0.090\n    centers[23] = [0.5, edge_radius]\n    centers[24] = [edge_radius, 0.5]\n    centers[25] = [1 - edge_radius, 0.5]\n    radii[23:26] = edge_radius\n    \n    return centers, radii\n\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place 4 large circles in corners\n    corner_radius = 0.123\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.107\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.132\n    \n    # Place 8 circles in inner ring around center\n    inner_radius = 0.102\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n    \n    # Place 6 circles in outer ring\n    outer_radius = 0.076\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi/6\n        dist = 0.40\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = outer_radius\n    \n    # Adjust remaining circles\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.25, 0.25]\n    radii[23:26] = 0.080\n    \n    return centers, radii\n\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.133\n    \n    # Inner ring (6 circles)\n    inner_radius = 0.107\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n    \n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.097\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius + 0.001\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.118\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n    \n    # Edge circles (4 medium circles)\n    edge_radius = 0.092\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n    \n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.077\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = small_radius\n    \n    return centers, radii\n\n\ndef initialize_pattern_corner_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal corner and edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # 4 large corner circles\n    corner_radius = 0.127\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # 4 medium edge circles\n    edge_radius = 0.102\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # 8 smaller edge circles\n    small_edge_radius = 0.087\n    centers[8] = [0.25, small_edge_radius]\n    centers[9] = [0.75, small_edge_radius]\n    centers[10] = [0.25, 1 - small_edge_radius]\n    centers[11] = [0.75, 1 - small_edge_radius]\n    centers[12] = [small_edge_radius, 0.25]\n    centers[13] = [small_edge_radius, 0.75]\n    centers[14] = [1 - small_edge_radius, 0.25]\n    centers[15] = [1 - small_edge_radius, 0.75]\n    radii[8:16] = small_edge_radius\n    \n    # Center circle\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.117\n    \n    # Inner grid (9 circles)\n    inner_radius = 0.082\n    grid_positions = [0.3, 0.5, 0.7]\n    \n    count = 17\n    for x in grid_positions:\n        for y in grid_positions:\n            if not (x == 0.5 and y == 0.5):  # Skip center as it's already placed\n                centers[count] = [x, y]\n                radii[count] = inner_radius\n                count += 1\n                if count >= n:\n                    break\n        if count >= n:\n            break\n    \n    return centers, radii\n\n\ndef initialize_pattern_ring_26():\n    \"\"\"\n    Initialize with concentric rings of circles, optimized for n=26.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.137\n    \n    # First ring (8 circles)\n    ring1_radius = 0.102\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = ring1_radius\n    \n    # Second ring (12 circles)\n    ring2_radius = 0.092\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * ring1_radius + ring2_radius + 0.001\n        centers[i + 9] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 9] = ring2_radius\n    \n    # Corner circles (4 circles)\n    corner_radius = 0.097\n    centers[21] = [corner_radius, corner_radius]\n    centers[22] = [1 - corner_radius, corner_radius]\n    centers[23] = [corner_radius, 1 - corner_radius]\n    centers[24] = [1 - corner_radius, 1 - corner_radius]\n    radii[21:25] = corner_radius\n    \n    # One extra circle\n    centers[25] = [0.5, 0.15]\n    radii[25] = 0.087\n    \n    return centers, radii\n\n\ndef optimize_with_physics(centers, radii, iterations=500, force_strength=0.001, boundary_force=0.002):\n    \"\"\"\n    Optimizes circle positions using a simplified physics simulation.\n    \"\"\"\n    n = len(centers)\n    \n    for iter in range(iterations):\n        # Calculate repulsive forces between circles\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist:\n                    # Repulsive force proportional to overlap\n                    direction = (centers[i] - centers[j]) / (dist + 1e-10)  # Avoid division by zero\n                    overlap = min_dist - dist\n                    force_magnitude = force_strength * overlap\n                    forces[i] += direction * force_magnitude\n                    forces[j] -= direction * force_magnitude\n        \n        # Add forces to keep circles within the unit square\n        for i in range(n):\n            # Left boundary\n            if centers[i, 0] - radii[i] < 0:\n                forces[i, 0] += boundary_force * (0 - (centers[i, 0] - radii[i]))\n            \n            # Right boundary\n            if centers[i, 0] + radii[i] > 1:\n                forces[i, 0] -= boundary_force * ((centers[i, 0] + radii[i]) - 1)\n            \n            # Bottom boundary\n            if centers[i, 1] - radii[i] < 0:\n                forces[i, 1] += boundary_force * (0 - (centers[i, 1] - radii[i]))\n            \n            # Top boundary\n            if centers[i, 1] + radii[i] > 1:\n                forces[i, 1] -= boundary_force * ((centers[i, 1] + radii[i]) - 1)\n        \n        # Apply forces with damping as iterations progress\n        damping = 1.0 - (iter / iterations) * 0.9\n        centers += forces * damping\n        \n        # Ensure centers stay within [0,1]\n        centers = np.clip(centers, 0, 1)\n        \n        # Adjust radii to prevent overlaps less frequently\n        if iter % 200 == 0:  # Reduced frequency of radius adjustment\n            radii = adjust_radii_to_prevent_overlaps(centers, radii)\n    \n    return centers, radii\n\n\ndef optimize_mathematically(centers, radii):\n    \"\"\"\n    Uses mathematical optimization to maximize the sum of radii while maintaining constraints.\n    \"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        # Extract centers and radii from flattened array\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        # Objective: Minimize negative sum of radii (equivalent to maximizing sum)\n        return -np.sum(r)\n    \n    def constraints():\n        cons = []\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                cons.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i, j=j: np.linalg.norm(x[2*i:2*i+2] - x[2*j:2*j+2]) - x[2*n+i] - x[2*n+j] - 1e-6 # Add tolerance\n                })\n        \n        # Boundary constraints\n        for i in range(n):\n            # Left boundary: x_i - r_i >= 0\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i] - x[2*n+i]\n            })\n            \n            # Right boundary: x_i + r_i <= 1\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[2*i] - x[2*n+i]\n            })\n            \n            # Bottom boundary: y_i - r_i >= 0\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]\n            })\n            \n            # Top boundary: y_i + r_i <= 1\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]\n            })\n        \n        return cons\n    \n    # Flatten the centers and radii for optimization\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Set bounds: centers in [0,1], radii in [0.01, 0.5]\n    bounds = [(0, 1)] * (2*n) + [(0.01, 0.5)] * n\n    \n    # Run optimization with constraints\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints(),\n            options={'maxiter': 150, 'ftol': 1e-7} # Increased iterations, tighter tolerance\n        )\n        \n        # Extract optimized centers and radii\n        opt_centers = result.x[:2*n].reshape(n, 2)\n        opt_radii = result.x[2*n:]\n        \n        return opt_centers, opt_radii\n    \n    except Exception as e:\n        logging.warning(f\"Mathematical optimization failed: {e}\")\n        return centers, radii\n\n\ndef adjust_radii_to_prevent_overlaps(centers, radii):\n    \"\"\"\n    Adjusts radii to prevent overlaps between circles and with boundaries.\n    \"\"\"\n    n = len(centers)\n    new_radii = radii.copy()\n    \n    # Check for overlaps between circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                # Reduce both radii proportionally to their original sizes\n                overlap = radii[i] + radii[j] - dist\n                ratio_i = radii[i] / (radii[i] + radii[j])\n                ratio_j = radii[j] / (radii[i] + radii[j])\n                \n                new_radii[i] -= overlap * ratio_i * 0.5 # Reduced reduction\n                new_radii[j] -= overlap * ratio_j * 0.5 # Reduced reduction\n    \n    # Check for boundary overlaps\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - new_radii[i] < 0:\n            new_radii[i] = centers[i, 0]\n        \n        # Right boundary\n        if centers[i, 0] + new_radii[i] > 1:\n            new_radii[i] = 1 - centers[i, 0]\n        \n        # Bottom boundary\n        if centers[i, 1] - new_radii[i] < 0:\n            new_radii[i] = min(new_radii[i], centers[i, 1])\n        \n        # Top boundary\n        if centers[i, 1] + new_radii[i] > 1:\n            new_radii[i] = min(new_radii[i], 1 - centers[i, 1])\n    \n    return np.clip(new_radii, 0.01, 0.5)  # Ensure minimum radius\n\n\ndef maximize_radii(centers, radii):\n    \"\"\"\n    Maximizes the radii of all circles while maintaining constraints.\n    \"\"\"\n    n = len(centers)\n    new_radii = radii.copy()\n    \n    # Calculate the maximum possible radius for each circle\n    for i in range(n):\n        # Maximum radius based on distance to boundaries\n        max_radius_boundary = min(\n            centers[i, 0],              # Distance to left\n            1 - centers[i, 0],          # Distance to right\n            centers[i, 1],              # Distance to bottom\n            1 - centers[i, 1]           # Distance to top\n        )\n        \n        # Maximum radius based on distance to other circles\n        max_radius_circles = float('inf')\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_radius_circles = min(max_radius_circles, (dist - new_radii[j])*0.99) # Slightly reduce to prevent overlap\n        \n        # Set radius to the minimum of the two constraints\n        new_radii[i] = min(max_radius_boundary, max_radius_circles)\n    \n    # Iterative refinement to ensure no overlaps\n    for _ in range(3): # Reduced iterations for speed\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < new_radii[i] + new_radii[j]:\n                    # Reduce both radii proportionally\n                    overlap = new_radii[i] + new_radii[j] - dist\n                    ratio_i = new_radii[i] / (new_radii[i] + new_radii[j])\n                    ratio_j = new_radii[j] / (new_radii[i] + new_radii[j])\n                    \n                    new_radii[i] -= overlap * ratio_i * 1.01  # Slight extra reduction for stability\n                    new_radii[j] -= overlap * ratio_j * 1.01\n    \n    return np.clip(new_radii, 0.01, 0.5)  # Ensure minimum and maximum radius\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This implementation focuses on a gradient-free optimization approach combined with carefully tuned initial patterns and radius adjustments to maximize the sum of radii toward the theoretical target of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Start with the most promising patterns first\n    patterns = [\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_specialized_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_corner_optimized_26,\n        initialize_pattern_ring_26\n    ]\n    \n    start_time = time.time()\n    time_limit = 25  # Set a time limit to ensure we don't timeout\n    \n    for pattern_func in patterns:\n        # Check if we're approaching the time limit\n        if time.time() - start_time > time_limit:\n            break\n            \n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function {pattern_func.__name__} returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization\n        try:\n            # Use a gradient-free optimization method\n            centers, radii = optimize_gradient_free(centers, radii)\n\n            # Final refinement\n            radii = maximize_radii(centers, radii)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n        except Exception as e:\n            logging.warning(f\"Optimization failed for {pattern_func.__name__}: {e}\")\n            continue\n    \n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26 with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.130\n    \n    # First hexagonal ring (6 circles)\n    inner_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n    \n    # Second partial hexagonal ring (12 circles)\n    middle_radius = 0.095\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * inner_radius + 0.002\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.115\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1 - corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1 - corner_radius]\n    centers[22] = [1 - corner_radius, 1 - corner_radius]\n    radii[19:23] = corner_radius\n    \n    # Edge circles (3 medium circles)\n    edge_radius = 0.090\n    centers[23] = [0.5, edge_radius]\n    centers[24] = [edge_radius, 0.5]\n    centers[25] = [1 - edge_radius, 0.5]\n    radii[23:26] = edge_radius\n    \n    return centers, radii\n\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place 4 large circles in corners\n    corner_radius = 0.123\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.107\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.132\n    \n    # Place 8 circles in inner ring around center\n    inner_radius = 0.102\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.002\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n    \n    # Place 6 circles in outer ring\n    outer_radius = 0.076\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi/6\n        dist = 0.40\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = outer_radius\n    \n    # Adjust remaining circles\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.25, 0.25]\n    radii[23:26] = 0.080\n    \n    return centers, radii\n\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.133\n    \n    # Inner ring (6 circles)\n    inner_radius = 0.107\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n    \n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.097\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius + 0.001\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n    \n    # Corner circles (4 larger circles)\n    corner_radius = 0.118\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n    \n    # Edge circles (4 medium circles)\n    edge_radius = 0.092\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n    \n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.077\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = small_radius\n    \n    return centers, radii\n\n\ndef initialize_pattern_corner_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal corner and edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # 4 large corner circles\n    corner_radius = 0.127\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # 4 medium edge circles\n    edge_radius = 0.102\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # 8 smaller edge circles\n    small_edge_radius = 0.087\n    centers[8] = [0.25, small_edge_radius]\n    centers[9] = [0.75, small_edge_radius]\n    centers[10] = [0.25, 1 - small_edge_radius]\n    centers[11] = [0.75, 1 - small_edge_radius]\n    centers[12] = [small_edge_radius, 0.25]\n    centers[13] = [small_edge_radius, 0.75]\n    centers[14] = [1 - small_edge_radius, 0.25]\n    centers[15] = [1 - small_edge_radius, 0.75]\n    radii[8:16] = small_edge_radius\n    \n    # Center circle\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.117\n    \n    # Inner grid (9 circles)\n    inner_radius = 0.082\n    grid_positions = [0.3, 0.5, 0.7]\n    \n    count = 17\n    for x in grid_positions:\n        for y in grid_positions:\n            if not (x == 0.5 and y == 0.5):  # Skip center as it's already placed\n                centers[count] = [x, y]\n                radii[count] = inner_radius\n                count += 1\n                if count >= n:\n                    break\n        if count >= n:\n            break\n    \n    return centers, radii\n\n\ndef initialize_pattern_ring_26():\n    \"\"\"\n    Initialize with concentric rings of circles, optimized for n=26.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.137\n    \n    # First ring (8 circles)\n    ring1_radius = 0.102\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = ring1_radius\n    \n    # Second ring (12 circles)\n    ring2_radius = 0.092\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * ring1_radius + ring2_radius + 0.001\n        centers[i + 9] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 9] = ring2_radius\n    \n    # Corner circles (4 circles)\n    corner_radius = 0.097\n    centers[21] = [corner_radius, corner_radius]\n    centers[22] = [1 - corner_radius, corner_radius]\n    centers[23] = [corner_radius, 1 - corner_radius]\n    centers[24] = [1 - corner_radius, 1 - corner_radius]\n    radii[21:25] = corner_radius\n    \n    # One extra circle\n    centers[25] = [0.5, 0.15]\n    radii[25] = 0.087\n    \n    return centers, radii\n\n\ndef optimize_gradient_free(centers, radii):\n    \"\"\"\n    Optimizes circle positions and radii using a gradient-free optimization method (Nelder-Mead).\n    This method is less sensitive to local optima and doesn't require gradient calculations.\n    \"\"\"\n    n = len(centers)\n\n    def objective(x):\n        # Extract centers and radii from flattened array\n        c = x[:2 * n].reshape(n, 2)\n        r = x[2 * n:]\n\n        # Penalty for circles outside the boundaries\n        boundary_penalty = 0.0\n        for i in range(n):\n            boundary_penalty += max(0, (r[i] - c[i, 0]) * 100)  # Left boundary\n            boundary_penalty += max(0, (r[i] + c[i, 0] - 1) * 100)  # Right boundary\n            boundary_penalty += max(0, (r[i] - c[i, 1]) * 100)  # Bottom boundary\n            boundary_penalty += max(0, (r[i] + c[i, 1] - 1) * 100)  # Top boundary\n\n        # Penalty for overlapping circles\n        overlap_penalty = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                overlap = r[i] + r[j] - dist\n                overlap_penalty += max(0, overlap * 100)  # Increased penalty\n\n        # Objective: Minimize negative sum of radii + penalties\n        return -np.sum(r) + boundary_penalty + overlap_penalty\n\n    # Flatten the centers and radii for optimization\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Set bounds: centers in [0,1], radii in [0.01, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0.01, 0.5)] * n\n\n    # Run optimization with constraints\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='Nelder-Mead',  # Gradient-free method\n            bounds=bounds,\n            options={'maxiter': 2000, 'ftol': 1e-5, 'adaptive': True}  # Adjusted parameters\n        )\n\n        # Extract optimized centers and radii\n        opt_centers = result.x[:2 * n].reshape(n, 2)\n        opt_radii = result.x[2 * n:]\n\n        return opt_centers, opt_radii\n\n    except Exception as e:\n        logging.warning(f\"Gradient-free optimization failed: {e}\")\n        return centers, radii\n\n\ndef adjust_radii_to_prevent_overlaps(centers, radii):\n    \"\"\"\n    Adjusts radii to prevent overlaps between circles and with boundaries.\n    \"\"\"\n    n = len(centers)\n    new_radii = radii.copy()\n    \n    # Check for overlaps between circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                # Reduce both radii proportionally to their original sizes\n                overlap = radii[i] + radii[j] - dist\n                ratio_i = radii[i] / (radii[i] + radii[j])\n                ratio_j = radii[j] / (radii[i] + radii[j])\n                \n                new_radii[i] -= overlap * ratio_i * 0.5 # Reduced reduction\n                new_radii[j] -= overlap * ratio_j * 0.5 # Reduced reduction\n    \n    # Check for boundary overlaps\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - new_radii[i] < 0:\n            new_radii[i] = centers[i, 0]\n        \n        # Right boundary\n        if centers[i, 0] + new_radii[i] > 1:\n            new_radii[i] = 1 - centers[i, 0]\n        \n        # Bottom boundary\n        if centers[i, 1] - new_radii[i] < 0:\n            new_radii[i] = min(new_radii[i], centers[i, 1])\n        \n        # Top boundary\n        if centers[i, 1] + new_radii[i] > 1:\n            new_radii[i] = min(new_radii[i], 1 - centers[i, 1])\n    \n    return np.clip(new_radii, 0.01, 0.5)  # Ensure minimum radius\n\n\ndef maximize_radii(centers, radii):\n    \"\"\"\n    Maximizes the radii of all circles while maintaining constraints.\n    \"\"\"\n    n = len(centers)\n    new_radii = radii.copy()\n    \n    # Calculate the maximum possible radius for each circle\n    for i in range(n):\n        # Maximum radius based on distance to boundaries\n        max_radius_boundary = min(\n            centers[i, 0],              # Distance to left\n            1 - centers[i, 0],          # Distance to right\n            centers[i, 1],              # Distance to bottom\n            1 - centers[i, 1]           # Distance to top\n        )\n        \n        # Maximum radius based on distance to other circles\n        max_radius_circles = float('inf')\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_radius_circles = min(max_radius_circles, (dist - new_radii[j])*0.99) # Slightly reduce to prevent overlap\n        \n        # Set radius to the minimum of the two constraints\n        new_radii[i] = min(max_radius_boundary, max_radius_circles)\n    \n    # Iterative refinement to ensure no overlaps\n    for _ in range(3): # Reduced iterations for speed\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < new_radii[i] + new_radii[j]:\n                    # Reduce both radii proportionally\n                    overlap = new_radii[i] + new_radii[j] - dist\n                    ratio_i = new_radii[i] / (new_radii[i] + new_radii[j])\n                    ratio_j = new_radii[j] / (new_radii[i] + new_radii[j])\n                    \n                    new_radii[i] -= overlap * ratio_i * 1.01  # Slight extra reduction for stability\n                    new_radii[j] -= overlap * ratio_j * 1.01\n    \n    return np.clip(new_radii, 0.01, 0.5)  # Ensure minimum and maximum radius\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```"]}}}