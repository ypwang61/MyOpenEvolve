{"id": "9e6dd607-3c69-4b6d-b1d0-33ff2dd87182", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using multi-stage optimization with specialized patterns and mathematical insights to maximize the sum of radii toward the theoretical optimal value of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport random\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    start_time = time.time()\n    max_time = 39  # Ensure we stay within time limits\n\n    # Define pattern generation functions\n    patterns = [\n        initialize_pattern_optimized_26,  # Our best pattern based on mathematical insights\n        initialize_pattern_hybrid_variable_26,\n        initialize_pattern_asymmetric_26,  # New asymmetric pattern\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_optimized_corners_26,\n    ]\n    \n    # First optimization pass: try each pattern\n    for pattern_idx, pattern_func in enumerate(patterns):\n        if time.time() - start_time > max_time * 0.5:  # Use half the time for initial patterns\n            break\n            \n        try:\n            # Generate initial pattern\n            centers, radii = pattern_func()\n            \n            # Ensure we have exactly 26 circles\n            assert centers.shape[0] == n, f\"Pattern function returned {centers.shape[0]} circles instead of {n}\"\n            \n            # Quick optimization to improve the pattern\n            centers, radii = optimize_packing(centers, radii, iterations=25, quick=True)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n            # Try a perturbed version of this pattern\n            if pattern_idx < 2:  # Only for top patterns\n                perturbed_centers = centers.copy() + np.random.normal(0, 0.01, centers.shape)\n                perturbed_radii = radii.copy() * (1 + np.random.normal(0, 0.02, radii.shape))\n                \n                # Ensure perturbed radii are positive\n                perturbed_radii = np.maximum(perturbed_radii, 0.03)\n                \n                # Optimize the perturbed pattern\n                perturbed_centers, perturbed_radii = optimize_packing(perturbed_centers, perturbed_radii, iterations=20, quick=True)\n                \n                perturbed_sum = np.sum(perturbed_radii)\n                if perturbed_sum > best_sum:\n                    best_sum = perturbed_sum\n                    best_centers = perturbed_centers.copy()\n                    best_radii = perturbed_radii.copy()\n                    \n        except Exception as e:\n            continue\n\n    # Second pass: intensive optimization on the best pattern\n    if best_centers is not None:\n        remaining_time = max_time - (time.time() - start_time)\n        if remaining_time > 5:  # Only if we have enough time left\n            try:\n                # Multi-stage optimization\n                for i in range(3):  # Multiple optimization stages\n                    centers, radii = optimize_packing(best_centers, best_radii, \n                                                     iterations=40,\n                                                     quick=False)\n                    \n                    # Apply targeted perturbation between optimization stages\n                    if i < 2:  # Skip perturbation on final stage\n                        centers, radii = targeted_perturbation(centers, radii)\n                    \n                    sum_radii = np.sum(radii)\n                    if sum_radii > best_sum:\n                        best_sum = sum_radii\n                        best_centers = centers.copy()\n                        best_radii = radii.copy()\n            except Exception:\n                pass  # Keep the previous best if optimization fails\n\n    # Final refinement with specialized techniques\n    remaining_time = max_time - (time.time() - start_time)\n    if remaining_time > 3 and best_centers is not None:\n        try:\n            # Apply radius balancing to improve overall sum\n            centers, radii = radius_balancing(best_centers, best_radii)\n            \n            # Final quick optimization\n            centers, radii = optimize_packing(centers, radii, iterations=15, quick=True)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception:\n            pass  # Keep the previous best if optimization fails\n\n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_optimized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research\n    and insights from circle packing literature.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners with carefully calculated radius\n    corner_radius = 0.129\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.110\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.138\n\n    # Place 8 circles in inner ring around center\n    inner_radius = 0.098\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n\n    # Place 9 smaller circles to fill gaps\n    small_radius = 0.082\n    grid_positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.33, 0.5), (0.67, 0.5), (0.5, 0.33), (0.5, 0.67),\n        (0.33, 0.33)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        centers[17+i] = pos\n        radii[17+i] = small_radius\n\n    return centers, radii\n\ndef initialize_pattern_hybrid_variable_26():\n    \"\"\"\n    Initialize with a hybrid pattern using variable-sized circles arranged in a pattern\n    that combines hexagonal and square grid elements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.127\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.108\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Central circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.135\n\n    # 8 circles in inner ring around center\n    inner_radius = 0.097\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n\n    # 9 circles in outer positions\n    outer_radius = 0.08\n    positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.25, 0.5), (0.75, 0.5), (0.33, 0.33), (0.67, 0.33), (0.67, 0.67)\n    ]\n    \n    for i, pos in enumerate(positions):\n        centers[17+i] = pos\n        radii[17+i] = outer_radius\n\n    return centers, radii\n\ndef initialize_pattern_asymmetric_26():\n    \"\"\"\n    Initialize with an asymmetric pattern that may help escape local optima\n    by breaking symmetry constraints.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Variable-sized corner circles\n    corner_radii = [0.128, 0.130, 0.126, 0.132]\n    centers[0] = [corner_radii[0], corner_radii[0]]\n    centers[1] = [1-corner_radii[1], corner_radii[1]]\n    centers[2] = [corner_radii[2], 1-corner_radii[2]]\n    centers[3] = [1-corner_radii[3], 1-corner_radii[3]]\n    for i in range(4):\n        radii[i] = corner_radii[i]\n\n    # Variable-sized edge circles\n    edge_radii = [0.107, 0.112, 0.109, 0.110]\n    centers[4] = [0.5, edge_radii[0]]\n    centers[5] = [0.5, 1-edge_radii[1]]\n    centers[6] = [edge_radii[2], 0.5]\n    centers[7] = [1-edge_radii[3], 0.5]\n    for i in range(4):\n        radii[4+i] = edge_radii[i]\n\n    # Off-center large circle\n    centers[8] = [0.52, 0.48]\n    radii[8] = 0.136\n\n    # Asymmetric ring around center\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + 0.1  # Slight rotation\n        dist = radii[8] + 0.098 + 0.001\n        if i % 2 == 0:\n            dist += 0.005  # Alternate distance\n        centers[9+i] = [centers[8][0] + dist * np.cos(angle), centers[8][1] + dist * np.sin(angle)]\n        radii[9+i] = 0.095 + 0.004 * (i % 3)  # Variable sizes\n\n    # Asymmetric filling circles\n    positions = [\n        (0.24, 0.26), (0.76, 0.23), (0.27, 0.74), (0.73, 0.77),\n        (0.26, 0.52), (0.74, 0.48), (0.34, 0.32), (0.66, 0.34), (0.68, 0.66)\n    ]\n    \n    sizes = [0.083, 0.079, 0.081, 0.084, 0.082, 0.080, 0.078, 0.082, 0.081]\n    \n    for i, pos in enumerate(positions):\n        centers[17+i] = pos\n        radii[17+i] = sizes[i]\n\n    return centers, radii\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26, with larger circles in the center\n    and corners, and smaller circles to fill gaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place a large circle in the center\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.137\n\n    # Place 6 circles in the first hexagonal ring\n    first_ring_radius = 0.102\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + first_ring_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = first_ring_radius\n\n    # Place 12 circles in the second hexagonal ring\n    second_ring_radius = 0.089\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*first_ring_radius + second_ring_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = second_ring_radius\n\n    # Place 4 larger circles in the corners\n    corner_radius = 0.126\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n\n    # Place 3 medium circles to fill remaining spaces\n    medium_radius = 0.083\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = medium_radius\n\n    return centers, radii\n\ndef initialize_pattern_optimized_corners_26():\n    \"\"\"\n    Initialize with a pattern that optimizes corner and edge utilization with\n    variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.128\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 8 edge circles (2 on each edge)\n    edge_radius = 0.095\n    edge_positions = [0.3, 0.7]\n    \n    # Bottom edge\n    centers[4] = [edge_positions[0], edge_radius]\n    centers[5] = [edge_positions[1], edge_radius]\n    \n    # Top edge\n    centers[6] = [edge_positions[0], 1-edge_radius]\n    centers[7] = [edge_positions[1], 1-edge_radius]\n    \n    # Left edge\n    centers[8] = [edge_radius, edge_positions[0]]\n    centers[9] = [edge_radius, edge_positions[1]]\n    \n    # Right edge\n    centers[10] = [1-edge_radius, edge_positions[0]]\n    centers[11] = [1-edge_radius, edge_positions[1]]\n    \n    radii[4:12] = edge_radius\n\n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.135\n\n    # Inner grid (13 circles)\n    inner_radius = 0.08\n    grid_positions = [\n        (0.5, 0.3), (0.5, 0.7),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),\n        (0.4, 0.4), (0.6, 0.4), (0.4, 0.6), (0.6, 0.6),\n        (0.5, 0.5)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        if i < 13:  # Ensure we don't exceed 26 circles\n            centers[13+i] = pos\n            if pos == (0.5, 0.5):  # Center of grid gets slightly larger radius\n                radii[13+i] = 0.09\n            else:\n                radii[13+i] = inner_radius\n\n    return centers, radii\n\ndef optimize_packing(centers, radii, iterations=100, quick=False):\n    \"\"\"\n    Optimize circle positions and radii using the L-BFGS-B optimization algorithm.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        iterations: Number of optimization iterations\n        quick: If True, perform a faster but less thorough optimization\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        sum_radii = np.sum(current_radii)\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -sum_radii + penalty\n    \n    # Initial guess\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds for centers and radii\n    center_bounds = [(0.01, 0.99)] * (2 * n)\n    radii_bounds = [(0.03, 0.2)] * n\n    bounds = center_bounds + radii_bounds\n    \n    # Define optimization parameters\n    if quick:\n        options = {'maxiter': min(iterations, 30), 'ftol': 1e-5}\n        method = 'L-BFGS-B'\n    else:\n        options = {'maxiter': iterations, 'ftol': 1e-6}\n        method = 'L-BFGS-B'\n    \n    # Perform optimization\n    result = minimize(objective, x0, method=method, bounds=bounds, options=options)\n    \n    # Extract optimized centers and radii\n    final_centers = result.x[:2*n].reshape((n, 2))\n    final_radii = result.x[2*n:]\n    \n    return final_centers, final_radii\n\ndef targeted_perturbation(centers, radii):\n    \"\"\"\n    Apply targeted perturbation to help escape local optima.\n    Focus on perturbing smaller circles and areas with lower density.\n    \n    Args:\n        centers: Current circle centers\n        radii: Current circle radii\n        \n    Returns:\n        Tuple of (perturbed_centers, perturbed_radii)\n    \"\"\"\n    n = len(centers)\n    perturbed_centers = centers.copy()\n    perturbed_radii = radii.copy()\n    \n    # Identify smaller circles (bottom 30%)\n    size_threshold = np.percentile(radii, 30)\n    small_indices = np.where(radii <= size_threshold)[0]\n    \n    # Perturb positions of smaller circles\n    for idx in small_indices:\n        perturbed_centers[idx] += np.random.normal(0, 0.02, size=2)\n        \n        # Keep within bounds\n        perturbed_centers[idx] = np.clip(perturbed_centers[idx], 0.01, 0.99)\n    \n    # Calculate local density for each circle\n    densities = np.zeros(n)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                densities[i] += 1.0 / (dist + 0.1)  # Add small constant to avoid division by zero\n    \n    # Identify areas with lower density (bottom 40%)\n    density_threshold = np.percentile(densities, 40)\n    low_density_indices = np.where(densities <= density_threshold)[0]\n    \n    # Perturb radii in low density areas\n    for idx in low_density_indices:\n        # Increase radius slightly in low density areas\n        perturbed_radii[idx] *= (1 + np.random.uniform(0, 0.03))\n    \n    # Ensure all radii are positive\n    perturbed_radii = np.maximum(perturbed_radii, 0.03)\n    \n    return perturbed_centers, perturbed_radii\n\ndef radius_balancing(centers, radii):\n    \"\"\"\n    Balance radii to maximize overall sum while maintaining validity.\n    This function tries to redistribute radius from circles with more \"slack\" to those with less.\n    \n    Args:\n        centers: Current circle centers\n        radii: Current circle radii\n        \n    Returns:\n        Tuple of (centers, balanced_radii)\n    \"\"\"\n    n = len(centers)\n    balanced_radii = radii.copy()\n    \n    # Calculate \"slack\" for each circle (how much it can grow before hitting another)\n    slack = np.zeros(n)\n    for i in range(n):\n        min_slack = float('inf')\n        \n        # Check distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                current_slack = dist - (radii[i] + radii[j])\n                min_slack = min(min_slack, current_slack)\n        \n        # Check distance to boundaries\n        for coord in range(2):\n            boundary_slack = min(centers[i, coord] - radii[i], 1 - centers[i, coord] - radii[i])\n            min_slack = min(min_slack, boundary_slack)\n        \n        slack[i] = max(0, min_slack)\n    \n    # Identify circles with more slack and those with less\n    median_slack = np.median(slack)\n    high_slack_indices = np.where(slack > median_slack)[0]\n    low_slack_indices = np.where(slack < median_slack * 0.5)[0]\n    \n    # Redistribute radius from high slack to low slack circles\n    total_redistribution = 0\n    for idx in high_slack_indices:\n        # Take a small portion of the slack\n        reduction = slack[idx] * 0.3\n        balanced_radii[idx] -= reduction\n        total_redistribution += reduction\n    \n    # Distribute the collected radius to low slack circles\n    if len(low_slack_indices) > 0 and total_redistribution > 0:\n        per_circle_increase = total_redistribution / len(low_slack_indices)\n        for idx in low_slack_indices:\n            balanced_radii[idx] += per_circle_increase\n    \n    # Final validity check and correction\n    for i in range(n):\n        # Check against other circles\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = balanced_radii[i] + balanced_radii[j] - dist\n            if overlap > 0:\n                # Reduce both radii proportionally\n                reduction = overlap / 2\n                balanced_radii[i] -= reduction\n                balanced_radii[j] -= reduction\n        \n        # Check against boundaries\n        for coord in range(2):\n            if centers[i, coord] - balanced_radii[i] < 0:\n                balanced_radii[i] = centers[i, coord]\n            if centers[i, coord] + balanced_radii[i] > 1:\n                balanced_radii[i] = 1 - centers[i, coord]\n    \n    # Ensure all radii are positive\n    balanced_radii = np.maximum(balanced_radii, 0.03)\n    \n    return centers, balanced_radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Uses a smooth, differentiable penalty function for better optimization.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    overlap_penalty_factor = 1000\n    boundary_penalty_factor = 1000\n    \n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                # Use a quadratic penalty with radius-dependent scaling\n                penalty += overlap_penalty_factor * overlap**2 * (radii[i] + radii[j])\n    \n    # Penalty for circles outside the unit square\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n    \n    return penalty\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "037642e1-e3b8-4c19-b3de-6c86c3c0159e", "generation": 8, "timestamp": 1750928153.2230237, "iteration_found": 43, "metrics": {"validity": 0.0, "sum_radii": 0.0, "target_ratio": 0.0, "combined_score": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "sum_radii": 0.0, "target_ratio": 0.0, "combined_score": 0.0}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.645 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.636, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - validity: 0.0000\n- sum_radii: 0.0000\n- target_ratio: 0.0000\n- combined_score: 0.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: validity, sum_radii, target_ratio, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6202, target_ratio: 0.9944, combined_score: 0.9944, eval_time: 43.5821\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6228, target_ratio: 0.9954, combined_score: 0.9954, eval_time: 117.8238\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6073, target_ratio: 0.9895, combined_score: 0.9895, eval_time: 132.5911\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 9.7633)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6360), Performs well on target_ratio (1.0004), Performs well on combined_score (1.0004), Performs well on eval_time (43.1799)\n\n\n### Program 2 (Score: 27.6355)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6073), Performs well on target_ratio (0.9895), Performs well on combined_score (0.9895), Performs well on eval_time (132.5911)\n\n\n### Program 3 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on error (Program execution failed: index 26 is out of bounds for axis 0 with size 26)\n\n\n### Program 4 (Score: 0.0000)\n```python\nI'll analyze the current program and develop a significantly improved version to break through the 2.636 plateau and reach closer to the 2.645 target.\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using multi-stage optimization with specialized patterns and mathematical insights to maximize the sum of radii toward the theoretical optimal value of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef construct_packing():\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on error (Program execution failed: unterminated string literal (detected at line 1) (tmpmpocpe7l.py, line 1))\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, a refined initial pattern selection strategy, and simulated annealing for escaping local optima.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n# ... (truncated)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square, implementing specialized geometric patterns and multi-stage optimization techniques to maximize the sum of radii. This implementation uses hybrid patterns with variable-sized circles, targeted perturbation strategies, and adaptive penalty functions to escape local optima. This version focuses on SIMPLER optimization and increased pattern diversity.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport random\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    start_time = time.time()\n    max_time = 40  # Increased max time\n\n    # Define pattern generation functions in order of expected performance\n    patterns = [\n        initialize_pattern_hybrid_variable_26,  # Prioritize this pattern\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_optimized_corners_26,\n        initialize_pattern_concentric_26,\n        initialize_pattern_specialized_26,\n        initialize_pattern_random_26 #Adding random initialization\n    ]\n\n    # First pass: try each pattern with basic optimization\n    for pattern_func in patterns:\n        if time.time() - start_time > max_time:\n            break\n            \n        try:\n            centers, radii = pattern_func()\n            \n            # Ensure we have exactly 26 circles\n            assert centers.shape[0] == n, f\"Pattern function returned {centers.shape[0]} circles instead of {n}\"\n            \n            # Quick optimization to improve the pattern\n            centers, radii = optimize_packing(centers, radii, iterations=30, quick=True)  # Reduced iterations for speed\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            continue\n\n    # Second pass: intensive optimization on the best pattern\n    if best_centers is not None:\n        remaining_time = max_time - (time.time() - start_time)\n        if remaining_time > 5:  # Only if we have enough time left\n            try:\n                centers, radii = optimize_packing(best_centers, best_radii, \n                                                 iterations=100,  # Reduced iterations for speed\n                                                 quick=False)\n                \n                sum_radii = np.sum(radii)\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n            except Exception:\n                pass  # Keep the previous best if optimization fails\n\n    # Final refinement with multi-stage optimization - Simplified for efficiency\n    remaining_time = max_time - (time.time() - start_time)\n    if remaining_time > 3 and best_centers is not None:\n        try:\n            centers, radii = refine_packing(best_centers, best_radii)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception:\n            pass  # Keep the previous best if optimization fails\n\n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26, with larger circles in the center\n    and corners, and smaller circles to fill gaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place a large circle in the center\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.135\n\n    # Place 6 circles in the first hexagonal ring\n    first_ring_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + first_ring_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = first_ring_radius\n\n    # Place 12 circles in the second hexagonal ring\n    second_ring_radius = 0.09\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*first_ring_radius + second_ring_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = second_ring_radius\n\n    # Place 4 larger circles in the corners\n    corner_radius = 0.12\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n\n    # Place 3 medium circles to fill remaining spaces\n    medium_radius = 0.08\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = medium_radius\n\n    return centers, radii\n\ndef initialize_pattern_hybrid_variable_26():\n    \"\"\"\n    Initialize with a hybrid pattern using variable-sized circles arranged in a pattern\n    that combines hexagonal and square grid elements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.125\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.105\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Central circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.13\n\n    # 8 circles in inner ring around center\n    inner_radius = 0.1\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n\n    # 9 circles in outer positions\n    outer_radius = 0.075\n    positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.25, 0.5), (0.75, 0.5), (0.33, 0.33), (0.67, 0.33), (0.67, 0.67)\n    ]\n    \n    for i, pos in enumerate(positions):\n        centers[17+i] = pos\n        radii[17+i] = outer_radius\n\n    return centers, radii\n\ndef initialize_pattern_optimized_corners_26():\n    \"\"\"\n    Initialize with a pattern that optimizes corner and edge utilization with\n    variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.13\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 8 edge circles (2 on each edge)\n    edge_radius = 0.095\n    edge_positions = [0.3, 0.7]\n    \n    # Bottom edge\n    centers[4] = [edge_positions[0], edge_radius]\n    centers[5] = [edge_positions[1], edge_radius]\n    \n    # Top edge\n    centers[6] = [edge_positions[0], 1-edge_radius]\n    centers[7] = [edge_positions[1], 1-edge_radius]\n    \n    # Left edge\n    centers[8] = [edge_radius, edge_positions[0]]\n    centers[9] = [edge_radius, edge_positions[1]]\n    \n    # Right edge\n    centers[10] = [1-edge_radius, edge_positions[0]]\n    centers[11] = [1-edge_radius, edge_positions[1]]\n    \n    radii[4:12] = edge_radius\n\n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.115\n\n    # Inner grid (13 circles)\n    inner_radius = 0.08\n    grid_positions = [\n        (0.5, 0.3), (0.5, 0.7),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),\n        (0.4, 0.4), (0.6, 0.4), (0.4, 0.6), (0.6, 0.6),\n        (0.5, 0.5)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        if i < 13:  # Ensure we don't exceed 26 circles\n            centers[13+i] = pos\n            if pos == (0.5, 0.5):  # Center of grid gets slightly larger radius\n                radii[13+i] = 0.09\n            else:\n                radii[13+i] = inner_radius\n\n    return centers, radii\n\ndef initialize_pattern_concentric_26():\n    \"\"\"\n    Initialize with concentric rings of circles with carefully chosen radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.14\n\n    # First ring (6 circles)\n    ring1_radius = 0.11\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring1_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = ring1_radius\n\n    # Second ring (10 circles)\n    ring2_radius = 0.09\n    for i in range(10):\n        angle = 2 * np.pi * i / 10 + np.pi/10\n        dist = radii[0] + 2*ring1_radius + ring2_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = ring2_radius\n\n    # Corner circles (4 circles)\n    corner_radius = 0.12\n    centers[17] = [corner_radius, corner_radius]\n    centers[18] = [1-corner_radius, corner_radius]\n    centers[19] = [corner_radius, 1-corner_radius]\n    centers[20] = [1-corner_radius, 1-corner_radius]\n    radii[17:21] = corner_radius\n\n    # Edge circles (5 circles)\n    edge_radius = 0.08\n    centers[21] = [0.5, edge_radius]\n    centers[22] = [0.5, 1-edge_radius]\n    centers[23] = [edge_radius, 0.5]\n    centers[24] = [1-edge_radius, 0.5]\n    centers[25] = [0.25, 0.25]  # Extra circle to fill a gap\n    radii[21:26] = edge_radius\n\n    return centers, radii\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically designed for n=26 based on mathematical research.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.123\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.108\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place 8 medium-small circles at intermediate edge positions\n    mid_edge_radius = 0.095\n    centers[8] = [0.25, mid_edge_radius]\n    centers[9] = [0.75, mid_edge_radius]\n    centers[10] = [0.25, 1-mid_edge_radius]\n    centers[11] = [0.75, 1-mid_edge_radius]\n    centers[12] = [mid_edge_radius, 0.25]\n    centers[13] = [mid_edge_radius, 0.75]\n    centers[14] = [1-mid_edge_radius, 0.25]\n    centers[15] = [1-mid_edge_radius, 0.75]\n    radii[8:16] = mid_edge_radius\n\n    # Place a large circle in the center\n    centers[16] = [0.5, 0.5]\n    radii[16] = 0.135\n\n    # Place 9 smaller circles in a grid pattern\n    small_radius = 0.075\n    grid_positions = [\n        (0.3, 0.3), (0.5, 0.3), (0.7, 0.3),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.7), (0.5, 0.7), (0.7, 0.7),\n        (0.4, 0.4)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        centers[17+i] = pos\n        radii[17+i] = small_radius\n\n    return centers, radii\n\ndef initialize_pattern_random_26():\n    \"\"\"\n    Initialize with random circle positions and radii\n    \"\"\"\n    n = 26\n    centers = np.random.rand(n, 2) * 0.8 + 0.1  # Ensure circles are within bounds\n    radii = np.random.rand(n) * 0.07 + 0.06   # Radii between 0.06 and 0.13\n    return centers, radii\n\n\ndef optimize_packing(centers, radii, iterations=100, quick=False):\n    \"\"\"\n    Optimize circle positions and radii using a simple gradient descent approach.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        iterations: Number of optimization iterations\n        quick: If True, perform a faster but less thorough optimization\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        sum_radii = np.sum(current_radii)\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -sum_radii + penalty\n    \n    # Initial guess\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds for centers and radii\n    center_bounds = [(0.01, 0.99)] * (2 * n)\n    radii_bounds = [(0.03, 0.2)] * n\n    bounds = center_bounds + radii_bounds\n    \n    # Define optimization parameters\n    if quick:\n        options = {'maxiter': min(iterations, 30), 'ftol': 1e-5}\n    else:\n        options = {'maxiter': iterations, 'ftol': 1e-6}\n    \n    # Perform optimization\n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds, options=options)\n    \n    # Extract optimized centers and radii\n    final_centers = result.x[:2*n].reshape((n, 2))\n    final_radii = result.x[2*n:]\n    \n    return final_centers, final_radii\n\ndef refine_packing(centers, radii):\n    \"\"\"\n    Simplified refinement stage to improve packing.\n    \"\"\"\n    n = len(centers)\n    \n    # Perturb positions of smaller circles\n    sorted_indices = np.argsort(radii)\n    for i in range(min(5, n)):  # Perturb the smallest 5 circles\n        idx = sorted_indices[i]\n        centers[idx] += np.random.normal(0, 0.02, size=2)\n    \n    # Adjust radii slightly\n    radii *= 1.005  # Increase radii by a small amount\n    \n    # Re-optimize with reduced iterations\n    centers, radii = optimize_packing(centers, radii, iterations=30, quick=True)\n    \n    return centers, radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Uses a smooth, differentiable penalty function for better optimization.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    overlap_penalty_factor = 1000\n    boundary_penalty_factor = 1000\n    \n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                # Use a quadratic penalty with radius-dependent scaling\n                penalty += overlap_penalty_factor * overlap**2 * (radii[i] + radii[j])\n    \n    # Penalty for circles outside the unit square\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n    \n    return penalty\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["After analyzing the current program, I can see that we need to break through the 2.636 plateau and reach closer to the 2.645 target for packing 26 circles in a unit square. The current implementation has several patterns but might be trapped in local optima. I'll redesign the approach with more sophisticated optimization techniques and specialized patterns based on mathematical insights.\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using multi-stage optimization with specialized patterns and mathematical insights to maximize the sum of radii toward the theoretical optimal value of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport random\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    start_time = time.time()\n    max_time = 39  # Ensure we stay within time limits\n\n    # Define pattern generation functions\n    patterns = [\n        initialize_pattern_optimized_26,  # Our best pattern based on mathematical insights\n        initialize_pattern_hybrid_variable_26,\n        initialize_pattern_asymmetric_26,  # New asymmetric pattern\n        initialize_pattern_hexagonal_26,\n        initialize_pattern_optimized_corners_26,\n    ]\n    \n    # First optimization pass: try each pattern\n    for pattern_idx, pattern_func in enumerate(patterns):\n        if time.time() - start_time > max_time * 0.5:  # Use half the time for initial patterns\n            break\n            \n        try:\n            # Generate initial pattern\n            centers, radii = pattern_func()\n            \n            # Ensure we have exactly 26 circles\n            assert centers.shape[0] == n, f\"Pattern function returned {centers.shape[0]} circles instead of {n}\"\n            \n            # Quick optimization to improve the pattern\n            centers, radii = optimize_packing(centers, radii, iterations=25, quick=True)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n            # Try a perturbed version of this pattern\n            if pattern_idx < 2:  # Only for top patterns\n                perturbed_centers = centers.copy() + np.random.normal(0, 0.01, centers.shape)\n                perturbed_radii = radii.copy() * (1 + np.random.normal(0, 0.02, radii.shape))\n                \n                # Ensure perturbed radii are positive\n                perturbed_radii = np.maximum(perturbed_radii, 0.03)\n                \n                # Optimize the perturbed pattern\n                perturbed_centers, perturbed_radii = optimize_packing(perturbed_centers, perturbed_radii, iterations=20, quick=True)\n                \n                perturbed_sum = np.sum(perturbed_radii)\n                if perturbed_sum > best_sum:\n                    best_sum = perturbed_sum\n                    best_centers = perturbed_centers.copy()\n                    best_radii = perturbed_radii.copy()\n                    \n        except Exception as e:\n            continue\n\n    # Second pass: intensive optimization on the best pattern\n    if best_centers is not None:\n        remaining_time = max_time - (time.time() - start_time)\n        if remaining_time > 5:  # Only if we have enough time left\n            try:\n                # Multi-stage optimization\n                for i in range(3):  # Multiple optimization stages\n                    centers, radii = optimize_packing(best_centers, best_radii, \n                                                     iterations=40,\n                                                     quick=False)\n                    \n                    # Apply targeted perturbation between optimization stages\n                    if i < 2:  # Skip perturbation on final stage\n                        centers, radii = targeted_perturbation(centers, radii)\n                    \n                    sum_radii = np.sum(radii)\n                    if sum_radii > best_sum:\n                        best_sum = sum_radii\n                        best_centers = centers.copy()\n                        best_radii = radii.copy()\n            except Exception:\n                pass  # Keep the previous best if optimization fails\n\n    # Final refinement with specialized techniques\n    remaining_time = max_time - (time.time() - start_time)\n    if remaining_time > 3 and best_centers is not None:\n        try:\n            # Apply radius balancing to improve overall sum\n            centers, radii = radius_balancing(best_centers, best_radii)\n            \n            # Final quick optimization\n            centers, radii = optimize_packing(centers, radii, iterations=15, quick=True)\n            \n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception:\n            pass  # Keep the previous best if optimization fails\n\n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_optimized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research\n    and insights from circle packing literature.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners with carefully calculated radius\n    corner_radius = 0.129\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.110\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.138\n\n    # Place 8 circles in inner ring around center\n    inner_radius = 0.098\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n\n    # Place 9 smaller circles to fill gaps\n    small_radius = 0.082\n    grid_positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.33, 0.5), (0.67, 0.5), (0.5, 0.33), (0.5, 0.67),\n        (0.33, 0.33)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        centers[17+i] = pos\n        radii[17+i] = small_radius\n\n    return centers, radii\n\ndef initialize_pattern_hybrid_variable_26():\n    \"\"\"\n    Initialize with a hybrid pattern using variable-sized circles arranged in a pattern\n    that combines hexagonal and square grid elements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.127\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.108\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1-edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1-edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Central circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.135\n\n    # 8 circles in inner ring around center\n    inner_radius = 0.097\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_radius\n\n    # 9 circles in outer positions\n    outer_radius = 0.08\n    positions = [\n        (0.25, 0.25), (0.75, 0.25), (0.25, 0.75), (0.75, 0.75),\n        (0.25, 0.5), (0.75, 0.5), (0.33, 0.33), (0.67, 0.33), (0.67, 0.67)\n    ]\n    \n    for i, pos in enumerate(positions):\n        centers[17+i] = pos\n        radii[17+i] = outer_radius\n\n    return centers, radii\n\ndef initialize_pattern_asymmetric_26():\n    \"\"\"\n    Initialize with an asymmetric pattern that may help escape local optima\n    by breaking symmetry constraints.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Variable-sized corner circles\n    corner_radii = [0.128, 0.130, 0.126, 0.132]\n    centers[0] = [corner_radii[0], corner_radii[0]]\n    centers[1] = [1-corner_radii[1], corner_radii[1]]\n    centers[2] = [corner_radii[2], 1-corner_radii[2]]\n    centers[3] = [1-corner_radii[3], 1-corner_radii[3]]\n    for i in range(4):\n        radii[i] = corner_radii[i]\n\n    # Variable-sized edge circles\n    edge_radii = [0.107, 0.112, 0.109, 0.110]\n    centers[4] = [0.5, edge_radii[0]]\n    centers[5] = [0.5, 1-edge_radii[1]]\n    centers[6] = [edge_radii[2], 0.5]\n    centers[7] = [1-edge_radii[3], 0.5]\n    for i in range(4):\n        radii[4+i] = edge_radii[i]\n\n    # Off-center large circle\n    centers[8] = [0.52, 0.48]\n    radii[8] = 0.136\n\n    # Asymmetric ring around center\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + 0.1  # Slight rotation\n        dist = radii[8] + 0.098 + 0.001\n        if i % 2 == 0:\n            dist += 0.005  # Alternate distance\n        centers[9+i] = [centers[8][0] + dist * np.cos(angle), centers[8][1] + dist * np.sin(angle)]\n        radii[9+i] = 0.095 + 0.004 * (i % 3)  # Variable sizes\n\n    # Asymmetric filling circles\n    positions = [\n        (0.24, 0.26), (0.76, 0.23), (0.27, 0.74), (0.73, 0.77),\n        (0.26, 0.52), (0.74, 0.48), (0.34, 0.32), (0.66, 0.34), (0.68, 0.66)\n    ]\n    \n    sizes = [0.083, 0.079, 0.081, 0.084, 0.082, 0.080, 0.078, 0.082, 0.081]\n    \n    for i, pos in enumerate(positions):\n        centers[17+i] = pos\n        radii[17+i] = sizes[i]\n\n    return centers, radii\n\ndef initialize_pattern_hexagonal_26():\n    \"\"\"\n    Initialize with a hexagonal pattern optimized for n=26, with larger circles in the center\n    and corners, and smaller circles to fill gaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place a large circle in the center\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.137\n\n    # Place 6 circles in the first hexagonal ring\n    first_ring_radius = 0.102\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + first_ring_radius + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = first_ring_radius\n\n    # Place 12 circles in the second hexagonal ring\n    second_ring_radius = 0.089\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*first_ring_radius + second_ring_radius + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = second_ring_radius\n\n    # Place 4 larger circles in the corners\n    corner_radius = 0.126\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1-corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1-corner_radius]\n    centers[22] = [1-corner_radius, 1-corner_radius]\n    radii[19:23] = corner_radius\n\n    # Place 3 medium circles to fill remaining spaces\n    medium_radius = 0.083\n    centers[23] = [0.25, 0.75]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.75, 0.75]\n    radii[23:26] = medium_radius\n\n    return centers, radii\n\ndef initialize_pattern_optimized_corners_26():\n    \"\"\"\n    Initialize with a pattern that optimizes corner and edge utilization with\n    variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.128\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1-corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1-corner_radius]\n    centers[3] = [1-corner_radius, 1-corner_radius]\n    radii[0:4] = corner_radius\n\n    # 8 edge circles (2 on each edge)\n    edge_radius = 0.095\n    edge_positions = [0.3, 0.7]\n    \n    # Bottom edge\n    centers[4] = [edge_positions[0], edge_radius]\n    centers[5] = [edge_positions[1], edge_radius]\n    \n    # Top edge\n    centers[6] = [edge_positions[0], 1-edge_radius]\n    centers[7] = [edge_positions[1], 1-edge_radius]\n    \n    # Left edge\n    centers[8] = [edge_radius, edge_positions[0]]\n    centers[9] = [edge_radius, edge_positions[1]]\n    \n    # Right edge\n    centers[10] = [1-edge_radius, edge_positions[0]]\n    centers[11] = [1-edge_radius, edge_positions[1]]\n    \n    radii[4:12] = edge_radius\n\n    # Center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.135\n\n    # Inner grid (13 circles)\n    inner_radius = 0.08\n    grid_positions = [\n        (0.5, 0.3), (0.5, 0.7),\n        (0.3, 0.5), (0.7, 0.5),\n        (0.3, 0.3), (0.7, 0.3), (0.3, 0.7), (0.7, 0.7),\n        (0.4, 0.4), (0.6, 0.4), (0.4, 0.6), (0.6, 0.6),\n        (0.5, 0.5)\n    ]\n    \n    for i, pos in enumerate(grid_positions):\n        if i < 13:  # Ensure we don't exceed 26 circles\n            centers[13+i] = pos\n            if pos == (0.5, 0.5):  # Center of grid gets slightly larger radius\n                radii[13+i] = 0.09\n            else:\n                radii[13+i] = inner_radius\n\n    return centers, radii\n\ndef optimize_packing(centers, radii, iterations=100, quick=False):\n    \"\"\"\n    Optimize circle positions and radii using the L-BFGS-B optimization algorithm.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        iterations: Number of optimization iterations\n        quick: If True, perform a faster but less thorough optimization\n        \n    Returns:\n        Tuple of (optimized_centers, optimized_radii)\n    \"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        \"\"\"Objective function to minimize (negative sum of radii + penalty).\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        sum_radii = np.sum(current_radii)\n        penalty = calculate_penalty(current_centers, current_radii)\n        return -sum_radii + penalty\n    \n    # Initial guess\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds for centers and radii\n    center_bounds = [(0.01, 0.99)] * (2 * n)\n    radii_bounds = [(0.03, 0.2)] * n\n    bounds = center_bounds + radii_bounds\n    \n    # Define optimization parameters\n    if quick:\n        options = {'maxiter': min(iterations, 30), 'ftol': 1e-5}\n        method = 'L-BFGS-B'\n    else:\n        options = {'maxiter': iterations, 'ftol': 1e-6}\n        method = 'L-BFGS-B'\n    \n    # Perform optimization\n    result = minimize(objective, x0, method=method, bounds=bounds, options=options)\n    \n    # Extract optimized centers and radii\n    final_centers = result.x[:2*n].reshape((n, 2))\n    final_radii = result.x[2*n:]\n    \n    return final_centers, final_radii\n\ndef targeted_perturbation(centers, radii):\n    \"\"\"\n    Apply targeted perturbation to help escape local optima.\n    Focus on perturbing smaller circles and areas with lower density.\n    \n    Args:\n        centers: Current circle centers\n        radii: Current circle radii\n        \n    Returns:\n        Tuple of (perturbed_centers, perturbed_radii)\n    \"\"\"\n    n = len(centers)\n    perturbed_centers = centers.copy()\n    perturbed_radii = radii.copy()\n    \n    # Identify smaller circles (bottom 30%)\n    size_threshold = np.percentile(radii, 30)\n    small_indices = np.where(radii <= size_threshold)[0]\n    \n    # Perturb positions of smaller circles\n    for idx in small_indices:\n        perturbed_centers[idx] += np.random.normal(0, 0.02, size=2)\n        \n        # Keep within bounds\n        perturbed_centers[idx] = np.clip(perturbed_centers[idx], 0.01, 0.99)\n    \n    # Calculate local density for each circle\n    densities = np.zeros(n)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                densities[i] += 1.0 / (dist + 0.1)  # Add small constant to avoid division by zero\n    \n    # Identify areas with lower density (bottom 40%)\n    density_threshold = np.percentile(densities, 40)\n    low_density_indices = np.where(densities <= density_threshold)[0]\n    \n    # Perturb radii in low density areas\n    for idx in low_density_indices:\n        # Increase radius slightly in low density areas\n        perturbed_radii[idx] *= (1 + np.random.uniform(0, 0.03))\n    \n    # Ensure all radii are positive\n    perturbed_radii = np.maximum(perturbed_radii, 0.03)\n    \n    return perturbed_centers, perturbed_radii\n\ndef radius_balancing(centers, radii):\n    \"\"\"\n    Balance radii to maximize overall sum while maintaining validity.\n    This function tries to redistribute radius from circles with more \"slack\" to those with less.\n    \n    Args:\n        centers: Current circle centers\n        radii: Current circle radii\n        \n    Returns:\n        Tuple of (centers, balanced_radii)\n    \"\"\"\n    n = len(centers)\n    balanced_radii = radii.copy()\n    \n    # Calculate \"slack\" for each circle (how much it can grow before hitting another)\n    slack = np.zeros(n)\n    for i in range(n):\n        min_slack = float('inf')\n        \n        # Check distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                current_slack = dist - (radii[i] + radii[j])\n                min_slack = min(min_slack, current_slack)\n        \n        # Check distance to boundaries\n        for coord in range(2):\n            boundary_slack = min(centers[i, coord] - radii[i], 1 - centers[i, coord] - radii[i])\n            min_slack = min(min_slack, boundary_slack)\n        \n        slack[i] = max(0, min_slack)\n    \n    # Identify circles with more slack and those with less\n    median_slack = np.median(slack)\n    high_slack_indices = np.where(slack > median_slack)[0]\n    low_slack_indices = np.where(slack < median_slack * 0.5)[0]\n    \n    # Redistribute radius from high slack to low slack circles\n    total_redistribution = 0\n    for idx in high_slack_indices:\n        # Take a small portion of the slack\n        reduction = slack[idx] * 0.3\n        balanced_radii[idx] -= reduction\n        total_redistribution += reduction\n    \n    # Distribute the collected radius to low slack circles\n    if len(low_slack_indices) > 0 and total_redistribution > 0:\n        per_circle_increase = total_redistribution / len(low_slack_indices)\n        for idx in low_slack_indices:\n            balanced_radii[idx] += per_circle_increase\n    \n    # Final validity check and correction\n    for i in range(n):\n        # Check against other circles\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = balanced_radii[i] + balanced_radii[j] - dist\n            if overlap > 0:\n                # Reduce both radii proportionally\n                reduction = overlap / 2\n                balanced_radii[i] -= reduction\n                balanced_radii[j] -= reduction\n        \n        # Check against boundaries\n        for coord in range(2):\n            if centers[i, coord] - balanced_radii[i] < 0:\n                balanced_radii[i] = centers[i, coord]\n            if centers[i, coord] + balanced_radii[i] > 1:\n                balanced_radii[i] = 1 - centers[i, coord]\n    \n    # Ensure all radii are positive\n    balanced_radii = np.maximum(balanced_radii, 0.03)\n    \n    return centers, balanced_radii\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Uses a smooth, differentiable penalty function for better optimization.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    overlap_penalty_factor = 1000\n    boundary_penalty_factor = 1000\n    \n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                # Use a quadratic penalty with radius-dependent scaling\n                penalty += overlap_penalty_factor * overlap**2 * (radii[i] + radii[j])\n    \n    # Penalty for circles outside the unit square\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 0])**2\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 0] + radii[i] - 1)**2\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += boundary_penalty_factor * (radii[i] - centers[i, 1])**2\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += boundary_penalty_factor * (centers[i, 1] + radii[i] - 1)**2\n    \n    return penalty\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```"]}}}