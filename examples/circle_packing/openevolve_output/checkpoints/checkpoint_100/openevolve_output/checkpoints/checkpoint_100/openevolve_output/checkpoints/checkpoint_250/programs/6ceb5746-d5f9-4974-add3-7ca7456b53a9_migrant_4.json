{"id": "6ceb5746-d5f9-4974-add3-7ca7456b53a9_migrant_4", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n\n    # Try multiple specialized patterns known to be effective for n=26\n    patterns = [\n        initialize_pattern_greedy_corners,\n        initialize_pattern_hexagonal_optimal,\n        initialize_pattern_hybrid_optimal,\n        initialize_pattern_variable_size,\n        initialize_pattern_edge_optimized,\n        initialize_pattern_research_based\n    ]\n\n    for pattern_func in patterns:\n        # Initialize with a specialized pattern\n        centers, radii = pattern_func(n)\n        \n        # Optimize with a two-stage approach\n        centers, radii = optimize_packing(centers, radii)\n        \n        # Keep the best result\n        sum_radii = np.sum(radii)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n\n    return best_centers, best_radii, best_sum\n\ndef initialize_pattern_greedy_corners(n):\n    \"\"\"\n    Initialize with a pattern that maximizes corner utilization with variable sizes.\n    This pattern is based on mathematical research for optimal circle packing.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Four large corner circles - these are critical for optimal packing\n    corner_radius = 0.1464\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Four circles at the midpoints of edges\n    edge_radius = 0.1\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Center circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.12\n    \n    # Inner ring of 8 circles around center\n    inner_radius = 0.095\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n    \n    # Additional circles to fill gaps\n    gap_radius = 0.08\n    centers[17] = [0.25, 0.25]\n    centers[18] = [0.75, 0.25]\n    centers[19] = [0.25, 0.75]\n    centers[20] = [0.75, 0.75]\n    radii[17:21] = gap_radius\n    \n    # Smaller circles to fill remaining spaces\n    small_radius = 0.07\n    centers[21] = [0.3, 0.5]\n    centers[22] = [0.7, 0.5]\n    centers[23] = [0.5, 0.3]\n    centers[24] = [0.5, 0.7]\n    centers[25] = [0.5, 0.85]\n    radii[21:26] = small_radius\n    \n    return centers, radii\n\ndef initialize_pattern_hexagonal_optimal(n):\n    \"\"\"\n    Initialize with a hexagonal-based pattern with variable sizes.\n    This is inspired by densest circle packing arrangements.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Large center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.135\n    \n    # First hexagonal ring (6 circles)\n    ring1_radius = 0.11\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring1_radius\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = ring1_radius\n    \n    # Second hexagonal ring (12 circles)\n    ring2_radius = 0.095\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * ring1_radius + ring2_radius\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = ring2_radius\n    \n    # Four corner circles - these are critical for optimal packing\n    corner_radius = 0.1\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1 - corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1 - corner_radius]\n    centers[22] = [1 - corner_radius, 1 - corner_radius]\n    radii[19:23] = corner_radius\n    \n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.07\n    centers[23] = [0.25, 0.5]\n    centers[24] = [0.75, 0.5]\n    centers[25] = [0.5, 0.25]\n    radii[23:26] = small_radius\n    \n    return centers, radii\n\ndef initialize_pattern_hybrid_optimal(n):\n    \"\"\"\n    Initialize with a hybrid pattern combining hexagonal and square grid elements.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Four large corner circles\n    corner_radius = 0.1464\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Large center circle\n    centers[4] = [0.5, 0.5]\n    radii[4] = 0.125\n    \n    # Inner ring of 6 circles around center\n    inner_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[4] + inner_radius\n        centers[5 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[5 + i] = inner_radius\n    \n    # Midpoint edge circles\n    edge_radius = 0.09\n    centers[11] = [0.5, edge_radius]\n    centers[12] = [0.5, 1 - edge_radius]\n    centers[13] = [edge_radius, 0.5]\n    centers[14] = [1 - edge_radius, 0.5]\n    radii[11:15] = edge_radius\n    \n    # Additional circles to fill gaps\n    gap_radius = 0.08\n    centers[15] = [0.25, 0.25]\n    centers[16] = [0.75, 0.25]\n    centers[17] = [0.25, 0.75]\n    centers[18] = [0.75, 0.75]\n    radii[15:19] = gap_radius\n    \n    # Smaller circles for remaining spaces\n    small_radius = 0.075\n    positions = [\n        [0.33, 0.5], [0.67, 0.5], [0.5, 0.33], [0.5, 0.67],\n        [0.33, 0.33], [0.67, 0.33], [0.33, 0.67]\n    ]\n    \n    for i in range(7):\n        if i + 19 < n:\n            centers[i + 19] = positions[i]\n            radii[i + 19] = small_radius\n    \n    return centers, radii\n\ndef initialize_pattern_variable_size(n):\n    \"\"\"\n    Initialize with a pattern specifically designed for n=26 with highly variable sizes.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Four large corner circles - mathematical optimum for corners\n    corner_radius = 0.1464\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Four edge circles\n    edge_radius = 0.11\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Large center circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.13\n    \n    # First ring of 6 medium circles\n    medium_radius = 0.095\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[8] + medium_radius\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = medium_radius\n    \n    # Four circles near quarter positions\n    quarter_radius = 0.08\n    centers[15] = [0.25, 0.25]\n    centers[16] = [0.75, 0.25]\n    centers[17] = [0.25, 0.75]\n    centers[18] = [0.75, 0.75]\n    radii[15:19] = quarter_radius\n    \n    # Seven smaller circles to fill gaps\n    small_radius = 0.07\n    positions = [\n        [0.33, 0.5], [0.67, 0.5], [0.5, 0.33], [0.5, 0.67],\n        [0.33, 0.33], [0.67, 0.33], [0.33, 0.67]\n    ]\n    \n    for i in range(7):\n        if i + 19 < n:\n            centers[i + 19] = positions[i]\n            radii[i + 19] = small_radius\n    \n    return centers, radii\n\ndef initialize_pattern_edge_optimized(n):\n    \"\"\"\n    Initialize with a pattern that maximizes edge utilization.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Four large corner circles\n    corner_radius = 0.1464\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Eight edge circles (2 on each edge)\n    edge_radius = 0.09\n    edge_positions = [0.3, 0.7]\n    \n    # Bottom edge\n    centers[4] = [edge_positions[0], edge_radius]\n    centers[5] = [edge_positions[1], edge_radius]\n    \n    # Top edge\n    centers[6] = [edge_positions[0], 1 - edge_radius]\n    centers[7] = [edge_positions[1], 1 - edge_radius]\n    \n    # Left edge\n    centers[8] = [edge_radius, edge_positions[0]]\n    centers[9] = [edge_radius, edge_positions[1]]\n    \n    # Right edge\n    centers[10] = [1 - edge_radius, edge_positions[0]]\n    centers[11] = [1 - edge_radius, edge_positions[1]]\n    \n    radii[4:12] = edge_radius\n    \n    # Large center circle\n    centers[12] = [0.5, 0.5]\n    radii[12] = 0.13\n    \n    # Inner ring of 6 circles\n    inner_radius = 0.095\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[12] + inner_radius\n        centers[13 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[13 + i] = inner_radius\n    \n    # Fill remaining spaces with 7 smaller circles\n    small_radius = 0.07\n    positions = [\n        [0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75],\n        [0.4, 0.4], [0.6, 0.4], [0.5, 0.75]\n    ]\n    \n    for i in range(7):\n        if i + 19 < n:\n            centers[i + 19] = positions[i]\n            radii[i + 19] = small_radius\n    \n    return centers, radii\n\ndef initialize_pattern_research_based(n):\n    \"\"\"\n    Initialize with a pattern based on mathematical research for n=26.\n    This uses the exact mathematical optimum for corner circles.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Four large corner circles - mathematical optimum is r = (3-2\u221a2)/2 \u2248 0.1464\n    corner_radius = (3 - 2 * np.sqrt(2)) / 2\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n    \n    # Edge circles\n    edge_radius = 0.11\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n    \n    # Large center circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.135\n    \n    # First ring of 6 circles\n    ring1_radius = 0.1\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[8] + ring1_radius\n        centers[i + 9] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 9] = ring1_radius\n    \n    # Second partial ring of 4 circles\n    ring2_radius = 0.085\n    for i in range(4):\n        angle = 2 * np.pi * i / 4 + np.pi / 4\n        dist = radii[8] + 2 * ring1_radius + ring2_radius\n        centers[i + 15] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 15] = ring2_radius\n    \n    # Fill remaining spaces with 7 smaller circles\n    small_radius = 0.075\n    positions = [\n        [0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75],\n        [0.35, 0.5], [0.65, 0.5], [0.5, 0.35]\n    ]\n    \n    for i in range(7):\n        if i + 19 < n:\n            centers[i + 19] = positions[i]\n            radii[i + 19] = small_radius\n    \n    return centers, radii\n\ndef optimize_packing(centers, radii):\n    \"\"\"\n    Optimize circle packing using a two-stage approach.\n    First optimize positions with fixed radii, then optimize both.\n    \"\"\"\n    n = len(centers)\n    \n    # Stage 1: Optimize positions with fixed radii\n    def objective_positions(x):\n        \"\"\"Maximize minimum distance between circles (scaled by radii)\"\"\"\n        current_centers = x.reshape((n, 2))\n        min_dist_ratio = float('inf')\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(current_centers[i] - current_centers[j])\n                required_dist = radii[i] + radii[j]\n                ratio = dist / required_dist if required_dist > 0 else float('inf')\n                min_dist_ratio = min(min_dist_ratio, ratio)\n                \n        return -min_dist_ratio  # Maximize minimum distance ratio\n    \n    def constraint_positions(x):\n        \"\"\"Ensure circles stay within unit square and don't overlap\"\"\"\n        current_centers = x.reshape((n, 2))\n        constraints = []\n        \n        # Circles within unit square\n        for i in range(n):\n            constraints.append(current_centers[i, 0] - radii[i])  # x >= r\n            constraints.append(1 - current_centers[i, 0] - radii[i])  # x <= 1-r\n            constraints.append(current_centers[i, 1] - radii[i])  # y >= r\n            constraints.append(1 - current_centers[i, 1] - radii[i])  # y <= 1-r\n        \n        # No overlapping\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(current_centers[i] - current_centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n                \n        return np.array(constraints)\n    \n    # Optimize positions\n    x0_positions = centers.flatten()\n    cons_positions = {'type': 'ineq', 'fun': constraint_positions}\n    \n    res_positions = minimize(\n        objective_positions, \n        x0_positions, \n        method='SLSQP', \n        constraints=cons_positions, \n        options={'maxiter': 300, 'ftol': 1e-6}\n    )\n    \n    optimized_centers = res_positions.x.reshape((n, 2))\n    \n    # Stage 2: Optimize both positions and radii\n    def objective_full(x):\n        \"\"\"Objective function to maximize sum of radii\"\"\"\n        current_radii = x[2*n:]\n        return -np.sum(current_radii)\n    \n    def constraint_full(x):\n        \"\"\"Constraints for full optimization\"\"\"\n        current_centers = x[:2*n].reshape((n, 2))\n        current_radii = x[2*n:]\n        constraints = []\n        \n        # Circles within unit square\n        for i in range(n):\n            constraints.append(current_centers[i, 0] - current_radii[i])  # x >= r\n            constraints.append(1 - current_centers[i, 0] - current_radii[i])  # x <= 1-r\n            constraints.append(current_centers[i, 1] - current_radii[i])  # y >= r\n            constraints.append(1 - current_centers[i, 1] - current_radii[i])  # y <= 1-r\n            constraints.append(current_radii[i] - 0.01)  # Minimum radius\n        \n        # No overlapping\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(current_centers[i] - current_centers[j])\n                constraints.append(dist - current_radii[i] - current_radii[j] - 1e-6)\n                \n        return np.array(constraints)\n    \n    # Optimize positions and radii\n    x0_full = np.concatenate([optimized_centers.flatten(), radii])\n    cons_full = {'type': 'ineq', 'fun': constraint_full}\n    \n    res_full = minimize(\n        objective_full, \n        x0_full, \n        method='SLSQP', \n        constraints=cons_full, \n        options={'maxiter': 500, 'ftol': 1e-8}\n    )\n    \n    final_centers = res_full.x[:2*n].reshape((n, 2))\n    final_radii = res_full.x[2*n:]\n    \n    # Final refinement with increased precision\n    def refine_packing(centers, radii):\n        \"\"\"Refine the packing with a focused optimization\"\"\"\n        x0 = np.concatenate([centers.flatten(), radii])\n        \n        res = minimize(\n            objective_full, \n            x0, \n            method='SLSQP', \n            constraints=cons_full, \n            options={'maxiter': 1000, 'ftol': 1e-10}\n        )\n        \n        refined_centers = res.x[:2*n].reshape((n, 2))\n        refined_radii = res.x[2*n:]\n        \n        return refined_centers, refined_radii\n    \n    # Apply final refinement\n    final_centers, final_radii = refine_packing(final_centers, final_radii)\n    \n    return final_centers, final_radii\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "6ceb5746-d5f9-4974-add3-7ca7456b53a9", "generation": 9, "timestamp": 1750811354.7836862, "iteration_found": 0, "metrics": {"validity": 1.0, "sum_radii": 2.6266678519590396, "target_ratio": 0.9968378944816091, "combined_score": 0.9968378944816091, "eval_time": 42.1537823677063}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "sum_radii": 0.0, "target_ratio": 0.0, "combined_score": 0.0}, "island": 4, "migrant": true}, "artifacts_json": null, "artifact_dir": null}