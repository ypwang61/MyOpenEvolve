{"id": "54126da2-1bf6-41b0-82b5-9e88e0a7ff11_migrant_1", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization with gradient-based refinement\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n\n    # Try multiple specialized patterns known to be effective for n=26\n    patterns = [\n        initialize_pattern_corner_optimized_26, # Keep this one as it's generally good\n        initialize_pattern_research_26,\n        initialize_pattern_hybrid_26,\n        initialize_pattern_ring_26,\n        initialize_pattern_hexagonal_like_26 #Add a new pattern\n    ]\n\n    for pattern_func in patterns:\n        # Initialize with a specialized pattern\n        centers, radii = pattern_func()\n        \n        # Ensure we have exactly 26 circles\n        assert centers.shape[0] == n, f\"Pattern function {pattern_func.__name__} returned {centers.shape[0]} circles instead of {n}\"\n        \n        # Perform optimization\n        try:\n            centers, radii = optimize_with_scipy(centers, radii)\n            \n            # Keep the best result\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        except Exception as e:\n            logging.error(f\"Optimization failed for {pattern_func.__name__}: {e}\")\n            continue\n\n    return best_centers, best_radii, best_sum\n\n\n\ndef initialize_pattern_hexagonal_like_26():\n    \"\"\"\n    Initialize with a pattern resembling a hexagonal packing, adapted for the square.\n    This will be more flexible than a strict hexagonal grid.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Approximate hexagonal grid parameters\n    radius = 0.085  # Initial guess for radius\n    x_spacing = radius * np.sqrt(3)\n    y_spacing = radius * 2\n\n    # Start filling the grid from the center outwards\n    center_x, center_y = 0.5, 0.5\n    count = 0\n\n    # Fill circles row by row\n    rows = [0]  # Start with the center row\n    while count < n:\n        new_rows = []\n        for row_offset in rows:\n            y = center_y + row_offset * y_spacing\n\n            # Calculate the number of circles in this row\n            num_circles = int(np.floor((1 - radius * 2) / x_spacing)) + 1\n\n            # Calculate the horizontal offset for even rows\n            x_offset = 0 if row_offset % 2 == 0 else x_spacing / 2\n\n            # Place circles in the row\n            for i in range(num_circles):\n                x = center_x - (num_circles - 1) * x_spacing / 2 + i * x_spacing + x_offset\n                if count < n:\n                    centers[count] = [x, y]\n                    radii[count] = radius\n                    count += 1\n                else:\n                    break\n\n            # Add new rows\n            if row_offset == 0:\n                new_rows.append(1)\n                new_rows.append(-1)\n            else:\n                new_rows.append(row_offset + 1)\n                new_rows.append(row_offset - 1)\n\n        # Remove duplicates and sort\n        rows = sorted(list(set(new_rows)))\n\n    # Adjust radii slightly to fill space\n    radii = np.clip(radii, 0.05, 0.12) # Limit radius range\n\n    return centers, radii\n\n\ndef initialize_pattern_research_26():\n    \"\"\"\n    Initialize with a pattern based on mathematical research for n=26,\n    specifically targeting the known optimal arrangement.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.132\n    \n    # First ring - 6 circles in hexagonal arrangement\n    ring1_radius = 0.107\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring1_radius + 0.002 # slight increase in distance\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = ring1_radius\n    \n    # Second ring - 12 circles\n    ring2_radius = 0.097\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12  # Offset to stagger\n        dist = radii[0] + 2 * ring1_radius + 0.015 # slight increase in distance\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = ring2_radius\n    \n    # Corner circles - 4 circles\n    corner_radius = 0.115\n    centers[19] = [corner_radius, corner_radius]\n    centers[20] = [1 - corner_radius, corner_radius]\n    centers[21] = [corner_radius, 1 - corner_radius]\n    centers[22] = [1 - corner_radius, 1 - corner_radius]\n    radii[19:23] = corner_radius\n    \n    # Edge circles - 3 circles\n    edge_radius = 0.092\n    centers[23] = [0.5, edge_radius]\n    centers[24] = [edge_radius, 0.5]\n    centers[25] = [1 - edge_radius, 0.5]\n    radii[23:26] = edge_radius\n    \n    return centers, radii\n\n\ndef initialize_pattern_specialized_26():\n    \"\"\"\n    Initialize with a pattern specifically optimized for n=26 based on mathematical research.\n    This pattern uses a hybrid approach with variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Place 4 large circles in corners\n    corner_radius = 0.115\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # Place 4 medium circles at midpoints of edges\n    edge_radius = 0.1\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # Place a large circle in the center\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.12\n\n    # Place 8 circles in inner ring around center\n    inner_radius = 0.095\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_radius\n        centers[9 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9 + i] = inner_radius\n\n    # Place 9 circles in outer ring\n    outer_radius = 0.08\n    for i in range(9):\n        angle = 2 * np.pi * i / 9\n        dist = radii[8] + 2 * inner_radius + outer_radius\n        centers[17 + i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17 + i] = outer_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_hybrid_26():\n    \"\"\"\n    Initialize with a hybrid pattern optimized for n=26 with strategic placement\n    of variable-sized circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.127\n\n    # Inner ring (6 circles)\n    inner_radius = 0.102\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius + 0.002 # slight increase in distance\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = inner_radius\n\n    # Middle ring (8 circles, slightly offset)\n    middle_radius = 0.092\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + np.pi / 8\n        dist = radii[0] + 2 * inner_radius + middle_radius + 0.003 # slight increase in distance\n        centers[i + 7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 7] = middle_radius\n\n    # Corner circles (4 larger circles)\n    corner_radius = 0.113\n    centers[15] = [corner_radius, corner_radius]\n    centers[16] = [1 - corner_radius, corner_radius]\n    centers[17] = [corner_radius, 1 - corner_radius]\n    centers[18] = [1 - corner_radius, 1 - corner_radius]\n    radii[15:19] = corner_radius\n\n    # Edge circles (4 medium circles)\n    edge_radius = 0.087\n    centers[19] = [0.5, edge_radius]\n    centers[20] = [0.5, 1 - edge_radius]\n    centers[21] = [edge_radius, 0.5]\n    centers[22] = [1 - edge_radius, 0.5]\n    radii[19:23] = edge_radius\n\n    # Fill remaining spaces with 3 smaller circles\n    small_radius = 0.072\n    centers[23] = [0.25, 0.25]\n    centers[24] = [0.75, 0.25]\n    centers[25] = [0.25, 0.75]\n    radii[23:26] = small_radius\n\n    return centers, radii\n\n\n\ndef initialize_pattern_corner_optimized_26():\n    \"\"\"\n    Initialize with a pattern that emphasizes optimal corner and edge utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # 4 large corner circles\n    corner_radius = 0.122\n    centers[0] = [corner_radius, corner_radius]\n    centers[1] = [1 - corner_radius, corner_radius]\n    centers[2] = [corner_radius, 1 - corner_radius]\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[0:4] = corner_radius\n\n    # 4 medium edge circles\n    edge_radius = 0.097\n    centers[4] = [0.5, edge_radius]\n    centers[5] = [0.5, 1 - edge_radius]\n    centers[6] = [edge_radius, 0.5]\n    centers[7] = [1 - edge_radius, 0.5]\n    radii[4:8] = edge_radius\n\n    # 8 smaller edge circles\n    small_edge_radius = 0.082\n    centers[8] = [0.25, small_edge_radius]\n    centers[9] = [0.75, small_edge_radius]\n    centers[10] = [0.25, 1 - small_edge_radius]\n    centers[11] = [0.75, 1 - small_edge_radius]\n    centers[12] = [small_edge_radius, 0.25]\n    centers[13] = [small_edge_radius, 0.75]\n    centers[14] = [1 - small_edge_radius, 0.25]\n    centers[15] = [1 - small_edge_radius, 0.75]\n    radii[8:16] = small_edge_radius\n\n    # Inner grid (10 circles)\n    inner_radius = 0.077\n    grid_positions = [0.3, 0.5, 0.7]\n    \n    count = 16\n    grid_points = []\n    for x in grid_positions:\n        for y in grid_positions:\n            grid_points.append((x, y))\n    \n    # Ensure we don't exceed 26 circles\n    for x, y in grid_points[:n-count]:\n        if x == 0.5 and y == 0.5:\n            # Larger circle in the center\n            centers[count] = [x, y]\n            radii[count] = 0.115\n        else:\n            centers[count] = [x, y]\n            radii[count] = inner_radius\n        count += 1\n\n    # Fill any remaining slots\n    while count < n:\n        centers[count] = [0.4 + 0.2 * (count - 16) / 10, 0.4 + 0.2 * ((count - 16) % 3) / 3]\n        radii[count] = 0.07\n        count += 1\n\n    return centers, radii\n\n\ndef initialize_pattern_ring_26():\n    \"\"\"\n    Initialize with concentric rings of circles, optimized for n=26.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.135\n\n    # First ring (8 circles)\n    ring1_radius = 0.098\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_radius\n        centers[i + 1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 1] = ring1_radius\n\n    # Second ring (12 circles)\n    ring2_radius = 0.088\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi / 12\n        dist = radii[0] + 2 * ring1_radius + ring2_radius\n        centers[i + 9] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i + 9] = ring2_radius\n\n    # Corner circles (4 circles)\n    corner_radius = 0.093\n    centers[21] = [corner_radius, corner_radius]\n    centers[22] = [1 - corner_radius, corner_radius]\n    centers[23] = [corner_radius, 1 - corner_radius]\n    centers[24] = [1 - corner_radius, 1 - corner_radius]\n    radii[21:25] = corner_radius\n\n    # One extra circle\n    centers[25] = [0.5, 0.15]\n    radii[25] = 0.083\n\n    return centers, radii\n\n\ndef optimize_with_scipy(centers, radii):\n    \"\"\"\n    Optimize circle positions and radii using scipy.optimize.minimize.\n    Uses a multi-stage approach with progressive refinement and gradient-based optimization.\n    \"\"\"\n    n = len(centers)\n    \n    # Stage 1: Optimize positions with fixed radii (L-BFGS-B)\n    def objective_positions(x):\n        current_centers = x.reshape((n, 2))\n        return calculate_penalty(current_centers, radii)\n\n    x0_positions = centers.flatten()\n    bounds_positions = [(0, 1) for _ in range(2 * n)]\n\n    res_positions = minimize(\n        objective_positions,\n        x0_positions,\n        method='L-BFGS-B',\n        bounds=bounds_positions,\n        jac=None,  # Let scipy estimate the Jacobian\n        options={'maxiter': 200, 'ftol': 1e-7}\n    )\n\n    improved_centers = res_positions.x.reshape((n, 2))\n\n    # Stage 2: Optimize radii with fixed positions (SLSQP)\n    def objective_radii(r):\n        return -np.sum(r)  # Maximize sum of radii\n\n    def constraint_radii(r):\n        constraints = []\n        for i in range(n):\n            # Circle within bounds\n            constraints.extend([\n                improved_centers[i, 0] - r[i],  # x >= r\n                1 - improved_centers[i, 0] - r[i],  # x <= 1 - r\n                improved_centers[i, 1] - r[i],  # y >= r\n                1 - improved_centers[i, 1] - r[i],  # y <= 1 - r\n            ])\n            for j in range(i + 1, n):\n                # Non-overlapping circles\n                dist = np.linalg.norm(improved_centers[i] - improved_centers[j])\n                constraints.append(dist - r[i] - r[j] - 1e-7)  # Add small tolerance\n        return np.array(constraints)\n\n    cons_radii = {'type': 'ineq', 'fun': constraint_radii}\n    bounds_radii = [(0.01, 0.4) for _ in range(n)]  # Radius bounds\n\n    res_radii = minimize(\n        objective_radii,\n        radii,\n        method='SLSQP',\n        constraints=cons_radii,\n        bounds=bounds_radii,\n        jac=None,\n        options={'maxiter': 300, 'ftol': 1e-7}\n    )\n    \n    improved_radii = res_radii.x\n\n    # Stage 3: Joint optimization with progressive refinement and larger tolerance\n    best_centers = improved_centers.copy()\n    best_radii = improved_radii.copy()\n    best_sum = np.sum(best_radii)\n\n    def objective_joint(x):\n        current_centers = x[:2 * n].reshape((n, 2))\n        current_radii = x[2 * n:]\n        return -np.sum(current_radii)\n\n    def constraint_joint(x):\n        current_centers = x[:2 * n].reshape((n, 2))\n        current_radii = x[2 * n:]\n        constraints = []\n\n        # Circle within bounds\n        for i in range(n):\n            constraints.extend([\n                current_centers[i, 0] - current_radii[i],  # x >= r\n                1 - current_centers[i, 0] - current_radii[i],  # x <= 1 - r\n                current_centers[i, 1] - current_radii[i],  # y >= r\n                1 - current_centers[i, 1] - current_radii[i],  # y <= 1 - r\n            ])\n            for j in range(i + 1, n):\n                # Non-overlapping circles\n                dist = np.linalg.norm(current_centers[i] - current_centers[j])\n                constraints.append(dist - current_radii[i] - current_radii[j] - 1e-6)  # Add small tolerance\n\n        return np.array(constraints)\n\n    x0_joint = np.concatenate([best_centers.flatten(), best_radii])\n    bounds_joint = [(0, 1) for _ in range(2 * n)] + [(0.01, 0.4) for _ in range(n)]\n    cons_joint = {'type': 'ineq', 'fun': constraint_joint}\n\n    res_joint = minimize(\n        objective_joint,\n        x0_joint,\n        method='SLSQP',\n        constraints=cons_joint,\n        bounds=bounds_joint,\n        jac=None,\n        options={'maxiter': 400, 'ftol': 1e-8}\n    )\n\n    refined_centers = res_joint.x[:2 * n].reshape((n, 2))\n    refined_radii = res_joint.x[2 * n:]\n    refined_sum = np.sum(refined_radii)\n\n    if refined_sum > best_sum:\n        return refined_centers, refined_radii\n    else:\n        return best_centers, best_radii\n\n\ndef calculate_penalty(centers, radii):\n    \"\"\"\n    Calculate penalty for overlapping circles or circles outside the unit square.\n    Used for optimization.\n    \"\"\"\n    n = len(centers)\n    penalty = 0.0\n    \n    # Penalty for overlapping circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                penalty += overlap**2 * 150  # Increased penalty weight\n    \n    # Penalty for circles outside the unit square\n    for i in range(n):\n        # Left boundary\n        if centers[i, 0] - radii[i] < 0:\n            penalty += (radii[i] - centers[i, 0])**2 * 150\n        \n        # Right boundary\n        if centers[i, 0] + radii[i] > 1:\n            penalty += (centers[i, 0] + radii[i] - 1)**2 * 150\n        \n        # Bottom boundary\n        if centers[i, 1] - radii[i] < 0:\n            penalty += (radii[i] - centers[i, 1])**2 * 150\n        \n        # Top boundary\n        if centers[i, 1] + radii[i] > 1:\n            penalty += (centers[i, 1] + radii[i] - 1)**2 * 150\n    \n    return penalty\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect('equal')\n\n    # Draw circles\n    for i in range(len(centers)):\n        circle = Circle(centers[i], radii[i], edgecolor='black', facecolor='skyblue', alpha=0.7)\n        ax.add_patch(circle)\n\n    # Show plot\n    plt.title('Circle Packing in Unit Square (n=26)')\n    plt.show()\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "54126da2-1bf6-41b0-82b5-9e88e0a7ff11", "generation": 12, "timestamp": 1750811354.7837567, "iteration_found": 0, "metrics": {"validity": 1.0, "sum_radii": 2.6359670315249586, "target_ratio": 1.0003669948861325, "combined_score": 1.0003669948861325, "eval_time": 26.916716814041138}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.6359670305077567, "target_ratio": 1.0003669945000975, "combined_score": 1.0003669945000975, "eval_time": 19.973353624343872}, "island": 1, "migrant": true}, "artifacts_json": null, "artifact_dir": null}