{"id": "c77d1f99-3c0e-499c-86aa-2b45b5243fbe", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using specialized patterns and multi-stage optimization to maximize the sum of radii toward the target of 2.645. This version introduces a gradient-based radius adjustment and refines the penalty function to better guide the optimization.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Multiple initialization patterns based on mathematical research\n    patterns = [\n        initialize_optimal_pattern,\n        initialize_variable_pattern,\n        initialize_edge_optimized_pattern,\n        initialize_hexagonal_pattern,\n        initialize_hybrid_pattern\n    ]\n    \n    start_time = time.time()\n    max_time = 180  # Maximum time in seconds\n\n    for pattern_index, pattern_func in enumerate(patterns):\n        if time.time() - start_time > max_time * 0.95:  # 95% time safety margin\n            break\n            \n        # Initialize with pattern\n        centers, radii = pattern_func(n)\n        \n        # Optimization strategies with different parameters\n        strategies = [\n            # (penalty_factor, max_iterations, ftol, gtol)\n            (1000, 200, 1e-7, 1e-7),\n            (2000, 300, 1e-8, 1e-8),\n            (500, 250, 1e-7, 1e-7)\n        ]\n        \n        for strategy_index, (penalty_factor, max_iters, ftol, gtol) in enumerate(strategies):\n            if time.time() - start_time > max_time * 0.95:\n                break\n                \n            try:\n                # Create a copy to avoid modifying the original\n                centers_copy = centers.copy()\n                radii_copy = radii.copy()\n                \n                # First stage: Coarse optimization with higher tolerance\n                centers_opt, radii_opt = optimize_pattern(\n                    centers_copy, radii_copy, \n                    penalty_factor=penalty_factor,\n                    max_iterations=max_iters,\n                    ftol=ftol*10,\n                    gtol=gtol*10\n                )\n                \n                # Second stage: Refined optimization with stricter tolerance\n                centers_opt, radii_opt = optimize_pattern(\n                    centers_opt, radii_opt,\n                    penalty_factor=penalty_factor*2,\n                    max_iterations=max_iters,\n                    ftol=ftol,\n                    gtol=gtol\n                )\n                \n                # Apply perturbation to escape local optima\n                if pattern_index < 3 and strategy_index < 2:  # Only for promising configurations\n                    centers_opt, radii_opt = apply_perturbation(centers_opt, radii_opt)\n                    \n                    # Third stage: Final refinement after perturbation\n                    centers_opt, radii_opt = optimize_pattern(\n                        centers_opt, radii_opt,\n                        penalty_factor=penalty_factor*4,\n                        max_iterations=max_iters//2,\n                        ftol=ftol/10,\n                        gtol=gtol/10\n                    )\n                \n                # Post-processing to ensure validity and maximize radii\n                centers_opt, radii_opt = post_process(centers_opt, radii_opt)\n                \n                sum_radii = np.sum(radii_opt)\n                if sum_radii > best_sum and is_valid_packing(centers_opt, radii_opt):\n                    best_sum = sum_radii\n                    best_centers = centers_opt.copy()\n                    best_radii = radii_opt.copy()\n            except Exception as e:\n                logging.error(f\"Optimization failed: {e}\")\n                continue\n\n    # If we found a valid solution\n    if best_centers is not None:\n        return best_centers, best_radii, best_sum\n    \n    # Fallback to a simple pattern if all optimizations failed\n    centers, radii = initialize_hexagonal_pattern(n)\n    centers, radii = post_process(centers, radii)\n    return centers, radii, np.sum(radii)\n\n\ndef initialize_optimal_pattern(n):\n    \"\"\"\n    Initialize with a pattern optimized for n=26 based on mathematical research.\n    Uses variable-sized circles with strategic placement.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.14\n    \n    # Corner circles - slightly larger\n    corner_r = 0.13\n    centers[1] = [0.13, 0.13]\n    centers[2] = [0.87, 0.13]\n    centers[3] = [0.13, 0.87]\n    centers[4] = [0.87, 0.87]\n    radii[1:5] = corner_r\n    \n    # Edge circles\n    edge_r = 0.115\n    centers[5] = [0.5, 0.115]\n    centers[6] = [0.5, 0.885]\n    centers[7] = [0.115, 0.5]\n    centers[8] = [0.885, 0.5]\n    radii[5:9] = edge_r\n    \n    # Inner ring (8 circles)\n    inner_r = 0.095\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + inner_r + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_r\n    \n    # Outer circles to fill gaps\n    outer_r = 0.08\n    \n    # Strategic positions based on known gap patterns\n    centers[17] = [0.25, 0.25]\n    centers[18] = [0.75, 0.25]\n    centers[19] = [0.25, 0.75]\n    centers[20] = [0.75, 0.75]\n    \n    centers[21] = [0.33, 0.67]\n    centers[22] = [0.67, 0.33]\n    centers[23] = [0.33, 0.33]\n    centers[24] = [0.67, 0.67]\n    \n    # Two smaller circles in remaining gaps\n    centers[25] = [0.2, 0.5]\n    \n    radii[17:25] = outer_r\n    radii[25] = 0.07\n    \n    return centers, radii\n\n\ndef initialize_variable_pattern(n):\n    \"\"\"\n    Initialize with a pattern that uses highly variable circle sizes\n    to maximize packing efficiency.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Large center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.15\n    \n    # Medium corner circles\n    corner_r = 0.125\n    centers[1] = [corner_r, corner_r]\n    centers[2] = [1-corner_r, corner_r]\n    centers[3] = [corner_r, 1-corner_r]\n    centers[4] = [1-corner_r, 1-corner_r]\n    radii[1:5] = corner_r\n    \n    # Medium edge circles\n    edge_r = 0.11\n    centers[5] = [0.5, edge_r]\n    centers[6] = [0.5, 1-edge_r]\n    centers[7] = [edge_r, 0.5]\n    centers[8] = [1-edge_r, 0.5]\n    radii[5:9] = edge_r\n    \n    # First ring (8 smaller circles)\n    ring1_r = 0.09\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_r + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = ring1_r\n    \n    # Remaining circles with variable sizes\n    sizes = [0.08, 0.075, 0.07, 0.065, 0.06, 0.055, 0.05, 0.045, 0.04]\n    positions = [\n        [0.28, 0.28], [0.72, 0.28], [0.28, 0.72], [0.72, 0.72],\n        [0.35, 0.65], [0.65, 0.35], [0.35, 0.35], [0.65, 0.65], [0.2, 0.5]\n    ]\n    \n    for i in range(min(len(sizes), n-17)):\n        centers[17+i] = positions[i]\n        radii[17+i] = sizes[i]\n    \n    return centers, radii\n\n\ndef initialize_edge_optimized_pattern(n):\n    \"\"\"\n    Initialize with a pattern that optimizes edge utilization.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center and near-center circles\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.13\n    \n    # Corner circles\n    corner_r = 0.12\n    centers[1] = [corner_r, corner_r]\n    centers[2] = [1-corner_r, corner_r]\n    centers[3] = [corner_r, 1-corner_r]\n    centers[4] = [1-corner_r, 1-corner_r]\n    radii[1:5] = corner_r\n    \n    # Edge circles - more of them with smaller radii\n    edge_r = 0.1\n    edge_positions = [\n        [0.3, edge_r], [0.5, edge_r], [0.7, edge_r],\n        [0.3, 1-edge_r], [0.5, 1-edge_r], [0.7, 1-edge_r],\n        [edge_r, 0.3], [edge_r, 0.5], [edge_r, 0.7],\n        [1-edge_r, 0.3], [1-edge_r, 0.5], [1-edge_r, 0.7]\n    ]\n    \n    for i, pos in enumerate(edge_positions[:12]):\n        centers[5+i] = pos\n        radii[5+i] = edge_r\n    \n    # Inner ring circles\n    inner_r = 0.09\n    for i in range(5):\n        angle = 2 * np.pi * i / 5\n        dist = radii[0] + inner_r + 0.001\n        centers[17+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17+i] = inner_r\n    \n    # Remaining circles\n    small_r = 0.07\n    centers[22] = [0.25, 0.25]\n    centers[23] = [0.75, 0.25]\n    centers[24] = [0.25, 0.75]\n    centers[25] = [0.75, 0.75]\n    radii[22:26] = small_r\n    \n    return centers, radii\n\n\ndef initialize_hexagonal_pattern(n):\n    \"\"\"\n    Initialize with a hexagonal pattern which is known to be efficient for circle packing.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Base radius - will be optimized later\n    r = 0.09\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.12\n    \n    # First hexagonal ring (6 circles)\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + r + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = r\n    \n    # Second ring (12 circles)\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*r + r + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = r\n    \n    # Corner circles (4 circles)\n    corner_r = 0.11\n    centers[19] = [corner_r, corner_r]\n    centers[20] = [1-corner_r, corner_r]\n    centers[21] = [corner_r, 1-corner_r]\n    centers[22] = [1-corner_r, 1-corner_r]\n    radii[19:23] = corner_r\n    \n    # Edge circles (3 circles)\n    edge_r = 0.095\n    centers[23] = [0.5, edge_r]\n    centers[24] = [edge_r, 0.5]\n    centers[25] = [1-edge_r, 0.5]\n    radii[23:26] = edge_r\n    \n    return centers, radii\n\n\ndef initialize_hybrid_pattern(n):\n    \"\"\"\n    Initialize with a hybrid pattern that combines corner optimization with inner rings.\n    This pattern is inspired by the best known arrangements for n=26.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Corner circles (4 larger circles)\n    corner_r = 0.12\n    centers[0] = [corner_r, corner_r]\n    centers[1] = [1-corner_r, corner_r]\n    centers[2] = [corner_r, 1-corner_r]\n    centers[3] = [1-corner_r, 1-corner_r]\n    radii[0:4] = corner_r\n    \n    # Edge circles (4 medium circles)\n    edge_r = 0.105\n    centers[4] = [0.5, edge_r]\n    centers[5] = [0.5, 1-edge_r]\n    centers[6] = [edge_r, 0.5]\n    centers[7] = [1-edge_r, 0.5]\n    radii[4:8] = edge_r\n    \n    # Center circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.13\n    \n    # Inner ring (8 circles)\n    inner_r = 0.1\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_r + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_r\n    \n    # Additional circles in between\n    mid_r = 0.08\n    centers[17] = [0.25, 0.25]\n    centers[18] = [0.75, 0.25]\n    centers[19] = [0.25, 0.75]\n    centers[20] = [0.75, 0.75]\n    \n    centers[21] = [0.25, 0.5]\n    centers[22] = [0.75, 0.5]\n    centers[23] = [0.5, 0.25]\n    centers[24] = [0.5, 0.75]\n    \n    # One more in a strategic position\n    centers[25] = [0.35, 0.35]\n    \n    radii[17:26] = mid_r\n    \n    return centers, radii\n\n\ndef optimize_pattern(centers, radii, penalty_factor=1000, max_iterations=300, ftol=1e-7, gtol=1e-7):\n    \"\"\"\n    Optimize circle positions and radii to maximize the sum of radii.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        penalty_factor: Weight for constraint penalties\n        max_iterations: Maximum optimization iterations\n        ftol: Function tolerance for convergence\n        gtol: Gradient tolerance for convergence\n        \n    Returns:\n        Optimized centers and radii\n    \"\"\"\n    n = len(centers)\n    \n    # Define bounds for optimization\n    bounds = []\n    for i in range(n):\n        # x-coordinate bounds\n        bounds.append((0.0, 1.0))\n        # y-coordinate bounds\n        bounds.append((0.0, 1.0))\n    \n    # Radius bounds - allow a wide range but prevent tiny circles\n    for i in range(n):\n        # Different bounds for different circle types\n        if i < 5:  # Corner/center circles can be larger\n            bounds.append((0.04, 0.16))\n        elif i < 9:  # Edge circles\n            bounds.append((0.04, 0.14))\n        else:  # Inner and remaining circles\n            bounds.append((0.03, 0.12))\n    \n    # Flatten the initial guess\n    initial_guess = np.concatenate([centers.flatten(), radii])\n    \n    # Define the objective function (negative sum of radii + penalty)\n    def objective(x):\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        # Calculate the sum of radii (to be maximized)\n        sum_r = np.sum(r)\n        \n        # Calculate penalties\n        penalty = 0.0\n        \n        # Penalty for circles outside the unit square - softened penalty\n        for i in range(n):\n            penalty += boundary_penalty(c[i, 0], r[i])\n            penalty += boundary_penalty(c[i, 1], r[i])\n        \n        # Penalty for overlapping circles - using a more efficient computation\n        for i in range(n):\n            for j in range(i+1, n):\n                # Squared distance is faster than sqrt\n                dist_squared = (c[i,0]-c[j,0])**2 + (c[i,1]-c[j,1])**2\n                sum_radii = r[i] + r[j]\n                \n                # Only compute sqrt if potentially overlapping\n                if dist_squared < sum_radii**2:\n                    dist = np.sqrt(dist_squared)\n                    overlap = sum_radii - dist\n                    if overlap > 0:\n                        # Quadratic penalty with higher weight for larger overlaps\n                        penalty += overlap**2 * (1 + overlap * 5)  # Non-linear overlap penalty\n        \n        # Return negative sum (for minimization) plus penalty\n        return -sum_r + penalty_factor * penalty\n    \n    # Gradient-based radius adjustment\n    def adjust_radii(x):\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        # Calculate radius adjustment based on boundary proximity\n        for i in range(n):\n            # Boundary gradient\n            grad_x_low = max(0, -(c[i, 0] - r[i]))\n            grad_x_high = max(0, (c[i, 0] + r[i] - 1))\n            grad_y_low = max(0, -(c[i, 1] - r[i]))\n            grad_y_high = max(0, (c[i, 1] + r[i] - 1))\n            \n            # Adjust radius based on boundary gradients\n            r[i] -= 0.0001 * (grad_x_low + grad_x_high + grad_y_low + grad_y_high)\n            \n            # Ensure radii stay within bounds\n            r[i] = max(bounds[2*n+i][0], min(r[i], bounds[2*n+i][1]))\n        \n        return np.concatenate([c.flatten(), r])\n        \n    # Callback function to adjust radii during optimization\n    def callback(xk):\n        nonlocal initial_guess\n        initial_guess = adjust_radii(xk)\n    \n    # Run the optimization\n    result = minimize(\n        objective, \n        initial_guess, \n        method='L-BFGS-B',\n        bounds=bounds,\n        options={\n            'maxiter': max_iterations,\n            'ftol': ftol,\n            'gtol': gtol,\n            'disp': False\n        },\n        callback=callback\n    )\n    \n    # Extract the results\n    optimized = result.x\n    centers_opt = optimized[:2*n].reshape(n, 2)\n    radii_opt = optimized[2*n:]\n    \n    return centers_opt, radii_opt\n\n\ndef boundary_penalty(coord, radius):\n    \"\"\"Calculates the penalty for a circle being outside the unit square.\"\"\"\n    penalty = 0.0\n    if coord - radius < 0:\n        penalty += (coord - radius)**2 * 2\n    if coord + radius > 1:\n        penalty += (coord + radius - 1)**2 * 2\n    return penalty\n\n\ndef apply_perturbation(centers, radii):\n    \"\"\"\n    Apply small random perturbations to escape local optima\n    \"\"\"\n    n = len(centers)\n    centers_perturbed = centers.copy()\n    radii_perturbed = radii.copy()\n    \n    # Identify circles that might be in suboptimal positions\n    # (typically smaller circles or those in crowded areas)\n    for i in range(n):\n        # Apply stronger perturbation to smaller circles\n        if radii[i] < np.median(radii):\n            # Position perturbation\n            centers_perturbed[i,0] += np.random.uniform(-0.03, 0.03)\n            centers_perturbed[i,1] += np.random.uniform(-0.03, 0.03)\n            \n            # Radius perturbation (smaller)\n            radii_perturbed[i] *= np.random.uniform(0.95, 1.05)\n    \n    # Ensure circles stay in bounds after perturbation\n    for i in range(n):\n        centers_perturbed[i,0] = np.clip(centers_perturbed[i,0], radii_perturbed[i], 1-radii_perturbed[i])\n        centers_perturbed[i,1] = np.clip(centers_perturbed[i,1], radii_perturbed[i], 1-radii_perturbed[i])\n    \n    return centers_perturbed, radii_perturbed\n\n\ndef is_valid_packing(centers, radii):\n    \"\"\"\n    Check if the packing is valid (no overlaps, all circles within bounds)\n    \"\"\"\n    n = len(centers)\n    \n    # Check if all circles are within bounds\n    for i in range(n):\n        if (centers[i,0] - radii[i] < -1e-10 or centers[i,0] + radii[i] > 1+1e-10 or\n            centers[i,1] - radii[i] < -1e-10 or centers[i,1] + radii[i] > 1+1e-10):\n            return False\n    \n    # Check for overlaps\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.sqrt((centers[i,0]-centers[j,0])**2 + (centers[i,1]-centers[j,1])**2)\n            if dist < radii[i] + radii[j] - 1e-10:  # Small tolerance\n                return False\n    \n    return True\n\n\ndef post_process(centers, radii):\n    \"\"\"\n    Post-process the optimization results to ensure validity and maximize radii.\n    \n    This function:\n    1. Ensures all circles are within bounds\n    2. Resolves any remaining overlaps\n    3. Tries to expand circles where possible\n    \"\"\"\n    n = len(centers)\n    \n    # Ensure circles are within bounds\n    for i in range(n):\n        # Left boundary\n        if centers[i,0] - radii[i] < 0:\n            centers[i,0] = radii[i]\n        # Right boundary\n        if centers[i,0] + radii[i] > 1:\n            centers[i,0] = 1 - radii[i]\n        # Bottom boundary\n        if centers[i,1] - radii[i] < 0:\n            centers[i,1] = radii[i]\n        # Top boundary\n        if centers[i,1] + radii[i] > 1:\n            centers[i,1] = 1 - radii[i]\n    \n    # Resolve overlaps (iteratively shrink overlapping circles)\n    max_iterations = 20\n    for _ in range(max_iterations):\n        overlap_found = False\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i,0]-centers[j,0])**2 + (centers[i,1]-centers[j,1])**2)\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 1e-10:  # Small tolerance\n                    overlap_found = True\n                    # Shrink both circles proportionally\n                    shrink_i = overlap * radii[i] / (radii[i] + radii[j])\n                    shrink_j = overlap * radii[j] / (radii[i] + radii[j])\n                    radii[i] -= shrink_i * 0.6  # Slightly more to ensure resolution\n                    radii[j] -= shrink_j * 0.6\n        \n        if not overlap_found:\n            break\n    \n    # Try to expand circles where possible - using a more efficient approach\n    # First identify how much each circle can expand\n    max_expansion = np.ones(n) * float('inf')\n    \n    # Boundary constraints\n    for i in range(n):\n        max_expansion[i] = min(max_expansion[i], centers[i,0] / radii[i] - 1)\n        max_expansion[i] = min(max_expansion[i], centers[i,1] / radii[i] - 1)\n        max_expansion[i] = min(max_expansion[i], (1 - centers[i,0]) / radii[i] - 1)\n        max_expansion[i] = min(max_expansion[i], (1 - centers[i,1]) / radii[i] - 1)\n    \n    # Circle-circle constraints\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.sqrt((centers[i,0]-centers[j,0])**2 + (centers[i,1]-centers[j,1])**2)\n                max_exp_ij = (dist / (radii[i] + radii[j])) - 1\n                max_expansion[i] = min(max_expansion[i], max_exp_ij)\n    \n    # Apply expansions (with a safety factor)\n    safety_factor = 0.99\n    for i in range(n):\n        if max_expansion[i] > 0:\n            expansion = min(max_expansion[i], 0.05)  # Limit maximum expansion\n            radii[i] *= (1 + expansion * safety_factor)\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.savefig(\"circle_packing.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "2847d927-30ac-4e20-97d6-1434c86c3ecf", "generation": 10, "timestamp": 1750953587.8279464, "iteration_found": 191, "metrics": {"validity": 1.0, "sum_radii": 2.586737547533574, "target_ratio": 0.9816840787603697, "combined_score": 0.9816840787603697, "eval_time": 164.8533170223236}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.6095704378764197, "target_ratio": 0.9903493122870664, "combined_score": 0.9903493122870664, "eval_time": 181.5327548980713}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.645 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.636, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - validity: 1.0000\n- sum_radii: 2.6096\n- target_ratio: 0.9903\n- combined_score: 0.9903\n- eval_time: 181.5328\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: sum_radii, target_ratio, combined_score. Consider continuing with similar changes.\n- Metrics showing regression: eval_time. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.5846, target_ratio: 0.9809, combined_score: 0.9809, eval_time: 183.1378\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.5701, target_ratio: 0.9754, combined_score: 0.9754, eval_time: 184.1761\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6093, target_ratio: 0.9902, combined_score: 0.9902, eval_time: 190.7207\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 9.7633)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n\n# Configure logging (optional, but helpful for debugging)\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6360), Performs well on target_ratio (1.0004), Performs well on combined_score (1.0004), Performs well on eval_time (43.1799)\n\n\n### Program 2 (Score: 39.2621)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using mathematical insights and specialized optimization techniques to maximize the sum of radii toward the target of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6093), Performs well on target_ratio (0.9902), Performs well on combined_score (0.9902), Performs well on eval_time (190.7207)\n\n\n### Program 3 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square, implementing specialized geometric patterns and multi-stage optimization techniques to maximize the sum of radii. This implementation uses hybrid patterns with variable-sized circles, targeted perturbation strategies, and adaptive penalty functions to escape local optima. This version focuses on improved penalty functions, smarter initialization, and adaptive optimization parameters.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef construct_packing():\n# ... (truncated for brevity)\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n\n### Program 4 (Score: 1.7266)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This implementation prioritizes speed and convergence by focusing on a simplified physics-based approach and a targeted mathematical refinement stage. It leverages optimized initial patterns and a robust overlap resolution strategy to maximize the sum of radii.\"\"\"\nimport numpy as np\nimport time\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef construct_packing():\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.3439), Performs well on target_ratio (0.8895), Performs well on combined_score (0.8895), Performs well on eval_time (3.5100)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 27.6355)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques. This version incorporates a more robust penalty function, adaptive radius adjustments during optimization, and a refined initial pattern selection strategy.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport logging\n# ... (truncated)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using specialized patterns and multi-stage optimization to maximize the sum of radii toward the target of 2.645.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Multiple initialization patterns based on mathematical research\n    patterns = [\n        initialize_optimal_pattern,\n        initialize_variable_pattern,\n        initialize_edge_optimized_pattern,\n        initialize_hexagonal_pattern,\n        initialize_hybrid_pattern\n    ]\n    \n    start_time = time.time()\n    max_time = 180  # Maximum time in seconds\n\n    for pattern_index, pattern_func in enumerate(patterns):\n        if time.time() - start_time > max_time * 0.95:  # 95% time safety margin\n            break\n            \n        # Initialize with pattern\n        centers, radii = pattern_func(n)\n        \n        # Optimization strategies with different parameters\n        strategies = [\n            # (penalty_factor, max_iterations, ftol, gtol)\n            (1000, 200, 1e-7, 1e-7),\n            (2000, 300, 1e-8, 1e-8),\n            (500, 250, 1e-7, 1e-7)\n        ]\n        \n        for strategy_index, (penalty_factor, max_iters, ftol, gtol) in enumerate(strategies):\n            if time.time() - start_time > max_time * 0.95:\n                break\n                \n            try:\n                # Create a copy to avoid modifying the original\n                centers_copy = centers.copy()\n                radii_copy = radii.copy()\n                \n                # First stage: Coarse optimization with higher tolerance\n                centers_opt, radii_opt = optimize_pattern(\n                    centers_copy, radii_copy, \n                    penalty_factor=penalty_factor,\n                    max_iterations=max_iters,\n                    ftol=ftol*10,\n                    gtol=gtol*10\n                )\n                \n                # Second stage: Refined optimization with stricter tolerance\n                centers_opt, radii_opt = optimize_pattern(\n                    centers_opt, radii_opt,\n                    penalty_factor=penalty_factor*2,\n                    max_iterations=max_iters,\n                    ftol=ftol,\n                    gtol=gtol\n                )\n                \n                # Apply perturbation to escape local optima\n                if pattern_index < 3 and strategy_index < 2:  # Only for promising configurations\n                    centers_opt, radii_opt = apply_perturbation(centers_opt, radii_opt)\n                    \n                    # Third stage: Final refinement after perturbation\n                    centers_opt, radii_opt = optimize_pattern(\n                        centers_opt, radii_opt,\n                        penalty_factor=penalty_factor*4,\n                        max_iterations=max_iters//2,\n                        ftol=ftol/10,\n                        gtol=gtol/10\n                    )\n                \n                # Post-processing to ensure validity and maximize radii\n                centers_opt, radii_opt = post_process(centers_opt, radii_opt)\n                \n                sum_radii = np.sum(radii_opt)\n                if sum_radii > best_sum and is_valid_packing(centers_opt, radii_opt):\n                    best_sum = sum_radii\n                    best_centers = centers_opt.copy()\n                    best_radii = radii_opt.copy()\n            except Exception as e:\n                continue\n\n    # If we found a valid solution\n    if best_centers is not None:\n        return best_centers, best_radii, best_sum\n    \n    # Fallback to a simple pattern if all optimizations failed\n    centers, radii = initialize_hexagonal_pattern(n)\n    centers, radii = post_process(centers, radii)\n    return centers, radii, np.sum(radii)\n\n\ndef initialize_optimal_pattern(n):\n    \"\"\"\n    Initialize with a pattern optimized for n=26 based on mathematical research.\n    Uses variable-sized circles with strategic placement.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.14\n    \n    # Corner circles - slightly larger\n    corner_r = 0.13\n    centers[1] = [corner_r, corner_r]\n    centers[2] = [1-corner_r, corner_r]\n    centers[3] = [corner_r, 1-corner_r]\n    centers[4] = [1-corner_r, 1-corner_r]\n    radii[1:5] = corner_r\n    \n    # Edge circles\n    edge_r = 0.115\n    centers[5] = [0.5, edge_r]\n    centers[6] = [0.5, 1-edge_r]\n    centers[7] = [edge_r, 0.5]\n    centers[8] = [1-edge_r, 0.5]\n    radii[5:9] = edge_r\n    \n    # Inner ring (8 circles)\n    inner_r = 0.095\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + inner_r + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_r\n    \n    # Outer circles to fill gaps\n    outer_r = 0.08\n    \n    # Strategic positions based on known gap patterns\n    centers[17] = [0.25, 0.25]\n    centers[18] = [0.75, 0.25]\n    centers[19] = [0.25, 0.75]\n    centers[20] = [0.75, 0.75]\n    \n    centers[21] = [0.33, 0.67]\n    centers[22] = [0.67, 0.33]\n    centers[23] = [0.33, 0.33]\n    centers[24] = [0.67, 0.67]\n    \n    # Two smaller circles in remaining gaps\n    centers[25] = [0.2, 0.5]\n    \n    radii[17:25] = outer_r\n    radii[25] = 0.07\n    \n    return centers, radii\n\n\ndef initialize_variable_pattern(n):\n    \"\"\"\n    Initialize with a pattern that uses highly variable circle sizes\n    to maximize packing efficiency.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Large center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.15\n    \n    # Medium corner circles\n    corner_r = 0.125\n    centers[1] = [corner_r, corner_r]\n    centers[2] = [1-corner_r, corner_r]\n    centers[3] = [corner_r, 1-corner_r]\n    centers[4] = [1-corner_r, 1-corner_r]\n    radii[1:5] = corner_r\n    \n    # Medium edge circles\n    edge_r = 0.11\n    centers[5] = [0.5, edge_r]\n    centers[6] = [0.5, 1-edge_r]\n    centers[7] = [edge_r, 0.5]\n    centers[8] = [1-edge_r, 0.5]\n    radii[5:9] = edge_r\n    \n    # First ring (8 smaller circles)\n    ring1_r = 0.09\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_r + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = ring1_r\n    \n    # Remaining circles with variable sizes\n    sizes = [0.08, 0.075, 0.07, 0.065, 0.06, 0.055, 0.05, 0.045, 0.04]\n    positions = [\n        [0.28, 0.28], [0.72, 0.28], [0.28, 0.72], [0.72, 0.72],\n        [0.35, 0.65], [0.65, 0.35], [0.35, 0.35], [0.65, 0.65], [0.2, 0.5]\n    ]\n    \n    for i in range(min(len(sizes), n-17)):\n        centers[17+i] = positions[i]\n        radii[17+i] = sizes[i]\n    \n    return centers, radii\n\n\ndef initialize_edge_optimized_pattern(n):\n    \"\"\"\n    Initialize with a pattern that optimizes edge utilization.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center and near-center circles\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.13\n    \n    # Corner circles\n    corner_r = 0.12\n    centers[1] = [corner_r, corner_r]\n    centers[2] = [1-corner_r, corner_r]\n    centers[3] = [corner_r, 1-corner_r]\n    centers[4] = [1-corner_r, 1-corner_r]\n    radii[1:5] = corner_r\n    \n    # Edge circles - more of them with smaller radii\n    edge_r = 0.1\n    edge_positions = [\n        [0.3, edge_r], [0.5, edge_r], [0.7, edge_r],\n        [0.3, 1-edge_r], [0.5, 1-edge_r], [0.7, 1-edge_r],\n        [edge_r, 0.3], [edge_r, 0.5], [edge_r, 0.7],\n        [1-edge_r, 0.3], [1-edge_r, 0.5], [1-edge_r, 0.7]\n    ]\n    \n    for i, pos in enumerate(edge_positions[:12]):\n        centers[5+i] = pos\n        radii[5+i] = edge_r\n    \n    # Inner ring circles\n    inner_r = 0.09\n    for i in range(5):\n        angle = 2 * np.pi * i / 5\n        dist = radii[0] + inner_r + 0.001\n        centers[17+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17+i] = inner_r\n    \n    # Remaining circles\n    small_r = 0.07\n    centers[22] = [0.25, 0.25]\n    centers[23] = [0.75, 0.25]\n    centers[24] = [0.25, 0.75]\n    centers[25] = [0.75, 0.75]\n    radii[22:26] = small_r\n    \n    return centers, radii\n\n\ndef initialize_hexagonal_pattern(n):\n    \"\"\"\n    Initialize with a hexagonal pattern which is known to be efficient for circle packing.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Base radius - will be optimized later\n    r = 0.09\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.12\n    \n    # First hexagonal ring (6 circles)\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + r + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = r\n    \n    # Second ring (12 circles)\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*r + r + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = r\n    \n    # Corner circles (4 circles)\n    corner_r = 0.11\n    centers[19] = [corner_r, corner_r]\n    centers[20] = [1-corner_r, corner_r]\n    centers[21] = [corner_r, 1-corner_r]\n    centers[22] = [1-corner_r, 1-corner_r]\n    radii[19:23] = corner_r\n    \n    # Edge circles (3 circles)\n    edge_r = 0.095\n    centers[23] = [0.5, edge_r]\n    centers[24] = [edge_r, 0.5]\n    centers[25] = [1-edge_r, 0.5]\n    radii[23:26] = edge_r\n    \n    return centers, radii\n\n\ndef initialize_hybrid_pattern(n):\n    \"\"\"\n    Initialize with a hybrid pattern that combines corner optimization with inner rings.\n    This pattern is inspired by the best known arrangements for n=26.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Corner circles (4 larger circles)\n    corner_r = 0.12\n    centers[0] = [corner_r, corner_r]\n    centers[1] = [1-corner_r, corner_r]\n    centers[2] = [corner_r, 1-corner_r]\n    centers[3] = [1-corner_r, 1-corner_r]\n    radii[0:4] = corner_r\n    \n    # Edge circles (4 medium circles)\n    edge_r = 0.105\n    centers[4] = [0.5, edge_r]\n    centers[5] = [0.5, 1-edge_r]\n    centers[6] = [edge_r, 0.5]\n    centers[7] = [1-edge_r, 0.5]\n    radii[4:8] = edge_r\n    \n    # Center circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.13\n    \n    # Inner ring (8 circles)\n    inner_r = 0.1\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_r + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_r\n    \n    # Additional circles in between\n    mid_r = 0.08\n    centers[17] = [0.25, 0.25]\n    centers[18] = [0.75, 0.25]\n    centers[19] = [0.25, 0.75]\n    centers[20] = [0.75, 0.75]\n    \n    centers[21] = [0.25, 0.5]\n    centers[22] = [0.75, 0.5]\n    centers[23] = [0.5, 0.25]\n    centers[24] = [0.5, 0.75]\n    \n    # One more in a strategic position\n    centers[25] = [0.35, 0.35]\n    \n    radii[17:26] = mid_r\n    \n    return centers, radii\n\n\ndef optimize_pattern(centers, radii, penalty_factor=1000, max_iterations=300, ftol=1e-7, gtol=1e-7):\n    \"\"\"\n    Optimize circle positions and radii to maximize the sum of radii.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        penalty_factor: Weight for constraint penalties\n        max_iterations: Maximum optimization iterations\n        ftol: Function tolerance for convergence\n        gtol: Gradient tolerance for convergence\n        \n    Returns:\n        Optimized centers and radii\n    \"\"\"\n    n = len(centers)\n    \n    # Define bounds for optimization\n    bounds = []\n    for i in range(n):\n        # x-coordinate bounds\n        bounds.append((0.0, 1.0))\n        # y-coordinate bounds\n        bounds.append((0.0, 1.0))\n    \n    # Radius bounds - allow a wide range but prevent tiny circles\n    for i in range(n):\n        # Different bounds for different circle types\n        if i < 5:  # Corner/center circles can be larger\n            bounds.append((0.04, 0.16))\n        elif i < 9:  # Edge circles\n            bounds.append((0.04, 0.14))\n        else:  # Inner and remaining circles\n            bounds.append((0.03, 0.12))\n    \n    # Flatten the initial guess\n    initial_guess = np.concatenate([centers.flatten(), radii])\n    \n    # Define the objective function (negative sum of radii + penalty)\n    def objective(x):\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        # Calculate the sum of radii (to be maximized)\n        sum_r = np.sum(r)\n        \n        # Calculate penalties\n        penalty = 0.0\n        \n        # Penalty for circles outside the unit square\n        for i in range(n):\n            if c[i,0] - r[i] < 0:\n                penalty += (c[i,0] - r[i])**2 * 2\n            if c[i,0] + r[i] > 1:\n                penalty += (c[i,0] + r[i] - 1)**2 * 2\n            if c[i,1] - r[i] < 0:\n                penalty += (c[i,1] - r[i])**2 * 2\n            if c[i,1] + r[i] > 1:\n                penalty += (c[i,1] + r[i] - 1)**2 * 2\n        \n        # Penalty for overlapping circles - using a more efficient computation\n        for i in range(n):\n            for j in range(i+1, n):\n                # Squared distance is faster than sqrt\n                dist_squared = (c[i,0]-c[j,0])**2 + (c[i,1]-c[j,1])**2\n                sum_radii = r[i] + r[j]\n                \n                # Only compute sqrt if potentially overlapping\n                if dist_squared < sum_radii**2:\n                    dist = np.sqrt(dist_squared)\n                    overlap = sum_radii - dist\n                    if overlap > 0:\n                        # Quadratic penalty with higher weight for larger overlaps\n                        penalty += overlap**2 * 1.5\n        \n        # Return negative sum (for minimization) plus penalty\n        return -sum_r + penalty_factor * penalty\n    \n    # Run the optimization\n    result = minimize(\n        objective, \n        initial_guess, \n        method='L-BFGS-B',\n        bounds=bounds,\n        options={\n            'maxiter': max_iterations,\n            'ftol': ftol,\n            'gtol': gtol,\n            'disp': False\n        }\n    )\n    \n    # Extract the results\n    optimized = result.x\n    centers_opt = optimized[:2*n].reshape(n, 2)\n    radii_opt = optimized[2*n:]\n    \n    return centers_opt, radii_opt\n\n\ndef apply_perturbation(centers, radii):\n    \"\"\"\n    Apply small random perturbations to escape local optima\n    \"\"\"\n    n = len(centers)\n    centers_perturbed = centers.copy()\n    radii_perturbed = radii.copy()\n    \n    # Identify circles that might be in suboptimal positions\n    # (typically smaller circles or those in crowded areas)\n    for i in range(n):\n        # Apply stronger perturbation to smaller circles\n        if radii[i] < np.median(radii):\n            # Position perturbation\n            centers_perturbed[i,0] += np.random.uniform(-0.03, 0.03)\n            centers_perturbed[i,1] += np.random.uniform(-0.03, 0.03)\n            \n            # Radius perturbation (smaller)\n            radii_perturbed[i] *= np.random.uniform(0.95, 1.05)\n    \n    # Ensure circles stay in bounds after perturbation\n    for i in range(n):\n        centers_perturbed[i,0] = np.clip(centers_perturbed[i,0], radii_perturbed[i], 1-radii_perturbed[i])\n        centers_perturbed[i,1] = np.clip(centers_perturbed[i,1], radii_perturbed[i], 1-radii_perturbed[i])\n    \n    return centers_perturbed, radii_perturbed\n\n\ndef is_valid_packing(centers, radii):\n    \"\"\"\n    Check if the packing is valid (no overlaps, all circles within bounds)\n    \"\"\"\n    n = len(centers)\n    \n    # Check if all circles are within bounds\n    for i in range(n):\n        if (centers[i,0] - radii[i] < -1e-10 or centers[i,0] + radii[i] > 1+1e-10 or\n            centers[i,1] - radii[i] < -1e-10 or centers[i,1] + radii[i] > 1+1e-10):\n            return False\n    \n    # Check for overlaps\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.sqrt((centers[i,0]-centers[j,0])**2 + (centers[i,1]-centers[j,1])**2)\n            if dist < radii[i] + radii[j] - 1e-10:  # Small tolerance\n                return False\n    \n    return True\n\n\ndef post_process(centers, radii):\n    \"\"\"\n    Post-process the optimization results to ensure validity and maximize radii.\n    \n    This function:\n    1. Ensures all circles are within bounds\n    2. Resolves any remaining overlaps\n    3. Tries to expand circles where possible\n    \"\"\"\n    n = len(centers)\n    \n    # Ensure circles are within bounds\n    for i in range(n):\n        # Left boundary\n        if centers[i,0] - radii[i] < 0:\n            centers[i,0] = radii[i]\n        # Right boundary\n        if centers[i,0] + radii[i] > 1:\n            centers[i,0] = 1 - radii[i]\n        # Bottom boundary\n        if centers[i,1] - radii[i] < 0:\n            centers[i,1] = radii[i]\n        # Top boundary\n        if centers[i,1] + radii[i] > 1:\n            centers[i,1] = 1 - radii[i]\n    \n    # Resolve overlaps (iteratively shrink overlapping circles)\n    max_iterations = 20\n    for _ in range(max_iterations):\n        overlap_found = False\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i,0]-centers[j,0])**2 + (centers[i,1]-centers[j,1])**2)\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 1e-10:  # Small tolerance\n                    overlap_found = True\n                    # Shrink both circles proportionally\n                    shrink_i = overlap * radii[i] / (radii[i] + radii[j])\n                    shrink_j = overlap * radii[j] / (radii[i] + radii[j])\n                    radii[i] -= shrink_i * 0.6  # Slightly more to ensure resolution\n                    radii[j] -= shrink_j * 0.6\n        \n        if not overlap_found:\n            break\n    \n    # Try to expand circles where possible - using a more efficient approach\n    # First identify how much each circle can expand\n    max_expansion = np.ones(n) * float('inf')\n    \n    # Boundary constraints\n    for i in range(n):\n        max_expansion[i] = min(max_expansion[i], centers[i,0] / radii[i] - 1)\n        max_expansion[i] = min(max_expansion[i], centers[i,1] / radii[i] - 1)\n        max_expansion[i] = min(max_expansion[i], (1 - centers[i,0]) / radii[i] - 1)\n        max_expansion[i] = min(max_expansion[i], (1 - centers[i,1]) / radii[i] - 1)\n    \n    # Circle-circle constraints\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.sqrt((centers[i,0]-centers[j,0])**2 + (centers[i,1]-centers[j,1])**2)\n                max_exp_ij = (dist / (radii[i] + radii[j])) - 1\n                max_expansion[i] = min(max_expansion[i], max_exp_ij)\n    \n    # Apply expansions (with a safety factor)\n    safety_factor = 0.99\n    for i in range(n):\n        if max_expansion[i] > 0:\n            expansion = min(max_expansion[i], 0.05)  # Limit maximum expansion\n            radii[i] *= (1 + expansion * safety_factor)\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.savefig(\"circle_packing.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles in a unit square using specialized patterns and multi-stage optimization to maximize the sum of radii toward the target of 2.645. This version introduces a gradient-based radius adjustment and refines the penalty function to better guide the optimization.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    # Multiple initialization patterns based on mathematical research\n    patterns = [\n        initialize_optimal_pattern,\n        initialize_variable_pattern,\n        initialize_edge_optimized_pattern,\n        initialize_hexagonal_pattern,\n        initialize_hybrid_pattern\n    ]\n    \n    start_time = time.time()\n    max_time = 180  # Maximum time in seconds\n\n    for pattern_index, pattern_func in enumerate(patterns):\n        if time.time() - start_time > max_time * 0.95:  # 95% time safety margin\n            break\n            \n        # Initialize with pattern\n        centers, radii = pattern_func(n)\n        \n        # Optimization strategies with different parameters\n        strategies = [\n            # (penalty_factor, max_iterations, ftol, gtol)\n            (1000, 200, 1e-7, 1e-7),\n            (2000, 300, 1e-8, 1e-8),\n            (500, 250, 1e-7, 1e-7)\n        ]\n        \n        for strategy_index, (penalty_factor, max_iters, ftol, gtol) in enumerate(strategies):\n            if time.time() - start_time > max_time * 0.95:\n                break\n                \n            try:\n                # Create a copy to avoid modifying the original\n                centers_copy = centers.copy()\n                radii_copy = radii.copy()\n                \n                # First stage: Coarse optimization with higher tolerance\n                centers_opt, radii_opt = optimize_pattern(\n                    centers_copy, radii_copy, \n                    penalty_factor=penalty_factor,\n                    max_iterations=max_iters,\n                    ftol=ftol*10,\n                    gtol=gtol*10\n                )\n                \n                # Second stage: Refined optimization with stricter tolerance\n                centers_opt, radii_opt = optimize_pattern(\n                    centers_opt, radii_opt,\n                    penalty_factor=penalty_factor*2,\n                    max_iterations=max_iters,\n                    ftol=ftol,\n                    gtol=gtol\n                )\n                \n                # Apply perturbation to escape local optima\n                if pattern_index < 3 and strategy_index < 2:  # Only for promising configurations\n                    centers_opt, radii_opt = apply_perturbation(centers_opt, radii_opt)\n                    \n                    # Third stage: Final refinement after perturbation\n                    centers_opt, radii_opt = optimize_pattern(\n                        centers_opt, radii_opt,\n                        penalty_factor=penalty_factor*4,\n                        max_iterations=max_iters//2,\n                        ftol=ftol/10,\n                        gtol=gtol/10\n                    )\n                \n                # Post-processing to ensure validity and maximize radii\n                centers_opt, radii_opt = post_process(centers_opt, radii_opt)\n                \n                sum_radii = np.sum(radii_opt)\n                if sum_radii > best_sum and is_valid_packing(centers_opt, radii_opt):\n                    best_sum = sum_radii\n                    best_centers = centers_opt.copy()\n                    best_radii = radii_opt.copy()\n            except Exception as e:\n                logging.error(f\"Optimization failed: {e}\")\n                continue\n\n    # If we found a valid solution\n    if best_centers is not None:\n        return best_centers, best_radii, best_sum\n    \n    # Fallback to a simple pattern if all optimizations failed\n    centers, radii = initialize_hexagonal_pattern(n)\n    centers, radii = post_process(centers, radii)\n    return centers, radii, np.sum(radii)\n\n\ndef initialize_optimal_pattern(n):\n    \"\"\"\n    Initialize with a pattern optimized for n=26 based on mathematical research.\n    Uses variable-sized circles with strategic placement.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.14\n    \n    # Corner circles - slightly larger\n    corner_r = 0.13\n    centers[1] = [0.13, 0.13]\n    centers[2] = [0.87, 0.13]\n    centers[3] = [0.13, 0.87]\n    centers[4] = [0.87, 0.87]\n    radii[1:5] = corner_r\n    \n    # Edge circles\n    edge_r = 0.115\n    centers[5] = [0.5, 0.115]\n    centers[6] = [0.5, 0.885]\n    centers[7] = [0.115, 0.5]\n    centers[8] = [0.885, 0.5]\n    radii[5:9] = edge_r\n    \n    # Inner ring (8 circles)\n    inner_r = 0.095\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + inner_r + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_r\n    \n    # Outer circles to fill gaps\n    outer_r = 0.08\n    \n    # Strategic positions based on known gap patterns\n    centers[17] = [0.25, 0.25]\n    centers[18] = [0.75, 0.25]\n    centers[19] = [0.25, 0.75]\n    centers[20] = [0.75, 0.75]\n    \n    centers[21] = [0.33, 0.67]\n    centers[22] = [0.67, 0.33]\n    centers[23] = [0.33, 0.33]\n    centers[24] = [0.67, 0.67]\n    \n    # Two smaller circles in remaining gaps\n    centers[25] = [0.2, 0.5]\n    \n    radii[17:25] = outer_r\n    radii[25] = 0.07\n    \n    return centers, radii\n\n\ndef initialize_variable_pattern(n):\n    \"\"\"\n    Initialize with a pattern that uses highly variable circle sizes\n    to maximize packing efficiency.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Large center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.15\n    \n    # Medium corner circles\n    corner_r = 0.125\n    centers[1] = [corner_r, corner_r]\n    centers[2] = [1-corner_r, corner_r]\n    centers[3] = [corner_r, 1-corner_r]\n    centers[4] = [1-corner_r, 1-corner_r]\n    radii[1:5] = corner_r\n    \n    # Medium edge circles\n    edge_r = 0.11\n    centers[5] = [0.5, edge_r]\n    centers[6] = [0.5, 1-edge_r]\n    centers[7] = [edge_r, 0.5]\n    centers[8] = [1-edge_r, 0.5]\n    radii[5:9] = edge_r\n    \n    # First ring (8 smaller circles)\n    ring1_r = 0.09\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_r + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = ring1_r\n    \n    # Remaining circles with variable sizes\n    sizes = [0.08, 0.075, 0.07, 0.065, 0.06, 0.055, 0.05, 0.045, 0.04]\n    positions = [\n        [0.28, 0.28], [0.72, 0.28], [0.28, 0.72], [0.72, 0.72],\n        [0.35, 0.65], [0.65, 0.35], [0.35, 0.35], [0.65, 0.65], [0.2, 0.5]\n    ]\n    \n    for i in range(min(len(sizes), n-17)):\n        centers[17+i] = positions[i]\n        radii[17+i] = sizes[i]\n    \n    return centers, radii\n\n\ndef initialize_edge_optimized_pattern(n):\n    \"\"\"\n    Initialize with a pattern that optimizes edge utilization.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Center and near-center circles\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.13\n    \n    # Corner circles\n    corner_r = 0.12\n    centers[1] = [corner_r, corner_r]\n    centers[2] = [1-corner_r, corner_r]\n    centers[3] = [corner_r, 1-corner_r]\n    centers[4] = [1-corner_r, 1-corner_r]\n    radii[1:5] = corner_r\n    \n    # Edge circles - more of them with smaller radii\n    edge_r = 0.1\n    edge_positions = [\n        [0.3, edge_r], [0.5, edge_r], [0.7, edge_r],\n        [0.3, 1-edge_r], [0.5, 1-edge_r], [0.7, 1-edge_r],\n        [edge_r, 0.3], [edge_r, 0.5], [edge_r, 0.7],\n        [1-edge_r, 0.3], [1-edge_r, 0.5], [1-edge_r, 0.7]\n    ]\n    \n    for i, pos in enumerate(edge_positions[:12]):\n        centers[5+i] = pos\n        radii[5+i] = edge_r\n    \n    # Inner ring circles\n    inner_r = 0.09\n    for i in range(5):\n        angle = 2 * np.pi * i / 5\n        dist = radii[0] + inner_r + 0.001\n        centers[17+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[17+i] = inner_r\n    \n    # Remaining circles\n    small_r = 0.07\n    centers[22] = [0.25, 0.25]\n    centers[23] = [0.75, 0.25]\n    centers[24] = [0.25, 0.75]\n    centers[25] = [0.75, 0.75]\n    radii[22:26] = small_r\n    \n    return centers, radii\n\n\ndef initialize_hexagonal_pattern(n):\n    \"\"\"\n    Initialize with a hexagonal pattern which is known to be efficient for circle packing.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Base radius - will be optimized later\n    r = 0.09\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.12\n    \n    # First hexagonal ring (6 circles)\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + r + 0.001\n        centers[i+1] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+1] = r\n    \n    # Second ring (12 circles)\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12\n        dist = radii[0] + 2*r + r + 0.002\n        centers[i+7] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[i+7] = r\n    \n    # Corner circles (4 circles)\n    corner_r = 0.11\n    centers[19] = [corner_r, corner_r]\n    centers[20] = [1-corner_r, corner_r]\n    centers[21] = [corner_r, 1-corner_r]\n    centers[22] = [1-corner_r, 1-corner_r]\n    radii[19:23] = corner_r\n    \n    # Edge circles (3 circles)\n    edge_r = 0.095\n    centers[23] = [0.5, edge_r]\n    centers[24] = [edge_r, 0.5]\n    centers[25] = [1-edge_r, 0.5]\n    radii[23:26] = edge_r\n    \n    return centers, radii\n\n\ndef initialize_hybrid_pattern(n):\n    \"\"\"\n    Initialize with a hybrid pattern that combines corner optimization with inner rings.\n    This pattern is inspired by the best known arrangements for n=26.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Corner circles (4 larger circles)\n    corner_r = 0.12\n    centers[0] = [corner_r, corner_r]\n    centers[1] = [1-corner_r, corner_r]\n    centers[2] = [corner_r, 1-corner_r]\n    centers[3] = [1-corner_r, 1-corner_r]\n    radii[0:4] = corner_r\n    \n    # Edge circles (4 medium circles)\n    edge_r = 0.105\n    centers[4] = [0.5, edge_r]\n    centers[5] = [0.5, 1-edge_r]\n    centers[6] = [edge_r, 0.5]\n    centers[7] = [1-edge_r, 0.5]\n    radii[4:8] = edge_r\n    \n    # Center circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.13\n    \n    # Inner ring (8 circles)\n    inner_r = 0.1\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[8] + inner_r + 0.001\n        centers[9+i] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[9+i] = inner_r\n    \n    # Additional circles in between\n    mid_r = 0.08\n    centers[17] = [0.25, 0.25]\n    centers[18] = [0.75, 0.25]\n    centers[19] = [0.25, 0.75]\n    centers[20] = [0.75, 0.75]\n    \n    centers[21] = [0.25, 0.5]\n    centers[22] = [0.75, 0.5]\n    centers[23] = [0.5, 0.25]\n    centers[24] = [0.5, 0.75]\n    \n    # One more in a strategic position\n    centers[25] = [0.35, 0.35]\n    \n    radii[17:26] = mid_r\n    \n    return centers, radii\n\n\ndef optimize_pattern(centers, radii, penalty_factor=1000, max_iterations=300, ftol=1e-7, gtol=1e-7):\n    \"\"\"\n    Optimize circle positions and radii to maximize the sum of radii.\n    \n    Args:\n        centers: Initial circle centers\n        radii: Initial circle radii\n        penalty_factor: Weight for constraint penalties\n        max_iterations: Maximum optimization iterations\n        ftol: Function tolerance for convergence\n        gtol: Gradient tolerance for convergence\n        \n    Returns:\n        Optimized centers and radii\n    \"\"\"\n    n = len(centers)\n    \n    # Define bounds for optimization\n    bounds = []\n    for i in range(n):\n        # x-coordinate bounds\n        bounds.append((0.0, 1.0))\n        # y-coordinate bounds\n        bounds.append((0.0, 1.0))\n    \n    # Radius bounds - allow a wide range but prevent tiny circles\n    for i in range(n):\n        # Different bounds for different circle types\n        if i < 5:  # Corner/center circles can be larger\n            bounds.append((0.04, 0.16))\n        elif i < 9:  # Edge circles\n            bounds.append((0.04, 0.14))\n        else:  # Inner and remaining circles\n            bounds.append((0.03, 0.12))\n    \n    # Flatten the initial guess\n    initial_guess = np.concatenate([centers.flatten(), radii])\n    \n    # Define the objective function (negative sum of radii + penalty)\n    def objective(x):\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        # Calculate the sum of radii (to be maximized)\n        sum_r = np.sum(r)\n        \n        # Calculate penalties\n        penalty = 0.0\n        \n        # Penalty for circles outside the unit square - softened penalty\n        for i in range(n):\n            penalty += boundary_penalty(c[i, 0], r[i])\n            penalty += boundary_penalty(c[i, 1], r[i])\n        \n        # Penalty for overlapping circles - using a more efficient computation\n        for i in range(n):\n            for j in range(i+1, n):\n                # Squared distance is faster than sqrt\n                dist_squared = (c[i,0]-c[j,0])**2 + (c[i,1]-c[j,1])**2\n                sum_radii = r[i] + r[j]\n                \n                # Only compute sqrt if potentially overlapping\n                if dist_squared < sum_radii**2:\n                    dist = np.sqrt(dist_squared)\n                    overlap = sum_radii - dist\n                    if overlap > 0:\n                        # Quadratic penalty with higher weight for larger overlaps\n                        penalty += overlap**2 * (1 + overlap * 5)  # Non-linear overlap penalty\n        \n        # Return negative sum (for minimization) plus penalty\n        return -sum_r + penalty_factor * penalty\n    \n    # Gradient-based radius adjustment\n    def adjust_radii(x):\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        # Calculate radius adjustment based on boundary proximity\n        for i in range(n):\n            # Boundary gradient\n            grad_x_low = max(0, -(c[i, 0] - r[i]))\n            grad_x_high = max(0, (c[i, 0] + r[i] - 1))\n            grad_y_low = max(0, -(c[i, 1] - r[i]))\n            grad_y_high = max(0, (c[i, 1] + r[i] - 1))\n            \n            # Adjust radius based on boundary gradients\n            r[i] -= 0.0001 * (grad_x_low + grad_x_high + grad_y_low + grad_y_high)\n            \n            # Ensure radii stay within bounds\n            r[i] = max(bounds[2*n+i][0], min(r[i], bounds[2*n+i][1]))\n        \n        return np.concatenate([c.flatten(), r])\n        \n    # Callback function to adjust radii during optimization\n    def callback(xk):\n        nonlocal initial_guess\n        initial_guess = adjust_radii(xk)\n    \n    # Run the optimization\n    result = minimize(\n        objective, \n        initial_guess, \n        method='L-BFGS-B',\n        bounds=bounds,\n        options={\n            'maxiter': max_iterations,\n            'ftol': ftol,\n            'gtol': gtol,\n            'disp': False\n        },\n        callback=callback\n    )\n    \n    # Extract the results\n    optimized = result.x\n    centers_opt = optimized[:2*n].reshape(n, 2)\n    radii_opt = optimized[2*n:]\n    \n    return centers_opt, radii_opt\n\n\ndef boundary_penalty(coord, radius):\n    \"\"\"Calculates the penalty for a circle being outside the unit square.\"\"\"\n    penalty = 0.0\n    if coord - radius < 0:\n        penalty += (coord - radius)**2 * 2\n    if coord + radius > 1:\n        penalty += (coord + radius - 1)**2 * 2\n    return penalty\n\n\ndef apply_perturbation(centers, radii):\n    \"\"\"\n    Apply small random perturbations to escape local optima\n    \"\"\"\n    n = len(centers)\n    centers_perturbed = centers.copy()\n    radii_perturbed = radii.copy()\n    \n    # Identify circles that might be in suboptimal positions\n    # (typically smaller circles or those in crowded areas)\n    for i in range(n):\n        # Apply stronger perturbation to smaller circles\n        if radii[i] < np.median(radii):\n            # Position perturbation\n            centers_perturbed[i,0] += np.random.uniform(-0.03, 0.03)\n            centers_perturbed[i,1] += np.random.uniform(-0.03, 0.03)\n            \n            # Radius perturbation (smaller)\n            radii_perturbed[i] *= np.random.uniform(0.95, 1.05)\n    \n    # Ensure circles stay in bounds after perturbation\n    for i in range(n):\n        centers_perturbed[i,0] = np.clip(centers_perturbed[i,0], radii_perturbed[i], 1-radii_perturbed[i])\n        centers_perturbed[i,1] = np.clip(centers_perturbed[i,1], radii_perturbed[i], 1-radii_perturbed[i])\n    \n    return centers_perturbed, radii_perturbed\n\n\ndef is_valid_packing(centers, radii):\n    \"\"\"\n    Check if the packing is valid (no overlaps, all circles within bounds)\n    \"\"\"\n    n = len(centers)\n    \n    # Check if all circles are within bounds\n    for i in range(n):\n        if (centers[i,0] - radii[i] < -1e-10 or centers[i,0] + radii[i] > 1+1e-10 or\n            centers[i,1] - radii[i] < -1e-10 or centers[i,1] + radii[i] > 1+1e-10):\n            return False\n    \n    # Check for overlaps\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.sqrt((centers[i,0]-centers[j,0])**2 + (centers[i,1]-centers[j,1])**2)\n            if dist < radii[i] + radii[j] - 1e-10:  # Small tolerance\n                return False\n    \n    return True\n\n\ndef post_process(centers, radii):\n    \"\"\"\n    Post-process the optimization results to ensure validity and maximize radii.\n    \n    This function:\n    1. Ensures all circles are within bounds\n    2. Resolves any remaining overlaps\n    3. Tries to expand circles where possible\n    \"\"\"\n    n = len(centers)\n    \n    # Ensure circles are within bounds\n    for i in range(n):\n        # Left boundary\n        if centers[i,0] - radii[i] < 0:\n            centers[i,0] = radii[i]\n        # Right boundary\n        if centers[i,0] + radii[i] > 1:\n            centers[i,0] = 1 - radii[i]\n        # Bottom boundary\n        if centers[i,1] - radii[i] < 0:\n            centers[i,1] = radii[i]\n        # Top boundary\n        if centers[i,1] + radii[i] > 1:\n            centers[i,1] = 1 - radii[i]\n    \n    # Resolve overlaps (iteratively shrink overlapping circles)\n    max_iterations = 20\n    for _ in range(max_iterations):\n        overlap_found = False\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i,0]-centers[j,0])**2 + (centers[i,1]-centers[j,1])**2)\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 1e-10:  # Small tolerance\n                    overlap_found = True\n                    # Shrink both circles proportionally\n                    shrink_i = overlap * radii[i] / (radii[i] + radii[j])\n                    shrink_j = overlap * radii[j] / (radii[i] + radii[j])\n                    radii[i] -= shrink_i * 0.6  # Slightly more to ensure resolution\n                    radii[j] -= shrink_j * 0.6\n        \n        if not overlap_found:\n            break\n    \n    # Try to expand circles where possible - using a more efficient approach\n    # First identify how much each circle can expand\n    max_expansion = np.ones(n) * float('inf')\n    \n    # Boundary constraints\n    for i in range(n):\n        max_expansion[i] = min(max_expansion[i], centers[i,0] / radii[i] - 1)\n        max_expansion[i] = min(max_expansion[i], centers[i,1] / radii[i] - 1)\n        max_expansion[i] = min(max_expansion[i], (1 - centers[i,0]) / radii[i] - 1)\n        max_expansion[i] = min(max_expansion[i], (1 - centers[i,1]) / radii[i] - 1)\n    \n    # Circle-circle constraints\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.sqrt((centers[i,0]-centers[j,0])**2 + (centers[i,1]-centers[j,1])**2)\n                max_exp_ij = (dist / (radii[i] + radii[j])) - 1\n                max_expansion[i] = min(max_expansion[i], max_exp_ij)\n    \n    # Apply expansions (with a safety factor)\n    safety_factor = 0.99\n    for i in range(n):\n        if max_expansion[i] > 0:\n            expansion = min(max_expansion[i], 0.05)  # Limit maximum expansion\n            radii[i] *= (1 + expansion * safety_factor)\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.savefig(\"circle_packing.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```"]}}}