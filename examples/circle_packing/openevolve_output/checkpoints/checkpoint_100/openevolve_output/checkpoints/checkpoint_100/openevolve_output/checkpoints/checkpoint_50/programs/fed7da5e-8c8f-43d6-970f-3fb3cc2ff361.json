{"id": "fed7da5e-8c8f-43d6-970f-3fb3cc2ff361", "code": "I'll rewrite the program to improve its performance, focusing on reaching the target of 2.637 for the sum of radii. The current program has a good foundation, but I'll make significant changes to the optimization approach and initialization patterns.\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and multi-stage optimization\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n\n    # Known good patterns for n=26 from mathematical literature\n    patterns = [\n        initialize_specialized_pattern_1,\n        initialize_specialized_pattern_2,\n        initialize_specialized_pattern_3,\n        initialize_hexagonal_pattern,\n        initialize_concentric_rings,\n        initialize_corner_optimized\n    ]\n    \n    # Try multiple initializations with specialized patterns\n    for pattern_func in patterns:\n        centers, radii = pattern_func(n)\n        \n        # Multi-stage optimization with different parameters\n        centers, radii = optimize_stage1(centers, radii, iterations=200)\n        centers, radii = optimize_stage2(centers, radii, iterations=200)\n        centers, radii = optimize_stage3(centers, radii, iterations=300)\n        \n        # Final polish with gradient-based optimization\n        centers, radii = polish_packing(centers, radii)\n\n        # Keep the best result\n        sum_radii = np.sum(radii)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n\n    return best_centers, best_radii, best_sum\n\n\ndef initialize_specialized_pattern_1(n):\n    \"\"\"\n    Initialize with a pattern specifically designed for n=26 based on\n    mathematical literature for optimal circle packing.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Central large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.125  # Slightly larger center\n    \n    # First ring: 8 circles\n    count = 1\n    ring1_radius = 0.098\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = ring1_radius\n        count += 1\n    \n    # Second ring: 12 circles with variable sizes\n    ring2_base_radius = 0.085\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12  # Offset angle for staggering\n        dist = radii[0] + 2 * ring1_radius + ring2_base_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        \n        # Vary sizes slightly based on position\n        position_factor = 0.5 + 0.5 * np.sin(3 * angle)  # Creates variation pattern\n        radii[count] = ring2_base_radius * (0.95 + 0.1 * position_factor)\n        count += 1\n    \n    # Corner circles: 4 circles\n    corner_radius = 0.065\n    corners = [[corner_radius, corner_radius], \n               [1-corner_radius, corner_radius], \n               [corner_radius, 1-corner_radius], \n               [1-corner_radius, 1-corner_radius]]\n    \n    for i in range(4):\n        centers[count] = corners[i]\n        radii[count] = corner_radius\n        count += 1\n    \n    # Edge circle at top center\n    centers[count] = [0.5, 1-0.06]\n    radii[count] = 0.06\n    \n    return centers, radii\n\n\ndef initialize_specialized_pattern_2(n):\n    \"\"\"\n    Alternative specialized pattern with variable-sized circles\n    arranged in a hybrid grid-hexagonal pattern.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Larger circles in a hexagonal arrangement in center\n    hex_radius = 0.115\n    centers[0] = [0.5, 0.5]\n    radii[0] = hex_radius\n    \n    # Six circles around center\n    count = 1\n    inner_radius = 0.1\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = hex_radius + inner_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = inner_radius\n        count += 1\n    \n    # Twelve circles in outer ring with variable sizes\n    outer_radius_base = 0.085\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12  # Offset for staggering\n        dist = hex_radius + 2 * inner_radius + outer_radius_base\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        \n        # Size variation based on position\n        angle_factor = np.cos(2 * angle)  # Creates size variation pattern\n        radii[count] = outer_radius_base * (1.0 + 0.08 * angle_factor)\n        count += 1\n    \n    # Four circles in corners\n    corner_radius = 0.07\n    corners = [[corner_radius, corner_radius], \n               [1-corner_radius, corner_radius], \n               [corner_radius, 1-corner_radius], \n               [1-corner_radius, 1-corner_radius]]\n    \n    for i in range(4):\n        centers[count] = corners[i]\n        radii[count] = corner_radius\n        count += 1\n    \n    # Three circles at middle of edges\n    edge_radius = 0.065\n    edges = [[0.5, edge_radius], \n             [0.5, 1-edge_radius], \n             [edge_radius, 0.5]]\n    \n    for i in range(3):\n        centers[count] = edges[i]\n        radii[count] = edge_radius\n        count += 1\n    \n    return centers, radii\n\n\ndef initialize_specialized_pattern_3(n):\n    \"\"\"\n    Pattern with optimal distribution of circle sizes - larger in center,\n    medium in middle region, smaller near edges.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.13  # Larger central circle\n    \n    # First ring: 6 circles\n    count = 1\n    ring1_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring1_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = ring1_radius\n        count += 1\n    \n    # Second ring: 10 circles\n    ring2_radius = 0.09\n    for i in range(10):\n        angle = 2 * np.pi * i / 10 + np.pi/10  # Offset\n        dist = radii[0] + 2 * ring1_radius + ring2_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = ring2_radius\n        count += 1\n    \n    # Remaining circles placed strategically\n    remaining_positions = [\n        [0.12, 0.12, 0.075],  # Bottom left corner\n        [0.88, 0.12, 0.075],  # Bottom right corner\n        [0.12, 0.88, 0.075],  # Top left corner\n        [0.88, 0.88, 0.075],  # Top right corner\n        [0.5, 0.08, 0.07],    # Bottom middle\n        [0.5, 0.92, 0.07],    # Top middle\n        [0.08, 0.5, 0.07],    # Left middle\n        [0.92, 0.5, 0.07],    # Right middle\n        [0.3, 0.3, 0.08]      # Additional circle\n    ]\n    \n    for i, (x, y, r) in enumerate(remaining_positions):\n        if count < n:\n            centers[count] = [x, y]\n            radii[count] = r\n            count += 1\n    \n    return centers, radii\n\n\ndef initialize_hexagonal_pattern(n):\n    \"\"\"\n    Initialize with an optimized hexagonal pattern with variable sizes.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.12\n    \n    # First hexagonal ring (6 circles)\n    count = 1\n    ring1_radius = 0.1\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring1_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = ring1_radius\n        count += 1\n    \n    # Second hexagonal ring (12 circles)\n    ring2_radius = 0.085\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12  # Offset\n        dist = radii[0] + 2 * ring1_radius + ring2_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = ring2_radius\n        count += 1\n    \n    # Place remaining circles in corners and edges\n    if count < n:\n        # Corner circles\n        corner_radius = 0.07\n        corners = [[corner_radius, corner_radius], \n                   [1-corner_radius, corner_radius], \n                   [corner_radius, 1-corner_radius], \n                   [1-corner_radius, 1-corner_radius]]\n        \n        for i in range(min(4, n-count)):\n            centers[count] = corners[i]\n            radii[count] = corner_radius\n            count += 1\n    \n    # Fill remaining positions if needed\n    while count < n:\n        # Place randomly with bias toward empty areas\n        best_pos = [0.5, 0.5]\n        best_dist = 0\n        \n        for _ in range(20):  # Try 20 candidate positions\n            pos = np.random.rand(2)\n            min_dist = float('inf')\n            \n            for i in range(count):\n                dist = np.linalg.norm(pos - centers[i]) - radii[i]\n                min_dist = min(min_dist, dist)\n            \n            if min_dist > best_dist:\n                best_dist = min_dist\n                best_pos = pos\n        \n        centers[count] = best_pos\n        radii[count] = min(0.07, best_dist * 0.95)  # 95% of available space\n        count += 1\n    \n    return centers, radii\n\n\ndef initialize_concentric_rings(n):\n    \"\"\"\n    Initialize with concentric rings of circles with optimal size distribution.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.125\n    \n    # Define ring parameters: (num_circles, radius)\n    rings = [\n        (8, 0.1),     # First ring: 8 circles of radius 0.1\n        (12, 0.085),  # Second ring: 12 circles of radius 0.085\n        (5, 0.07)     # Third ring: 5 circles of radius 0.07\n    ]\n    \n    count = 1\n    for ring_idx, (num_circles, circle_radius) in enumerate(rings):\n        # Calculate distance from center for this ring\n        if ring_idx == 0:\n            ring_dist = radii[0] + circle_radius\n        else:\n            # Distance depends on previous ring\n            prev_radius = rings[ring_idx-1][1]\n            ring_dist += prev_radius + circle_radius\n        \n        # Place circles in this ring\n        for i in range(num_circles):\n            if count < n:\n                angle = 2 * np.pi * i / num_circles\n                if ring_idx > 0:  # Offset angles for non-first rings\n                    angle += np.pi / num_circles\n                \n                centers[count] = [\n                    0.5 + ring_dist * np.cos(angle),\n                    0.5 + ring_dist * np.sin(angle)\n                ]\n                radii[count] = circle_radius\n                count += 1\n    \n    # Place remaining circles in corners\n    if count < n:\n        corner_radius = 0.07\n        corners = [[corner_radius, corner_radius], \n                   [1-corner_radius, corner_radius], \n                   [corner_radius, 1-corner_radius], \n                   [1-corner_radius, 1-corner_radius]]\n        \n        for i in range(min(4, n-count)):\n            centers[count] = corners[i]\n            radii[count] = corner_radius\n            count += 1\n    \n    return centers, radii\n\n\ndef initialize_corner_optimized(n):\n    \"\"\"\n    Initialize with an arrangement that optimizes corner and edge utilization.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Four corners\n    corner_radius = 0.09\n    corners = [[corner_radius, corner_radius], \n               [1-corner_radius, corner_radius], \n               [corner_radius, 1-corner_radius], \n               [1-corner_radius, 1-corner_radius]]\n    \n    for i in range(4):\n        centers[i] = corners[i]\n        radii[i] = corner_radius\n    \n    # Four edge midpoints\n    edge_radius = 0.08\n    edges = [[0.5, edge_radius], \n             [1-edge_radius, 0.5], \n             [0.5, 1-edge_radius], \n             [edge_radius, 0.5]]\n    \n    for i in range(4):\n        centers[i+4] = edges[i]\n        radii[i+4] = edge_radius\n    \n    # Central large circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.12\n    \n    # Inner ring around central circle\n    inner_radius = 0.095\n    count = 9\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[8] + inner_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = inner_radius\n        count += 1\n    \n    # Middle ring\n    middle_radius = 0.085\n    for i in range(12):\n        if count < n:\n            angle = 2 * np.pi * i / 12 + np.pi/12\n            dist = radii[8] + 2 * inner_radius + middle_radius\n            centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n            radii[count] = middle_radius\n            count += 1\n    \n    return centers, radii\n\n\ndef optimize_stage1(centers, radii, iterations):\n    \"\"\"\n    First optimization stage: Resolve overlaps and establish basic structure\n    using physics-based model with adaptive parameters.\n    \"\"\"\n    n = len(centers)\n    velocity = np.zeros_like(centers)\n    repulsion_strength = 30.0\n    wall_repulsion = 30.0\n    dt = 0.01\n    dampening = 0.92\n    \n    for iter in range(iterations):\n        forces = np.zeros_like(centers)\n        progress = iter / iterations\n        \n        # Adaptive parameters based on progress\n        local_repulsion = repulsion_strength * (1.0 + progress)\n        local_wall = wall_repulsion * (1.0 + 0.5 * progress)\n        \n        # Circle-circle repulsion with efficient distance calculation\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist_vec = centers[i] - centers[j]\n                dist_sq = np.sum(dist_vec * dist_vec)  # Squared distance\n                min_dist = radii[i] + radii[j]\n                \n                if dist_sq < min_dist * min_dist:\n                    dist = np.sqrt(dist_sq)  # Only compute sqrt when needed\n                    overlap = min_dist - dist\n                    direction = dist_vec / (dist + 1e-8)\n                    force = local_repulsion * overlap * direction\n                    forces[i] += force\n                    forces[j] -= force\n        \n        # Wall repulsion with soft boundary\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Soft boundary function that increases force as circles approach edges\n            if x < r:\n                forces[i, 0] += local_wall * (r - x) / (x + 0.01)\n            if x > 1 - r:\n                forces[i, 0] -= local_wall * (x - (1 - r)) / (1.01 - x)\n            if y < r:\n                forces[i, 1] += local_wall * (r - y) / (y + 0.01)\n            if y > 1 - r:\n                forces[i, 1] -= local_wall * (y - (1 - r)) / (1.01 - y)\n        \n        # Update positions using velocity Verlet integration\n        velocity = dampening * (velocity + forces * dt)\n        centers += velocity * dt\n        \n        # Add small random perturbation every few iterations\n        if iter % 25 == 0 and iter < iterations * 0.7:\n            centers += np.random.normal(0, 0.003 * (1 - progress), centers.shape)\n        \n        # Keep circles within bounds\n        for i in range(n):\n            centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n            centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n    \n    return centers, radii\n\n\ndef optimize_stage2(centers, radii, iterations):\n    \"\"\"\n    Second optimization stage: Grow radii while maintaining valid packing\n    with adaptive growth rates.\n    \"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # Base growth rates for different circle types\n    base_growth_rate = 0.0005\n    \n    for iter in range(iterations):\n        # Calculate available space for each circle\n        available_space = np.ones(n) * float('inf')\n        \n        # Space limited by other circles\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    space = dist - radii[j]\n                    available_space[i] = min(available_space[i], space)\n        \n        # Space limited by walls\n        for i in range(n):\n            x, y = centers[i]\n            wall_space = min(x, y, 1-x, 1-y)\n            available_space[i] = min(available_space[i], wall_space)\n        \n        # Adaptive growth based on position and available space\n        growth_happened = False\n        for i in range(n):\n            # Calculate distance from center of square\n            dist_from_center = np.linalg.norm(centers[i] - 0.5)\n            \n            # Adjust growth rate based on position - favor central circles\n            position_factor = 1.0 - 0.3 * dist_from_center\n            \n            # Calculate growth potential\n            growth_potential = available_space[i] - radii[i]\n            \n            if growth_potential > 0.0001:  # Only grow if there's space\n                # Adaptive growth rate\n                growth_rate = base_growth_rate * position_factor\n                \n                # Grow radius\n                growth_amount = min(growth_rate, growth_potential * 0.5)\n                radii[i] += growth_amount\n                growth_happened = growth_amount > 0\n        \n        # Resolve any overlaps that might occur\n        centers, radii = resolve_overlaps(centers, radii)\n        \n        # Keep track of best configuration\n        sum_radii = np.sum(radii)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n        \n        # Early stopping if no growth is happening\n        if not growth_happened and iter > iterations // 2:\n            break\n    \n    return best_centers, best_radii\n\n\ndef optimize_stage3(centers, radii, iterations):\n    \"\"\"\n    Third optimization stage: Fine-tune positions and sizes\n    using simulated annealing with adaptive parameters.\n    \"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    temperature = 0.01\n    cooling_rate = 0.995\n    \n    # Adaptive perturbation parameters\n    position_perturbation_base = 0.002\n    radius_perturbation_base = 0.0007\n    \n    for iter in range(iterations):\n        progress = iter / iterations\n        \n        # Adaptive perturbation sizes\n        position_perturbation = position_perturbation_base * (1.0 - 0.7 * progress)\n        radius_perturbation = radius_perturbation_base * (1.0 - 0.7 * progress)\n        \n        # Make a copy of current state\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Choose perturbation strategy\n        strategy = np.random.choice([0, 1, 2], p=[0.6, 0.3, 0.1])\n        \n        if strategy == 0:\n            # Perturb single circle\n            idx = np.random.randint(0, n)\n            new_centers[idx] += np.random.normal(0, position_perturbation, 2)\n            new_radii[idx] = max(0.01, new_radii[idx] + np.random.normal(0, radius_perturbation))\n            \n            # Keep circle within bounds\n            new_centers[idx, 0] = np.clip(new_centers[idx, 0], new_radii[idx], 1 - new_radii[idx])\n            new_centers[idx, 1] = np.clip(new_centers[idx, 1], new_radii[idx], 1 - new_radii[idx])\n            \n        elif strategy == 1:\n            # Perturb a pair of adjacent circles\n            idx1 = np.random.randint(0, n)\n            \n            # Find closest circle to idx1\n            min_dist = float('inf')\n            idx2 = idx1\n            for j in range(n):\n                if j != idx1:\n                    dist = np.linalg.norm(centers[idx1] - centers[j])\n                    if dist < min_dist:\n                        min_dist = dist\n                        idx2 = j\n            \n            # Perturb both circles in opposite directions\n            perturb = np.random.normal(0, position_perturbation, 2)\n            new_centers[idx1] += perturb\n            new_centers[idx2] -= perturb\n            \n            # Keep circles within bounds\n            for idx in [idx1, idx2]:\n                new_centers[idx, 0] = np.clip(new_centers[idx, 0], new_radii[idx], 1 - new_radii[idx])\n                new_centers[idx, 1] = np.clip(new_centers[idx, 1], new_radii[idx], 1 - new_radii[idx])\n            \n        else:\n            # Redistribute radius between two circles\n            idx1, idx2 = np.random.choice(n, 2, replace=False)\n            transfer = np.random.normal(0, radius_perturbation)\n            \n            new_radii[idx1] = max(0.01, new_radii[idx1] + transfer)\n            new_radii[idx2] = max(0.01, new_radii[idx2] - transfer)\n        \n        # Check for validity\n        valid = is_valid_packing(new_centers, new_radii)\n        \n        # Accept or reject based on simulated annealing\n        if valid:\n            new_sum = np.sum(new_radii)\n            delta_e = new_sum - np.sum(radii)\n            \n            if delta_e > 0 or np.random.random() < np.exp(delta_e / temperature):\n                centers = new_centers.copy()\n                radii = new_radii.copy()\n                \n                if new_sum > best_sum:\n                    best_sum = new_sum\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n        \n        # Cool temperature\n        temperature *= cooling_rate\n        \n        # Periodically optimize all radii\n        if iter % 30 == 0:\n            centers, radii = optimize_all_radii(centers, radii)\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n    \n    return best_centers, best_radii\n\n\ndef is_valid_packing(centers, radii):\n    \"\"\"\n    Check if a packing is valid (no overlaps).\n    Optimized for performance with early exit.\n    \"\"\"\n    n = len(centers)\n    \n    # Check circle-circle overlaps\n    for i in range(n):\n        # Check wall constraints first (faster)\n        x, y = centers[i]\n        r = radii[i]\n        if x < r or x > 1-r or y < r or y > 1-r:\n            return False\n        \n        # Check circle overlaps\n        for j in range(i+1, n):\n            dist_sq = np.sum((centers[i] - centers[j])**2)\n            min_dist = radii[i] + radii[j]\n            if dist_sq < min_dist**2 - 1e-10:  # Small epsilon for numerical stability\n                return False\n    \n    return True\n\n\ndef resolve_overlaps(centers, radii):\n    \"\"\"\n    Resolve any overlaps in the packing by iteratively\n    adjusting positions and sizes.\n    \"\"\"\n    n = len(centers)\n    max_iterations = 20\n    \n    for _ in range(max_iterations):\n        has_overlap = False\n        \n        # Check and resolve circle-circle overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist - 1e-10:\n                    has_overlap = True\n                    \n                    # Calculate overlap\n                    overlap = min_dist - dist\n                    direction = (centers[i] - centers[j]) / (dist + 1e-10)\n                    \n                    # Move circles apart\n                    move_i = 0.5 * overlap * direction\n                    move_j = -0.5 * overlap * direction\n                    \n                    centers[i] += move_i\n                    centers[j] += move_j\n                    \n                    # Ensure circles stay within bounds\n                    for idx, move in [(i, move_i), (j, move_j)]:\n                        if centers[idx, 0] < radii[idx]:\n                            centers[idx, 0] = radii[idx]\n                        elif centers[idx, 0] > 1 - radii[idx]:\n                            centers[idx, 0] = 1 - radii[idx]\n                            \n                        if centers[idx, 1] < radii[idx]:\n                            centers[idx, 1] = radii[idx]\n                        elif centers[idx, 1] > 1 - radii[idx]:\n                            centers[idx, 1] = 1 - radii[idx]\n        \n        # Check and resolve wall overlaps\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            \n            if x < r:\n                centers[i, 0] = r\n                has_overlap = True\n            elif x > 1 - r:\n                centers[i, 0] = 1 - r\n                has_overlap = True\n                \n            if y < r:\n                centers[i, 1] = r\n                has_overlap = True\n            elif y > 1 - r:\n                centers[i, 1] = 1 - r\n                has_overlap = True\n        \n        # If no overlaps, we're done\n        if not has_overlap:\n            break\n    \n    return centers, radii\n\n\ndef optimize_all_radii(centers, radii):\n    \"\"\"\n    Optimize all radii to fill available space with improved efficiency.\n    \"\"\"\n    n = len(centers)\n    \n    # Pre-calculate all pairwise distances\n    distances = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1, n):\n            distances[i, j] = distances[j, i] = np.linalg.norm(centers[i] - centers[j])\n    \n    # Calculate wall distances\n    wall_distances = np.zeros(n)\n    for i in range(n):\n        x, y = centers[i]\n        wall_distances[i] = min(x, y, 1-x, 1-y)\n    \n    # Iteratively optimize radii\n    for _ in range(3):  # Fewer iterations for speed\n        for i in range(n):\n            # Find minimum distance to other circles\n            min_dist_to_others = float('inf')\n            for j in range(n):\n                if i != j:\n                    dist = distances[i, j] - radii[j]\n                    min_dist_to_others = min(min_dist_to_others, dist", "language": "python", "parent_id": "a229601d-5cb0-4c2f-a9db-47400a0388e7", "generation": 6, "timestamp": 1750792238.5314512, "iteration_found": 38, "metrics": {"validity": 0.0, "combined_score": 0.0, "error": "Program execution failed: invalid syntax (tmpvdrcpeo3.py, line 1)"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.511207897015921, "target_ratio": 0.9530200747688505, "combined_score": 0.9530200747688505, "eval_time": 16.966673612594604}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.637 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.412, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - validity: 1.0000\n- sum_radii: 2.5112\n- target_ratio: 0.9530\n- combined_score: 0.9530\n- eval_time: 16.9667\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: sum_radii, target_ratio, combined_score. Consider continuing with similar changes.\n- Metrics showing regression: eval_time. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 1.7697, target_ratio: 0.6716, combined_score: 0.6716, eval_time: 22.4502\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.2023, target_ratio: 0.8358, combined_score: 0.8358, eval_time: 21.9099\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6267, target_ratio: 0.9968, combined_score: 0.9968, eval_time: 42.1538\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 9.5548)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6267), Performs well on target_ratio (0.9968), Performs well on combined_score (0.9968), Performs well on eval_time (42.1538)\n\n\n### Program 2 (Score: 5.1566)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and multi-stage optimization\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.3210), Performs well on target_ratio (0.8808), Performs well on combined_score (0.8808), Performs well on eval_time (20.7004)\n\n\n### Program 3 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (0.0000), Performs well on sum_radii (0.0000), Performs well on target_ratio (0.0000), Performs well on combined_score (0.0000)\n\n\n### Program 4 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on error (Program execution failed: No module named 'nlopt')\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\nI'll create an improved circle packing algorithm that aims to reach the target of 2.637 for the sum of radii. Based on the mathematical literature and computational geometry principles, I'll implement a more effective approach focusing on specialized patterns and optimization techniques.\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\n# ... (truncated)\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n\n    # Try multiple initializations and optimization strategies\n    for strategy in range(8):  # Increased strategies\n        # Initialize with different patterns\n        if strategy == 0:\n            centers, radii = initialize_pattern_hexagonal(n)\n        elif strategy == 1:\n            centers, radii = initialize_pattern_grid(n)\n        elif strategy == 2:\n            centers, radii = initialize_pattern_hybrid(n)\n        elif strategy == 3:\n            centers, radii = initialize_pattern_corner_biased(n)  # New strategy\n        elif strategy == 4:\n            centers, radii = initialize_pattern_random(n)  # New strategy\n        elif strategy == 5:\n            centers, radii = initialize_pattern_triangular(n)\n        elif strategy == 6:\n             centers, radii = initialize_pattern_adaptive_grid(n)\n        else:\n            centers, radii = initialize_pattern_radial(n)\n\n\n        # Multi-stage optimization\n        centers, radii = optimize_stage1(centers, radii, iterations=300)\n        centers, radii = optimize_stage2(centers, radii, iterations=300)\n        centers, radii = optimize_stage3(centers, radii, iterations=500)  # Increased iterations\n\n        # Keep the best result\n        sum_radii = np.sum(radii)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n\n    return best_centers, best_radii, best_sum\n\n\ndef initialize_pattern_hexagonal(n):\n    \"\"\"Initialize with a hexagonal pattern with variable sizes\"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.11  # Larger center circle\n\n    # First hexagonal ring (6 circles)\n    count = 1\n    ring_radius = 0.095\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = ring_radius\n        count += 1\n\n    # Second hexagonal ring (12 circles)\n    ring_radius = 0.085\n    for i in range(12):\n        angle = 2 * np.pi * i / 12\n        dist = radii[0] + 2 * 0.095 + ring_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = ring_radius\n        count += 1\n\n    # Corner circles (4 circles)\n    corner_radius = 0.09\n    centers[count] = [0.1, 0.1]\n    radii[count] = corner_radius\n    count += 1\n    centers[count] = [0.9, 0.1]\n    radii[count] = corner_radius\n    count += 1\n    centers[count] = [0.1, 0.9]\n    radii[count] = corner_radius\n    count += 1\n    centers[count] = [0.9, 0.9]\n    radii[count] = corner_radius\n    count += 1\n\n    # Edge circles (3 circles)\n    edge_radius = 0.07\n    centers[count] = [0.5, 0.05]\n    radii[count] = edge_radius\n    count += 1\n    centers[count] = [0.5, 0.95]\n    radii[count] = edge_radius\n    count += 1\n    centers[count] = [0.05, 0.5]\n    radii[count] = edge_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_grid(n):\n    \"\"\"Initialize with a grid pattern with variable sizes\"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Create a 5x5 grid (25 circles) plus 1 in center\n    grid_size = 5\n    spacing = 1.0 / grid_size\n    count = 0\n\n    # Grid circles\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count < 25:\n                centers[count] = [spacing / 2 + i * spacing, spacing / 2 + j * spacing]\n\n                # Larger circles in the middle, smaller at edges\n                dist_to_center = np.sqrt((centers[count][0] - 0.5) ** 2 + (centers[count][1] - 0.5) ** 2)\n                radii[count] = 0.07 + 0.04 * (1 - dist_to_center**2) # Quadratic falloff\n                count += 1\n\n    # One extra circle in the center with variable size\n    centers[count] = [0.5, 0.5]\n    radii[count] = 0.07\n\n    return centers, radii\n\n\ndef initialize_pattern_hybrid(n):\n    \"\"\"Initialize with a hybrid pattern optimized for n=26\"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Based on known good patterns for n=26\n    # Central large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.12\n\n    # Inner ring (6 circles)\n    count = 1\n    inner_radius = 0.1\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + inner_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = inner_radius\n        count += 1\n\n    # Middle ring (6 circles)\n    middle_radius = 0.09\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi / 6\n        dist = radii[0] + 2 * inner_radius + middle_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = middle_radius\n        count += 1\n\n    # Outer partial ring (9 circles)\n    outer_radius = 0.08\n    for i in range(9):\n        angle = 2 * np.pi * i / 9\n        dist = radii[0] + 2 * inner_radius + 2 * middle_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = outer_radius\n        count += 1\n\n    # Corner circles (4 circles)\n    corner_radius = 0.06\n    centers[count] = [corner_radius, corner_radius]\n    radii[count] = corner_radius\n    count += 1\n    centers[count] = [1 - corner_radius, corner_radius]\n    radii[count] = corner_radius\n    count += 1\n    centers[count] = [corner_radius, 1 - corner_radius]\n    radii[count] = corner_radius\n    count += 1\n    centers[count] = [1 - corner_radius, 1 - corner_radius]\n    radii[count] = corner_radius\n\n    return centers, radii\n\n\ndef initialize_pattern_corner_biased(n):\n    \"\"\"Initialize with larger circles in the corners\"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    corner_radius = 0.10\n    centers[0] = [corner_radius, corner_radius]\n    radii[0] = corner_radius\n    centers[1] = [1 - corner_radius, corner_radius]\n    radii[1] = corner_radius\n    centers[2] = [corner_radius, 1 - corner_radius]\n    radii[2] = corner_radius\n    centers[3] = [1 - corner_radius, 1 - corner_radius]\n    radii[3] = corner_radius\n\n    remaining = n - 4\n    grid_size = int(np.sqrt(remaining))\n    spacing = (1 - 2 * corner_radius) / (grid_size - 1) if grid_size > 1 else 0.5\n\n    count = 4\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count < n:\n                x = corner_radius + i * spacing\n                y = corner_radius + j * spacing\n                centers[count] = [x, y]\n                radii[count] = 0.06 + 0.02 * np.random.rand()\n                count += 1\n\n    return centers, radii\n\ndef initialize_pattern_random(n):\n    \"\"\"Initialize with random positions and radii\"\"\"\n    centers = np.random.rand(n, 2)\n    radii = np.random.rand(n) * 0.06 + 0.05  # Radii between 0.05 and 0.11\n    return centers, radii\n\ndef initialize_pattern_triangular(n):\n    \"\"\"Initialize with a triangular lattice pattern, denser packing.\"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    radius = 0.075  # Initial radius, will be adjusted.\n    x_start = radius\n    y_start = radius\n    x_spacing = 2 * radius\n    y_spacing = np.sqrt(3) * radius\n    count = 0\n\n    x = x_start\n    y = y_start\n\n    while count < n:\n        centers[count] = [x, y]\n        radii[count] = radius\n        count += 1\n\n        x += x_spacing\n        if x > 1 - radius:\n            x = x_start + (x_spacing / 2 if int(y / y_spacing) % 2 == 0 else 0) # Stagger rows\n            y += y_spacing\n            if y > 1 - radius:\n                radius *= 0.9 # Reduce radius slightly if too many are needed.\n                x_start = radius\n                y_start = radius\n                x_spacing = 2 * radius\n                y_spacing = np.sqrt(3) * radius\n                x = x_start\n                y = y_start\n                count = 0 #Restart packing with smaller circles\n\n    return centers[:n], radii[:n]\n\ndef initialize_pattern_adaptive_grid(n):\n    \"\"\"Initialize with an adaptive grid pattern, denser in the center.\"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    count = 0\n\n    # Place a larger circle in the center\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.12\n    count += 1\n\n    # Adaptively fill the rest of the space with smaller circles\n    remaining = n - 1\n    grid_density = 4  # Adjust this for density\n    while count < n:\n        for i in range(grid_density):\n            for j in range(grid_density):\n                if count < n:\n                    x = (i + 0.5) / grid_density\n                    y = (j + 0.5) / grid_density\n                    dist_to_center = np.sqrt((x - 0.5)**2 + (y - 0.5)**2)\n                    if dist_to_center > 0.15: #Avoid overlapping center circle\n                        centers[count] = [x, y]\n                        radii[count] = 0.06 + 0.02 * np.random.rand()\n                        count += 1\n        grid_density += 1 #Increase density if we haven't placed all circles\n\n    return centers, radii\n\ndef initialize_pattern_radial(n):\n    \"\"\"Initialize with a radial pattern from the center.\"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    count = 0\n\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.12\n    count += 1\n\n    num_rings = 4\n    circles_per_ring = [6, 8, 8, 3]  # Adjust distribution for different ring densities\n    ring_radii = [0.10, 0.09, 0.08, 0.07] #Radius distribution\n\n    for i in range(num_rings):\n        num_circles = circles_per_ring[i]\n        ring_radius = ring_radii[i]\n        for j in range(num_circles):\n            if count < n:\n                angle = 2 * np.pi * j / num_circles\n                dist = radii[0] + (i + 1) * 0.10\n                centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n                radii[count] = ring_radius\n                count += 1\n\n    return centers, radii\n\n\ndef optimize_stage1(centers, radii, iterations):\n    \"\"\"\n    First optimization stage: Resolve overlaps and establish basic structure\n    \"\"\"\n    n = len(centers)\n    velocity = np.zeros_like(centers)\n    repulsion_strength = 25.0  # Increased\n    wall_repulsion = 25.0  # Increased\n    dt = 0.01\n    dampening = 0.95\n    gravity = 0.001  # Add a weak gravity towards the center, reduced\n\n    for iter in range(iterations):\n        forces = np.zeros_like(centers)\n        temperature = 1.0 - iter / iterations  # Simulated annealing temperature\n\n        # Circle-circle repulsion\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist_vec = centers[i] - centers[j]\n                dist = np.linalg.norm(dist_vec)\n                min_dist = radii[i] + radii[j]\n\n                if dist < min_dist:\n                    overlap = min_dist - dist\n                    direction = dist_vec / (dist + 1e-8)\n                    force = repulsion_strength * overlap * direction\n                    forces[i] += force\n                    forces[j] -= force\n\n        # Wall repulsion\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n\n            if x < r:\n                forces[i, 0] += wall_repulsion * (r - x)\n            if x > 1 - r:\n                forces[i, 0] -= wall_repulsion * (x - (1 - r))\n            if y < r:\n                forces[i, 1] += wall_repulsion * (r - y)\n            if y > 1 - r:\n                forces[i, 1] -= wall_repulsion * (y - (1 - r))\n\n            # Gravity towards center\n            forces[i] -= gravity * (centers[i] - 0.5)\n\n        # Update positions using velocity Verlet integration\n        velocity = dampening * (velocity + forces * dt)\n        centers += velocity * dt\n\n        # Add random perturbation (simulated annealing)\n        if iter % 20 == 0:\n            centers += np.random.normal(0, 0.004 * temperature, centers.shape) # Reduced magnitude\n\n        # Keep circles within bounds\n        for i in range(n):\n            centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n            centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n\n    return centers, radii\n\n\ndef optimize_stage2(centers, radii, iterations):\n    \"\"\"\n    Second optimization stage: Grow radii while maintaining valid packing\n    \"\"\"\n    n = len(centers)\n    growth_rate = 0.0008 # Reduced growth rate\n\n    for _ in range(iterations):\n        # Calculate overlaps\n        overlaps = np.zeros(n)\n\n        # Circle-circle overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n\n                if dist < min_dist:\n                    overlap = min_dist - dist\n                    overlaps[i] += overlap\n                    overlaps[j] += overlap\n\n        # Wall overlaps\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n\n            if x < r:\n                overlaps[i] += r - x\n            if x > 1 - r:\n                overlaps[i] += x - (1 - r)\n            if y < r:\n                overlaps[i] += r - y\n            if y > 1 - r:\n                overlaps[i] += y - (1 - r)\n\n        # Grow circles without overlaps\n        for i in range(n):\n            if overlaps[i] <= 1e-6:\n                # Calculate available space\n                min_dist_to_others = float('inf')\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j]) - radii[j]\n                        min_dist_to_others = min(min_dist_to_others, dist)\n\n                space_to_walls = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n                available_space = min(min_dist_to_others, space_to_walls) - radii[i]\n\n                # Grow radius based on available space\n                radii[i] += min(growth_rate, available_space * 0.6)\n            else:\n                # Shrink overlapping circles\n                radii[i] = max(0.01, radii[i] - overlaps[i] * 0.1)\n\n    return centers, radii\n\n\ndef optimize_stage3(centers, radii, iterations):\n    \"\"\"\n    Third optimization stage: Fine-tune positions and sizes\n    \"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n\n    temperature = 0.01  # Initial temperature for simulated annealing\n    cooling_rate = 0.995  # Cooling rate\n    position_perturbation = 0.002\n    radius_perturbation = 0.0008\n\n    for iter in range(iterations):\n        # Make a copy of current state\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n\n        # Randomly perturb positions and radius\n        idx = np.random.randint(0, n)\n        new_centers[idx] += np.random.normal(0, position_perturbation, 2)  # Reduced position perturbation\n        radius_change = np.random.normal(0, radius_perturbation) # Reduced radius perturbation\n        new_radii[idx] = max(0.01, new_radii[idx] + radius_change)\n\n        # Keep circle within bounds\n        new_centers[idx, 0] = np.clip(new_centers[idx, 0], new_radii[idx], 1 - new_radii[idx])\n        new_centers[idx, 1] = np.clip(new_centers[idx, 1], new_radii[idx], 1 - new_radii[idx])\n\n        # Check for overlaps - more efficient overlap check\n        valid = True\n        for i in range(n):\n            if i == idx:\n                continue\n            dist_vec = new_centers[idx] - new_centers[i]\n            dist_sq = np.sum(dist_vec * dist_vec)\n            min_dist = new_radii[idx] + new_radii[i]\n            if dist_sq < min_dist * min_dist: # Avoid sqrt\n                valid = False\n                break\n\n        # Accept or reject based on simulated annealing\n        if valid:\n            new_sum = np.sum(new_radii)\n            delta_e = new_sum - np.sum(radii)\n            if delta_e > 0 or np.random.random() < np.exp(delta_e / temperature):\n                centers = new_centers\n                radii = new_radii\n\n                if new_sum > best_sum:\n                    best_sum = new_sum\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n\n        # Cool temperature\n        temperature *= cooling_rate\n\n        # Periodically optimize all radii\n        if iter % 50 == 0:\n            centers, radii = optimize_all_radii(centers, radii)\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n\n    return best_centers, best_radii\n\n\ndef optimize_all_radii(centers, radii):\n    \"\"\"Optimize all radii to fill available space\"\"\"\n    n = len(centers)\n\n    # Calculate available space for each circle\n    for _ in range(5):  # Reduced iterations for speed\n        for i in range(n):\n            # Calculate minimum distance to other circles\n            min_dist_to_others = float('inf')\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j]) - radii[j]\n                    min_dist_to_others = min(min_dist_to_others, dist)\n\n            # Calculate minimum distance to walls\n            space_to_walls = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n\n            # Set radius to fill available space - softened update\n            available_space = min(min_dist_to_others, space_to_walls)\n            radii[i] = 0.8 * radii[i] + 0.2 * available_space # Dampened update\n\n    return centers, radii\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["I'll rewrite the program to improve its performance, focusing on reaching the target of 2.637 for the sum of radii. The current program has a good foundation, but I'll make significant changes to the optimization approach and initialization patterns.\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and multi-stage optimization\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n\n    # Known good patterns for n=26 from mathematical literature\n    patterns = [\n        initialize_specialized_pattern_1,\n        initialize_specialized_pattern_2,\n        initialize_specialized_pattern_3,\n        initialize_hexagonal_pattern,\n        initialize_concentric_rings,\n        initialize_corner_optimized\n    ]\n    \n    # Try multiple initializations with specialized patterns\n    for pattern_func in patterns:\n        centers, radii = pattern_func(n)\n        \n        # Multi-stage optimization with different parameters\n        centers, radii = optimize_stage1(centers, radii, iterations=200)\n        centers, radii = optimize_stage2(centers, radii, iterations=200)\n        centers, radii = optimize_stage3(centers, radii, iterations=300)\n        \n        # Final polish with gradient-based optimization\n        centers, radii = polish_packing(centers, radii)\n\n        # Keep the best result\n        sum_radii = np.sum(radii)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n\n    return best_centers, best_radii, best_sum\n\n\ndef initialize_specialized_pattern_1(n):\n    \"\"\"\n    Initialize with a pattern specifically designed for n=26 based on\n    mathematical literature for optimal circle packing.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Central large circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.125  # Slightly larger center\n    \n    # First ring: 8 circles\n    count = 1\n    ring1_radius = 0.098\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        dist = radii[0] + ring1_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = ring1_radius\n        count += 1\n    \n    # Second ring: 12 circles with variable sizes\n    ring2_base_radius = 0.085\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12  # Offset angle for staggering\n        dist = radii[0] + 2 * ring1_radius + ring2_base_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        \n        # Vary sizes slightly based on position\n        position_factor = 0.5 + 0.5 * np.sin(3 * angle)  # Creates variation pattern\n        radii[count] = ring2_base_radius * (0.95 + 0.1 * position_factor)\n        count += 1\n    \n    # Corner circles: 4 circles\n    corner_radius = 0.065\n    corners = [[corner_radius, corner_radius], \n               [1-corner_radius, corner_radius], \n               [corner_radius, 1-corner_radius], \n               [1-corner_radius, 1-corner_radius]]\n    \n    for i in range(4):\n        centers[count] = corners[i]\n        radii[count] = corner_radius\n        count += 1\n    \n    # Edge circle at top center\n    centers[count] = [0.5, 1-0.06]\n    radii[count] = 0.06\n    \n    return centers, radii\n\n\ndef initialize_specialized_pattern_2(n):\n    \"\"\"\n    Alternative specialized pattern with variable-sized circles\n    arranged in a hybrid grid-hexagonal pattern.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Larger circles in a hexagonal arrangement in center\n    hex_radius = 0.115\n    centers[0] = [0.5, 0.5]\n    radii[0] = hex_radius\n    \n    # Six circles around center\n    count = 1\n    inner_radius = 0.1\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = hex_radius + inner_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = inner_radius\n        count += 1\n    \n    # Twelve circles in outer ring with variable sizes\n    outer_radius_base = 0.085\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12  # Offset for staggering\n        dist = hex_radius + 2 * inner_radius + outer_radius_base\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        \n        # Size variation based on position\n        angle_factor = np.cos(2 * angle)  # Creates size variation pattern\n        radii[count] = outer_radius_base * (1.0 + 0.08 * angle_factor)\n        count += 1\n    \n    # Four circles in corners\n    corner_radius = 0.07\n    corners = [[corner_radius, corner_radius], \n               [1-corner_radius, corner_radius], \n               [corner_radius, 1-corner_radius], \n               [1-corner_radius, 1-corner_radius]]\n    \n    for i in range(4):\n        centers[count] = corners[i]\n        radii[count] = corner_radius\n        count += 1\n    \n    # Three circles at middle of edges\n    edge_radius = 0.065\n    edges = [[0.5, edge_radius], \n             [0.5, 1-edge_radius], \n             [edge_radius, 0.5]]\n    \n    for i in range(3):\n        centers[count] = edges[i]\n        radii[count] = edge_radius\n        count += 1\n    \n    return centers, radii\n\n\ndef initialize_specialized_pattern_3(n):\n    \"\"\"\n    Pattern with optimal distribution of circle sizes - larger in center,\n    medium in middle region, smaller near edges.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.13  # Larger central circle\n    \n    # First ring: 6 circles\n    count = 1\n    ring1_radius = 0.105\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring1_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = ring1_radius\n        count += 1\n    \n    # Second ring: 10 circles\n    ring2_radius = 0.09\n    for i in range(10):\n        angle = 2 * np.pi * i / 10 + np.pi/10  # Offset\n        dist = radii[0] + 2 * ring1_radius + ring2_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = ring2_radius\n        count += 1\n    \n    # Remaining circles placed strategically\n    remaining_positions = [\n        [0.12, 0.12, 0.075],  # Bottom left corner\n        [0.88, 0.12, 0.075],  # Bottom right corner\n        [0.12, 0.88, 0.075],  # Top left corner\n        [0.88, 0.88, 0.075],  # Top right corner\n        [0.5, 0.08, 0.07],    # Bottom middle\n        [0.5, 0.92, 0.07],    # Top middle\n        [0.08, 0.5, 0.07],    # Left middle\n        [0.92, 0.5, 0.07],    # Right middle\n        [0.3, 0.3, 0.08]      # Additional circle\n    ]\n    \n    for i, (x, y, r) in enumerate(remaining_positions):\n        if count < n:\n            centers[count] = [x, y]\n            radii[count] = r\n            count += 1\n    \n    return centers, radii\n\n\ndef initialize_hexagonal_pattern(n):\n    \"\"\"\n    Initialize with an optimized hexagonal pattern with variable sizes.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.12\n    \n    # First hexagonal ring (6 circles)\n    count = 1\n    ring1_radius = 0.1\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[0] + ring1_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = ring1_radius\n        count += 1\n    \n    # Second hexagonal ring (12 circles)\n    ring2_radius = 0.085\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + np.pi/12  # Offset\n        dist = radii[0] + 2 * ring1_radius + ring2_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = ring2_radius\n        count += 1\n    \n    # Place remaining circles in corners and edges\n    if count < n:\n        # Corner circles\n        corner_radius = 0.07\n        corners = [[corner_radius, corner_radius], \n                   [1-corner_radius, corner_radius], \n                   [corner_radius, 1-corner_radius], \n                   [1-corner_radius, 1-corner_radius]]\n        \n        for i in range(min(4, n-count)):\n            centers[count] = corners[i]\n            radii[count] = corner_radius\n            count += 1\n    \n    # Fill remaining positions if needed\n    while count < n:\n        # Place randomly with bias toward empty areas\n        best_pos = [0.5, 0.5]\n        best_dist = 0\n        \n        for _ in range(20):  # Try 20 candidate positions\n            pos = np.random.rand(2)\n            min_dist = float('inf')\n            \n            for i in range(count):\n                dist = np.linalg.norm(pos - centers[i]) - radii[i]\n                min_dist = min(min_dist, dist)\n            \n            if min_dist > best_dist:\n                best_dist = min_dist\n                best_pos = pos\n        \n        centers[count] = best_pos\n        radii[count] = min(0.07, best_dist * 0.95)  # 95% of available space\n        count += 1\n    \n    return centers, radii\n\n\ndef initialize_concentric_rings(n):\n    \"\"\"\n    Initialize with concentric rings of circles with optimal size distribution.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.125\n    \n    # Define ring parameters: (num_circles, radius)\n    rings = [\n        (8, 0.1),     # First ring: 8 circles of radius 0.1\n        (12, 0.085),  # Second ring: 12 circles of radius 0.085\n        (5, 0.07)     # Third ring: 5 circles of radius 0.07\n    ]\n    \n    count = 1\n    for ring_idx, (num_circles, circle_radius) in enumerate(rings):\n        # Calculate distance from center for this ring\n        if ring_idx == 0:\n            ring_dist = radii[0] + circle_radius\n        else:\n            # Distance depends on previous ring\n            prev_radius = rings[ring_idx-1][1]\n            ring_dist += prev_radius + circle_radius\n        \n        # Place circles in this ring\n        for i in range(num_circles):\n            if count < n:\n                angle = 2 * np.pi * i / num_circles\n                if ring_idx > 0:  # Offset angles for non-first rings\n                    angle += np.pi / num_circles\n                \n                centers[count] = [\n                    0.5 + ring_dist * np.cos(angle),\n                    0.5 + ring_dist * np.sin(angle)\n                ]\n                radii[count] = circle_radius\n                count += 1\n    \n    # Place remaining circles in corners\n    if count < n:\n        corner_radius = 0.07\n        corners = [[corner_radius, corner_radius], \n                   [1-corner_radius, corner_radius], \n                   [corner_radius, 1-corner_radius], \n                   [1-corner_radius, 1-corner_radius]]\n        \n        for i in range(min(4, n-count)):\n            centers[count] = corners[i]\n            radii[count] = corner_radius\n            count += 1\n    \n    return centers, radii\n\n\ndef initialize_corner_optimized(n):\n    \"\"\"\n    Initialize with an arrangement that optimizes corner and edge utilization.\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Four corners\n    corner_radius = 0.09\n    corners = [[corner_radius, corner_radius], \n               [1-corner_radius, corner_radius], \n               [corner_radius, 1-corner_radius], \n               [1-corner_radius, 1-corner_radius]]\n    \n    for i in range(4):\n        centers[i] = corners[i]\n        radii[i] = corner_radius\n    \n    # Four edge midpoints\n    edge_radius = 0.08\n    edges = [[0.5, edge_radius], \n             [1-edge_radius, 0.5], \n             [0.5, 1-edge_radius], \n             [edge_radius, 0.5]]\n    \n    for i in range(4):\n        centers[i+4] = edges[i]\n        radii[i+4] = edge_radius\n    \n    # Central large circle\n    centers[8] = [0.5, 0.5]\n    radii[8] = 0.12\n    \n    # Inner ring around central circle\n    inner_radius = 0.095\n    count = 9\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        dist = radii[8] + inner_radius\n        centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n        radii[count] = inner_radius\n        count += 1\n    \n    # Middle ring\n    middle_radius = 0.085\n    for i in range(12):\n        if count < n:\n            angle = 2 * np.pi * i / 12 + np.pi/12\n            dist = radii[8] + 2 * inner_radius + middle_radius\n            centers[count] = [0.5 + dist * np.cos(angle), 0.5 + dist * np.sin(angle)]\n            radii[count] = middle_radius\n            count += 1\n    \n    return centers, radii\n\n\ndef optimize_stage1(centers, radii, iterations):\n    \"\"\"\n    First optimization stage: Resolve overlaps and establish basic structure\n    using physics-based model with adaptive parameters.\n    \"\"\"\n    n = len(centers)\n    velocity = np.zeros_like(centers)\n    repulsion_strength = 30.0\n    wall_repulsion = 30.0\n    dt = 0.01\n    dampening = 0.92\n    \n    for iter in range(iterations):\n        forces = np.zeros_like(centers)\n        progress = iter / iterations\n        \n        # Adaptive parameters based on progress\n        local_repulsion = repulsion_strength * (1.0 + progress)\n        local_wall = wall_repulsion * (1.0 + 0.5 * progress)\n        \n        # Circle-circle repulsion with efficient distance calculation\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist_vec = centers[i] - centers[j]\n                dist_sq = np.sum(dist_vec * dist_vec)  # Squared distance\n                min_dist = radii[i] + radii[j]\n                \n                if dist_sq < min_dist * min_dist:\n                    dist = np.sqrt(dist_sq)  # Only compute sqrt when needed\n                    overlap = min_dist - dist\n                    direction = dist_vec / (dist + 1e-8)\n                    force = local_repulsion * overlap * direction\n                    forces[i] += force\n                    forces[j] -= force\n        \n        # Wall repulsion with soft boundary\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Soft boundary function that increases force as circles approach edges\n            if x < r:\n                forces[i, 0] += local_wall * (r - x) / (x + 0.01)\n            if x > 1 - r:\n                forces[i, 0] -= local_wall * (x - (1 - r)) / (1.01 - x)\n            if y < r:\n                forces[i, 1] += local_wall * (r - y) / (y + 0.01)\n            if y > 1 - r:\n                forces[i, 1] -= local_wall * (y - (1 - r)) / (1.01 - y)\n        \n        # Update positions using velocity Verlet integration\n        velocity = dampening * (velocity + forces * dt)\n        centers += velocity * dt\n        \n        # Add small random perturbation every few iterations\n        if iter % 25 == 0 and iter < iterations * 0.7:\n            centers += np.random.normal(0, 0.003 * (1 - progress), centers.shape)\n        \n        # Keep circles within bounds\n        for i in range(n):\n            centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n            centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n    \n    return centers, radii\n\n\ndef optimize_stage2(centers, radii, iterations):\n    \"\"\"\n    Second optimization stage: Grow radii while maintaining valid packing\n    with adaptive growth rates.\n    \"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # Base growth rates for different circle types\n    base_growth_rate = 0.0005\n    \n    for iter in range(iterations):\n        # Calculate available space for each circle\n        available_space = np.ones(n) * float('inf')\n        \n        # Space limited by other circles\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    space = dist - radii[j]\n                    available_space[i] = min(available_space[i], space)\n        \n        # Space limited by walls\n        for i in range(n):\n            x, y = centers[i]\n            wall_space = min(x, y, 1-x, 1-y)\n            available_space[i] = min(available_space[i], wall_space)\n        \n        # Adaptive growth based on position and available space\n        growth_happened = False\n        for i in range(n):\n            # Calculate distance from center of square\n            dist_from_center = np.linalg.norm(centers[i] - 0.5)\n            \n            # Adjust growth rate based on position - favor central circles\n            position_factor = 1.0 - 0.3 * dist_from_center\n            \n            # Calculate growth potential\n            growth_potential = available_space[i] - radii[i]\n            \n            if growth_potential > 0.0001:  # Only grow if there's space\n                # Adaptive growth rate\n                growth_rate = base_growth_rate * position_factor\n                \n                # Grow radius\n                growth_amount = min(growth_rate, growth_potential * 0.5)\n                radii[i] += growth_amount\n                growth_happened = growth_amount > 0\n        \n        # Resolve any overlaps that might occur\n        centers, radii = resolve_overlaps(centers, radii)\n        \n        # Keep track of best configuration\n        sum_radii = np.sum(radii)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n        \n        # Early stopping if no growth is happening\n        if not growth_happened and iter > iterations // 2:\n            break\n    \n    return best_centers, best_radii\n\n\ndef optimize_stage3(centers, radii, iterations):\n    \"\"\"\n    Third optimization stage: Fine-tune positions and sizes\n    using simulated annealing with adaptive parameters.\n    \"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    temperature = 0.01\n    cooling_rate = 0.995\n    \n    # Adaptive perturbation parameters\n    position_perturbation_base = 0.002\n    radius_perturbation_base = 0.0007\n    \n    for iter in range(iterations):\n        progress = iter / iterations\n        \n        # Adaptive perturbation sizes\n        position_perturbation = position_perturbation_base * (1.0 - 0.7 * progress)\n        radius_perturbation = radius_perturbation_base * (1.0 - 0.7 * progress)\n        \n        # Make a copy of current state\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Choose perturbation strategy\n        strategy = np.random.choice([0, 1, 2], p=[0.6, 0.3, 0.1])\n        \n        if strategy == 0:\n            # Perturb single circle\n            idx = np.random.randint(0, n)\n            new_centers[idx] += np.random.normal(0, position_perturbation, 2)\n            new_radii[idx] = max(0.01, new_radii[idx] + np.random.normal(0, radius_perturbation))\n            \n            # Keep circle within bounds\n            new_centers[idx, 0] = np.clip(new_centers[idx, 0], new_radii[idx], 1 - new_radii[idx])\n            new_centers[idx, 1] = np.clip(new_centers[idx, 1], new_radii[idx], 1 - new_radii[idx])\n            \n        elif strategy == 1:\n            # Perturb a pair of adjacent circles\n            idx1 = np.random.randint(0, n)\n            \n            # Find closest circle to idx1\n            min_dist = float('inf')\n            idx2 = idx1\n            for j in range(n):\n                if j != idx1:\n                    dist = np.linalg.norm(centers[idx1] - centers[j])\n                    if dist < min_dist:\n                        min_dist = dist\n                        idx2 = j\n            \n            # Perturb both circles in opposite directions\n            perturb = np.random.normal(0, position_perturbation, 2)\n            new_centers[idx1] += perturb\n            new_centers[idx2] -= perturb\n            \n            # Keep circles within bounds\n            for idx in [idx1, idx2]:\n                new_centers[idx, 0] = np.clip(new_centers[idx, 0], new_radii[idx], 1 - new_radii[idx])\n                new_centers[idx, 1] = np.clip(new_centers[idx, 1], new_radii[idx], 1 - new_radii[idx])\n            \n        else:\n            # Redistribute radius between two circles\n            idx1, idx2 = np.random.choice(n, 2, replace=False)\n            transfer = np.random.normal(0, radius_perturbation)\n            \n            new_radii[idx1] = max(0.01, new_radii[idx1] + transfer)\n            new_radii[idx2] = max(0.01, new_radii[idx2] - transfer)\n        \n        # Check for validity\n        valid = is_valid_packing(new_centers, new_radii)\n        \n        # Accept or reject based on simulated annealing\n        if valid:\n            new_sum = np.sum(new_radii)\n            delta_e = new_sum - np.sum(radii)\n            \n            if delta_e > 0 or np.random.random() < np.exp(delta_e / temperature):\n                centers = new_centers.copy()\n                radii = new_radii.copy()\n                \n                if new_sum > best_sum:\n                    best_sum = new_sum\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n        \n        # Cool temperature\n        temperature *= cooling_rate\n        \n        # Periodically optimize all radii\n        if iter % 30 == 0:\n            centers, radii = optimize_all_radii(centers, radii)\n            sum_radii = np.sum(radii)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n    \n    return best_centers, best_radii\n\n\ndef is_valid_packing(centers, radii):\n    \"\"\"\n    Check if a packing is valid (no overlaps).\n    Optimized for performance with early exit.\n    \"\"\"\n    n = len(centers)\n    \n    # Check circle-circle overlaps\n    for i in range(n):\n        # Check wall constraints first (faster)\n        x, y = centers[i]\n        r = radii[i]\n        if x < r or x > 1-r or y < r or y > 1-r:\n            return False\n        \n        # Check circle overlaps\n        for j in range(i+1, n):\n            dist_sq = np.sum((centers[i] - centers[j])**2)\n            min_dist = radii[i] + radii[j]\n            if dist_sq < min_dist**2 - 1e-10:  # Small epsilon for numerical stability\n                return False\n    \n    return True\n\n\ndef resolve_overlaps(centers, radii):\n    \"\"\"\n    Resolve any overlaps in the packing by iteratively\n    adjusting positions and sizes.\n    \"\"\"\n    n = len(centers)\n    max_iterations = 20\n    \n    for _ in range(max_iterations):\n        has_overlap = False\n        \n        # Check and resolve circle-circle overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist - 1e-10:\n                    has_overlap = True\n                    \n                    # Calculate overlap\n                    overlap = min_dist - dist\n                    direction = (centers[i] - centers[j]) / (dist + 1e-10)\n                    \n                    # Move circles apart\n                    move_i = 0.5 * overlap * direction\n                    move_j = -0.5 * overlap * direction\n                    \n                    centers[i] += move_i\n                    centers[j] += move_j\n                    \n                    # Ensure circles stay within bounds\n                    for idx, move in [(i, move_i), (j, move_j)]:\n                        if centers[idx, 0] < radii[idx]:\n                            centers[idx, 0] = radii[idx]\n                        elif centers[idx, 0] > 1 - radii[idx]:\n                            centers[idx, 0] = 1 - radii[idx]\n                            \n                        if centers[idx, 1] < radii[idx]:\n                            centers[idx, 1] = radii[idx]\n                        elif centers[idx, 1] > 1 - radii[idx]:\n                            centers[idx, 1] = 1 - radii[idx]\n        \n        # Check and resolve wall overlaps\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            \n            if x < r:\n                centers[i, 0] = r\n                has_overlap = True\n            elif x > 1 - r:\n                centers[i, 0] = 1 - r\n                has_overlap = True\n                \n            if y < r:\n                centers[i, 1] = r\n                has_overlap = True\n            elif y > 1 - r:\n                centers[i, 1] = 1 - r\n                has_overlap = True\n        \n        # If no overlaps, we're done\n        if not has_overlap:\n            break\n    \n    return centers, radii\n\n\ndef optimize_all_radii(centers, radii):\n    \"\"\"\n    Optimize all radii to fill available space with improved efficiency.\n    \"\"\"\n    n = len(centers)\n    \n    # Pre-calculate all pairwise distances\n    distances = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1, n):\n            distances[i, j] = distances[j, i] = np.linalg.norm(centers[i] - centers[j])\n    \n    # Calculate wall distances\n    wall_distances = np.zeros(n)\n    for i in range(n):\n        x, y = centers[i]\n        wall_distances[i] = min(x, y, 1-x, 1-y)\n    \n    # Iteratively optimize radii\n    for _ in range(3):  # Fewer iterations for speed\n        for i in range(n):\n            # Find minimum distance to other circles\n            min_dist_to_others = float('inf')\n            for j in range(n):\n                if i != j:\n                    dist = distances[i, j] - radii[j]\n                    min_dist_to_others = min(min_dist_to_others, dist"]}}}