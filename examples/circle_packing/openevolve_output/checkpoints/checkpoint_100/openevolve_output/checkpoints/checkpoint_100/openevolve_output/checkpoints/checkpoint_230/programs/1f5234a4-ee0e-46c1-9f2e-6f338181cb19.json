{"id": "1f5234a4-ee0e-46c1-9f2e-6f338181cb19", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns, multi-stage optimization, and gradient-based refinement\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport math\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Start with multiple different initial configurations and pick the best\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try different initialization strategies\n    strategies = [\n        initialize_hexagonal_pattern,\n        initialize_corner_heavy_pattern,\n        initialize_specialized_pattern\n    ]\n    \n    for init_strategy in strategies:\n        centers, radii = init_strategy(n)\n        centers, radii = optimize_packing(centers, radii)\n        centers, radii = ensure_valid_packing(centers, radii)\n        \n        sum_radii = np.sum(radii)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Final optimization on the best configuration using gradient descent\n    best_centers, best_radii = global_numerical_optimization(best_centers, best_radii)\n    best_centers, best_radii = ensure_valid_packing(best_centers, best_radii)\n    \n    sum_radii = np.sum(best_radii)\n    return best_centers, best_radii, sum_radii\n\n\ndef initialize_hexagonal_pattern(n):\n    \"\"\"\n    Initialize circle positions using a hexagonal packing pattern\n    \"\"\"\n    centers = np.zeros((n, 2))\n    \n    # Hexagonal grid parameters with better aspect ratio handling\n    aspect_ratio = 1.0  # Unit square\n    rows = int(np.floor(np.sqrt(n / aspect_ratio)))\n    cols = int(np.ceil(n / rows))\n\n    dx = 1.0 / cols\n    dy = aspect_ratio / rows\n\n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if count < n:\n                x = (j + 0.5 + (i % 2) * 0.5) * dx\n                y = (i + 0.5) * dy\n                centers[count] = [x, y]\n                count += 1\n    \n    # Initialize all radii equally\n    initial_radius = 0.45 / max(rows, cols) # Dynamically set based on grid size\n    radii = np.ones(n) * initial_radius\n    \n    return centers, radii\n\n\ndef initialize_corner_heavy_pattern(n):\n    \"\"\"\n    Initialize with larger circles in corners and edges\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place 4 large circles in corners\n    corner_positions = np.array([\n        [0.11, 0.11],\n        [0.89, 0.11],\n        [0.11, 0.89],\n        [0.89, 0.89]\n    ])\n    centers[:4] = corner_positions\n    radii[:4] = 0.11\n    \n    # Place 4 medium circles at midpoints of edges\n    edge_positions = np.array([\n        [0.5, 0.11],\n        [0.5, 0.89],\n        [0.11, 0.5],\n        [0.89, 0.5]\n    ])\n    centers[4:8] = edge_positions\n    radii[4:8] = 0.10\n    \n    # Place remaining circles in a more strategic grid\n    remaining = n - 8\n    grid_rows = int(np.floor(np.sqrt(remaining)))\n    grid_cols = int(np.ceil(remaining / grid_rows))\n\n    count = 8\n    for i in range(grid_rows):\n        for j in range(grid_cols):\n            if count < n:\n                x = 0.2 + (0.6 / (grid_cols - 1)) * j if grid_cols > 1 else 0.5\n                y = 0.2 + (0.6 / (grid_rows - 1)) * i if grid_rows > 1 else 0.5\n                centers[count] = [x, y]\n                radii[count] = 0.085\n                count += 1\n    \n    return centers, radii\n\n\ndef initialize_specialized_pattern(n):\n    \"\"\"\n    Initialize with a specialized pattern for n=26 based on mathematical insights\n    \"\"\"\n    # Create a base grid of positions\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Optimized placement for n=26\n    radii[0:1] = 0.086981\n    centers[0] = [0.500000,0.500000]\n\n    radii[1:5] = 0.106889\n    centers[1] = [0.207107,0.207107]\n    centers[2] = [0.792893,0.207107]\n    centers[3] = [0.207107,0.792893]\n    centers[4] = [0.792893,0.792893]\n\n    radii[5:9] = 0.079625\n    centers[5] = [0.500000,0.133975]\n    centers[6] = [0.866025,0.500000]\n    centers[7] = [0.500000,0.866025]\n    centers[8] = [0.133975,0.500000]\n\n    radii[9:17] = 0.067492\n    centers[9] = [0.333333,0.333333]\n    centers[10] = [0.666667,0.333333]\n    centers[11] = [0.333333,0.666667]\n    centers[12] = [0.666667,0.666667]\n    centers[13] = [0.933013,0.266987]\n    centers[14] = [0.933013,0.733013]\n    centers[15] = [0.066987,0.266987]\n    centers[16] = [0.066987,0.733013]\n\n    radii[17:26] = 0.060000\n    centers[17] = [0.500000,0.333333]\n    centers[18] = [0.666667,0.500000]\n    centers[19] = [0.500000,0.666667]\n    centers[20] = [0.333333,0.500000]\n    centers[21] = [0.733013,0.266987]\n    centers[22] = [0.733013,0.733013]\n    centers[23] = [0.266987,0.266987]\n    centers[24] = [0.266987,0.733013]\n    centers[25] = [0.500000,0.566667]\n    \n    return centers, radii\n\n\ndef optimize_packing(centers, radii, iterations=2):\n    \"\"\"\n    Multi-stage optimization to maximize the sum of radii\n    \"\"\"\n    n = len(centers)\n    \n    # Perform several iterations of optimization\n    for _ in range(iterations):\n        # First optimize positions with fixed radii\n        centers = optimize_positions(centers, radii)\n        \n        # Then optimize radii with fixed positions\n        radii = optimize_radii(centers, radii)\n        \n        # Resolve any overlaps\n        centers, radii = resolve_overlaps(centers, radii)\n    \n    return centers, radii\n\n\ndef optimize_positions(centers, radii, iterations=150):\n    \"\"\"\n    Optimize circle positions while keeping radii fixed using a physics-based approach\n    \"\"\"\n    n = len(centers)\n    \n    # Parameters for the physics-based optimization\n    repulsion_strength = 20.0  # Increased repulsion strength\n    attraction_strength = 0.05 # Reduced attraction strength\n    wall_repulsion = 30.0       # Increased wall repulsion\n    \n    # Velocity and dampening for the physics simulation\n    velocity = np.zeros_like(centers)\n    dampening = 0.8  # Increased dampening\n    dt = 0.01\n    \n    for _ in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        # Circle-circle interactions\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist_vec = centers[i] - centers[j]\n                dist = np.linalg.norm(dist_vec)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist:\n                    # Repulsive force when overlapping\n                    overlap = min_dist - dist\n                    direction = dist_vec / (dist + 1e-10)\n                    \n                    # Apply stronger repulsion to resolve overlaps\n                    force_mag = repulsion_strength * overlap\n                    forces[i] += force_mag * direction\n                    forces[j] -= force_mag * direction\n                else:\n                    # Slight attractive force when not overlapping but close\n                    gap = dist - min_dist\n                    if gap < 0.04:  # Reduced attraction range\n                        direction = dist_vec / (dist + 1e-10)\n                        force_mag = attraction_strength * gap\n                        forces[i] -= force_mag * direction\n                        forces[j] += force_mag * direction\n        \n        # Wall constraints - strong repulsion from walls\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Distance to walls\n            dist_left = x - r\n            dist_right = 1 - r - x\n            dist_bottom = y - r\n            dist_top = 1 - r - y\n            \n            # Apply repulsive forces from walls\n            if dist_left < 0:\n                forces[i, 0] += wall_repulsion * abs(dist_left)\n            if dist_right < 0:\n                forces[i, 0] -= wall_repulsion * abs(dist_right)\n            if dist_bottom < 0:\n                forces[i, 1] += wall_repulsion * abs(dist_bottom)\n            if dist_top < 0:\n                forces[i, 1] -= wall_repulsion * abs(dist_top)\n        \n        # Update velocities and positions\n        velocity = dampening * velocity + forces * dt\n        centers += velocity * dt\n        \n        # Ensure circles stay within bounds\n        for i in range(n):\n            r = radii[i]\n            centers[i, 0] = np.clip(centers[i, 0], r, 1 - r)\n            centers[i, 1] = np.clip(centers[i, 1], r, 1 - r)\n    \n    return centers\n\n\ndef optimize_radii(centers, radii, iterations=100):\n    \"\"\"\n    Optimize circle radii while keeping positions fixed\n    \"\"\"\n    n = len(centers)\n    \n    # Calculate distance matrix between all circles\n    dist_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            dist_matrix[i, j] = dist_matrix[j, i] = dist\n    \n    # Calculate distance to walls for each circle\n    wall_dists = np.zeros((n, 4))  # left, right, bottom, top\n    for i in range(n):\n        x, y = centers[i]\n        wall_dists[i, 0] = x          # left wall\n        wall_dists[i, 1] = 1 - x      # right wall\n        wall_dists[i, 2] = y          # bottom wall\n        wall_dists[i, 3] = 1 - y      # top wall\n    \n    # Iteratively grow all circles\n    for _ in range(iterations):\n        # Calculate maximum possible radius for each circle\n        max_radii = np.ones(n) * float('inf')\n        \n        # Limit by walls\n        for i in range(n):\n            max_radii[i] = min(max_radii[i], np.min(wall_dists[i]))\n        \n        # Limit by other circles\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    max_from_j = dist_matrix[i, j] - radii[j]\n                    max_radii[i] = min(max_radii[i], max_from_j)\n        \n        # Grow each circle to its maximum radius (with a small safety margin)\n        for i in range(n):\n            radii[i] = max_radii[i] - 1e-10\n    \n    return radii\n\n\ndef global_numerical_optimization(centers, radii):\n    \"\"\"\n    Use numerical optimization to fine-tune the packing using gradient descent\n    \"\"\"\n    n = len(centers)\n    \n    # Create parameter vector for optimization\n    params = np.concatenate([centers.flatten(), radii])\n    \n    # Define bounds\n    bounds = []\n    # Position bounds\n    for i in range(n):\n        r = radii[i]\n        bounds.append((r, 1-r))  # x bounds\n        bounds.append((r, 1-r))  # y bounds\n    \n    # Radius bounds - allow them to vary but keep minimum size\n    min_radius = 0.01\n    for i in range(n):\n        bounds.append((min_radius, 0.5))  # radius bounds\n    \n    # Define objective function to maximize sum of radii\n    def objective(params):\n        # Extract positions and radii\n        pos = params[:2*n].reshape(n, 2)\n        rad = params[2*n:]\n        \n        # Penalty for invalid configurations\n        penalty = 0\n        \n        # Check if all circles are within bounds\n        for i in range(n):\n            x, y = pos[i]\n            r = rad[i]\n            \n            if x - r < 0:\n                penalty += (x - r) ** 2 * 1000\n            if x + r > 1:\n                penalty += (x + r - 1) ** 2 * 1000\n            if y - r < 0:\n                penalty += (y - r) ** 2 * 1000\n            if y + r > 1:\n                penalty += (y + r - 1) ** 2 * 1000\n        \n        # Check for overlaps between circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(pos[i] - pos[j])\n                min_dist = rad[i] + rad[j]\n                \n                if dist < min_dist:\n                    penalty += (min_dist - dist) ** 2 * 1000\n        \n        # Return negative sum (for minimization) with penalty\n        return -np.sum(rad) + penalty\n    \n    # Use a constrained optimization method (L-BFGS-B)\n    try:\n        result = minimize(\n            objective,\n            params,\n            method='L-BFGS-B',\n            jac=None,  # Let scipy estimate the Jacobian\n            bounds=bounds,\n            options={'maxiter': 200, 'ftol': 1e-6, 'gtol': 1e-6} # Increased iterations and tighter tolerances\n        )\n        \n        # Extract optimized parameters\n        optimized_params = result.x\n        optimized_centers = optimized_params[:2*n].reshape(n, 2)\n        optimized_radii = optimized_params[2*n:]\n        \n        # Ensure the result is valid\n        if is_valid_configuration(optimized_centers, optimized_radii):\n            centers, radii = optimized_centers, optimized_radii\n        \n    except Exception as e:\n        # If optimization fails, keep the original configuration and print the error\n        print(f\"Numerical optimization failed: {e}\")\n        pass\n    \n    return centers, radii\n\n\ndef is_valid_configuration(centers, radii):\n    \"\"\"\n    Check if a configuration is valid (no overlaps, all circles within bounds)\n    \"\"\"\n    n = len(centers)\n    \n    # Check if all circles are within bounds\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        \n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n    \n    # Check for overlaps between circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-9: # Reduced tolerance\n                return False\n    \n    return True\n\n\ndef resolve_overlaps(centers, radii, iterations=15):\n    \"\"\"\n    Resolve any overlaps by adjusting positions and radii\n    \"\"\"\n    n = len(centers)\n    \n    for _ in range(iterations):\n        overlap_exists = False\n        \n        # Check and resolve circle-circle overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist - 1e-10:\n                    overlap_exists = True\n                    \n                    # Calculate overlap amount\n                    overlap = min_dist - dist\n                    \n                    # Adjust positions to resolve overlap\n                    direction = (centers[i] - centers[j]) / (dist + 1e-10)\n                    \n                    # Move circles apart proportionally to their radii\n                    weight_i = radii[j] / (radii[i] + radii[j])\n                    weight_j = radii[i] / (radii[i] + radii[j])\n                    \n                    centers[i] += direction * overlap * weight_i * 0.5\n                    centers[j] -= direction * overlap * weight_j * 0.5\n                    \n                    # Also slightly reduce radii to help resolve difficult overlaps\n                    radii[i] -= overlap * 0.1 * weight_i\n                    radii[j] -= overlap * 0.1 * weight_j\n                    \n                    # Ensure minimum radius\n                    radii[i] = max(0.01, radii[i])\n                    radii[j] = max(0.01, radii[j])\n        \n        # Check and resolve circle-wall overlaps\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Left wall\n            if x < r:\n                overlap_exists = True\n                centers[i, 0] = r\n            \n            # Right wall\n            if x > 1 - r:\n                overlap_exists = True\n                centers[i, 0] = 1 - r\n            \n            # Bottom wall\n            if y < r:\n                overlap_exists = True\n                centers[i, 1] = r\n            \n            # Top wall\n            if y > 1 - r:\n                overlap_exists = True\n                centers[i, 1] = 1 - r\n        \n        if not overlap_exists:\n            break\n    \n    return centers, radii\n\n\ndef ensure_valid_packing(centers, radii):\n    \"\"\"\n    Final validation to ensure the packing is valid and maximize radii\n    \"\"\"\n    n = len(centers)\n    \n    # First resolve any remaining overlaps\n    centers, radii = resolve_overlaps(centers, radii, iterations=20)\n    \n    # Calculate distance matrix between all circles\n    dist_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            dist_matrix[i, j] = dist_matrix[j, i] = dist\n    \n    # Calculate distance to walls for each circle\n    wall_dists = np.zeros((n, 4))  # left, right, bottom, top\n    for i in range(n):\n        x, y = centers[i]\n        wall_dists[i, 0] = x          # left wall\n        wall_dists[i, 1] = 1 - x      # right wall\n        wall_dists[i, 2] = y          # bottom wall\n        wall_dists[i, 3] = 1 - y      # top wall\n    \n    # Final radius optimization\n    for i in range(n):\n        # Limit by walls\n        max_r = np.min(wall_dists[i])\n        \n        # Limit by other circles\n        for j in range(n):\n            if i != j:\n                max_from_j = dist_matrix[i, j] - radii[j]\n                max_r = min(max_r, max_from_j)\n        \n        # Set radius to maximum possible value (with a small safety margin)\n        radii[i] = max_r - 1e-10\n    \n    # Apply specialized pattern adjustment for n=26 - REMOVED as causing issues.\n    # centers, radii = apply_specialized_adjustment(centers, radii)\n    \n    return centers, radii\n\n\ndef apply_specialized_adjustment(centers, radii):\n    \"\"\"\n    Apply specialized adjustments based on mathematical insights for n=26 - REMOVED as causing issues.\n    \"\"\"\n    n = len(centers)\n    \n    # Sort circles by distance from center\n    center_point = np.array([0.5, 0.5])\n    distances = np.array([np.linalg.norm(center - center_point) for center in centers])\n    sorted_indices = np.argsort(distances)\n    \n    # Identify circles in different regions\n    center_indices = sorted_indices[:1]  # Center circle\n    inner_ring_indices = sorted_indices[1:9]  # Inner ring (8 circles)\n    middle_ring_indices = sorted_indices[9:17]  # Middle ring (8 circles)\n    outer_indices = sorted_indices[17:]  # Outer circles (9 circles)\n    \n    # Calculate distance matrix between all circles\n    dist_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            dist_matrix[i, j] = dist_matrix[j, i] = dist\n    \n    # Calculate wall distances\n    wall_dists = np.zeros((n, 4))  # left, right, bottom, top\n    for i in range(n):\n        x, y = centers[i]\n        wall_dists[i, 0] = x          # left wall\n        wall_dists[i, 1] = 1 - x      # right wall\n        wall_dists[i, 2] = y          # bottom wall\n        wall_dists[i, 3] = 1 - y      # top wall\n    \n    # Apply specialized adjustments\n    \n    # 1. Optimize corner circles first (they tend to be larger)\n    corner_threshold = 0.3  # Distance from corner to identify corner circles\n    corner_indices = []\n    corners = [(0,0), (0,1), (1,0), (1,1)]\n    \n    for i in range(n):\n        for cx, cy in corners:\n            dist = np.linalg.norm(centers[i] - np.array([cx, cy]))\n            if dist < corner_threshold:\n                corner_indices.append(i)\n                break\n    \n    for idx in corner_indices:\n        # Calculate maximum possible radius\n        max_r = np.min(wall_dists[idx])\n        for j in range(n):\n            if idx != j:\n                max_from_j = dist_matrix[idx, j] - radii[j]\n                max_r = min(max_r, max_from_j)\n        \n        radii[idx] = max_r - 1e-10\n    \n    # 2. Then optimize edge circles\n    edge_threshold = 0.15  # Distance from edge to identify edge circles\n    edge_indices = []\n    \n    for i in range(n):\n        if i in corner_indices:\n            continue\n        \n        x, y = centers[i]\n        min_wall_dist = min(x, y, 1-x, 1-y)\n        if min_wall_dist < edge_threshold:\n            edge_indices.append(i)\n    \n    for idx in edge_indices:\n        # Calculate maximum possible radius\n        max_r = np.min(wall_dists[idx])\n        for j in range(n):\n            if idx != j:\n                max_from_j = dist_matrix[idx, j] - radii[j]\n                max_r = min(max_r, max_from_j)\n        \n        radii[idx] = max_r - 1e-10\n    \n    # 3. Optimize inner circles\n    inner_indices = list(set(range(n)) - set(corner_indices) - set(edge_indices))\n    \n    for idx in inner_indices:\n        # Calculate maximum possible radius\n        max_r = np.min(wall_dists[idx])\n        for j in range(n):\n            if idx != j:\n                max_from_j = dist_matrix[idx, j] - radii[j]\n                max_r = min(max_r, max_from_j)\n        \n        radii[idx] = max_r - 1e-10\n    \n    # Final overlap resolution\n    centers, radii = resolve_overlaps(centers, radii, iterations=5)\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "17209a38-df09-44f1-9c0e-6ec5ce8382f1", "generation": 6, "timestamp": 1750804693.9530663, "iteration_found": 184, "metrics": {"validity": 1.0, "sum_radii": 2.1820242402109735, "target_ratio": 0.8280926907821532, "combined_score": 0.8280926907821532, "eval_time": 26.25919222831726}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.3209868767467055, "target_ratio": 0.8808299342492242, "combined_score": 0.8808299342492242, "eval_time": 20.70037865638733}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.637 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.412, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - validity: 1.0000\n- sum_radii: 2.3210\n- target_ratio: 0.8808\n- combined_score: 0.8808\n- eval_time: 20.7004\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: sum_radii, target_ratio, combined_score, eval_time. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.6181, target_ratio: 0.9936, combined_score: 0.9936, eval_time: 96.8205\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.5839, target_ratio: 0.9806, combined_score: 0.9806, eval_time: 99.5983\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.5828, target_ratio: 0.9802, combined_score: 0.9802, eval_time: 100.4894\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 5.1220)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6360), Performs well on target_ratio (1.0004), Performs well on combined_score (1.0004), Performs well on eval_time (19.9734)\n\n\n### Program 2 (Score: 21.2065)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5828), Performs well on target_ratio (0.9802), Performs well on combined_score (0.9802), Performs well on eval_time (100.4894)\n\n\n### Program 3 (Score: 3.8160)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5883), Performs well on target_ratio (0.9823), Performs well on combined_score (0.9823), Performs well on eval_time (13.5269)\n\n\n### Program 4 (Score: 4.6197)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and optimization techniques\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns and optimization.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4335), Performs well on target_ratio (0.9235), Performs well on combined_score (0.9235), Performs well on eval_time (17.8182)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 7.1443)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# ... (truncated)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns and multi-stage optimization\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Start with multiple different initial configurations and pick the best\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try different initialization strategies\n    strategies = [\n        initialize_hexagonal_pattern,\n        initialize_corner_heavy_pattern,\n        initialize_specialized_pattern\n    ]\n    \n    for init_strategy in strategies:\n        centers, radii = init_strategy(n)\n        centers, radii = optimize_packing(centers, radii)\n        centers, radii = ensure_valid_packing(centers, radii)\n        \n        sum_radii = np.sum(radii)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Final optimization on the best configuration\n    best_centers, best_radii = global_numerical_optimization(best_centers, best_radii)\n    best_centers, best_radii = ensure_valid_packing(best_centers, best_radii)\n    \n    sum_radii = np.sum(best_radii)\n    return best_centers, best_radii, sum_radii\n\n\ndef initialize_hexagonal_pattern(n):\n    \"\"\"\n    Initialize circle positions using a hexagonal packing pattern\n    \"\"\"\n    centers = np.zeros((n, 2))\n    \n    # Hexagonal grid parameters\n    rows = int(np.ceil(np.sqrt(n)))\n    cols = int(np.ceil(n / rows))\n    \n    # Hexagonal offset\n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / rows\n    \n    # Place circles in a hexagonal grid\n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if count < n:\n                # Apply hexagonal offset for even rows\n                offset = (dx / 2) if (i % 2 == 0) else 0\n                centers[count] = [offset + j * dx + dx/2, i * dy + dy/2]\n                count += 1\n    \n    # Initialize all radii equally\n    initial_radius = 0.08\n    radii = np.ones(n) * initial_radius\n    \n    return centers, radii\n\n\ndef initialize_corner_heavy_pattern(n):\n    \"\"\"\n    Initialize with larger circles in corners and edges\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place 4 large circles in corners\n    corner_positions = np.array([\n        [0.12, 0.12],\n        [0.88, 0.12],\n        [0.12, 0.88],\n        [0.88, 0.88]\n    ])\n    centers[:4] = corner_positions\n    radii[:4] = 0.12\n    \n    # Place 4 medium circles at midpoints of edges\n    edge_positions = np.array([\n        [0.5, 0.12],\n        [0.5, 0.88],\n        [0.12, 0.5],\n        [0.88, 0.5]\n    ])\n    centers[4:8] = edge_positions\n    radii[4:8] = 0.11\n    \n    # Place remaining circles in a grid pattern\n    remaining = n - 8\n    grid_size = int(np.ceil(np.sqrt(remaining)))\n    \n    count = 8\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count < n:\n                x = 0.25 + 0.5 * (j / (grid_size - 1))\n                y = 0.25 + 0.5 * (i / (grid_size - 1))\n                centers[count] = [x, y]\n                radii[count] = 0.09\n                count += 1\n    \n    return centers, radii\n\n\ndef initialize_specialized_pattern(n):\n    \"\"\"\n    Initialize with a specialized pattern for n=26 based on mathematical insights\n    \"\"\"\n    # Create a base grid of positions\n    centers = np.zeros((n, 2))\n    \n    # Place 4 circles in corners\n    corner_positions = np.array([\n        [0.115, 0.115],\n        [0.885, 0.115],\n        [0.115, 0.885],\n        [0.885, 0.885]\n    ])\n    \n    # Place 4 circles at midpoints of edges\n    edge_positions = np.array([\n        [0.5, 0.105],\n        [0.5, 0.895],\n        [0.105, 0.5],\n        [0.895, 0.5]\n    ])\n    \n    # Place 8 circles in a ring around center\n    angle = np.linspace(0, 2*np.pi, 9)[:-1]  # 8 evenly spaced angles\n    radius = 0.3\n    ring_positions = np.column_stack([\n        0.5 + radius * np.cos(angle),\n        0.5 + radius * np.sin(angle)\n    ])\n    \n    # Place 9 circles in a smaller inner ring\n    angle_inner = np.linspace(0, 2*np.pi, 10)[:-1]  # 9 evenly spaced angles\n    radius_inner = 0.15\n    inner_ring_positions = np.column_stack([\n        0.5 + radius_inner * np.cos(angle_inner),\n        0.5 + radius_inner * np.sin(angle_inner)\n    ])\n    \n    # Place 1 circle at center\n    center_position = np.array([[0.5, 0.5]])\n    \n    # Combine all positions\n    positions = np.vstack([\n        corner_positions,      # 4 positions\n        edge_positions,        # 4 positions\n        ring_positions,        # 8 positions\n        inner_ring_positions,  # 9 positions\n        center_position        # 1 position\n    ])\n    \n    centers = positions[:n]\n    \n    # Initialize with variable-sized radii\n    radii = np.zeros(n)\n    \n    # Assign initial radii based on position pattern\n    radii[:4] = 0.115  # Corner circles\n    radii[4:8] = 0.105  # Edge circles\n    radii[8:16] = 0.09  # Outer ring circles\n    radii[16:25] = 0.08  # Inner ring circles\n    radii[25] = 0.07  # Center circle\n    \n    return centers, radii\n\n\ndef optimize_packing(centers, radii, iterations=2):\n    \"\"\"\n    Multi-stage optimization to maximize the sum of radii\n    \"\"\"\n    n = len(centers)\n    \n    # Perform several iterations of optimization\n    for _ in range(iterations):\n        # First optimize positions with fixed radii\n        centers = optimize_positions(centers, radii)\n        \n        # Then optimize radii with fixed positions\n        radii = optimize_radii(centers, radii)\n        \n        # Resolve any overlaps\n        centers, radii = resolve_overlaps(centers, radii)\n    \n    return centers, radii\n\n\ndef optimize_positions(centers, radii, iterations=150):\n    \"\"\"\n    Optimize circle positions while keeping radii fixed using a physics-based approach\n    \"\"\"\n    n = len(centers)\n    \n    # Parameters for the physics-based optimization\n    repulsion_strength = 15.0\n    attraction_strength = 0.08\n    wall_repulsion = 20.0\n    \n    # Velocity and dampening for the physics simulation\n    velocity = np.zeros_like(centers)\n    dampening = 0.7\n    dt = 0.01\n    \n    for _ in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        # Circle-circle interactions\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist_vec = centers[i] - centers[j]\n                dist = np.linalg.norm(dist_vec)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist:\n                    # Repulsive force when overlapping\n                    overlap = min_dist - dist\n                    direction = dist_vec / (dist + 1e-10)\n                    \n                    # Apply stronger repulsion to resolve overlaps\n                    force_mag = repulsion_strength * overlap\n                    forces[i] += force_mag * direction\n                    forces[j] -= force_mag * direction\n                else:\n                    # Slight attractive force when not overlapping but close\n                    gap = dist - min_dist\n                    if gap < 0.05:  # Only attract if relatively close\n                        direction = dist_vec / (dist + 1e-10)\n                        force_mag = attraction_strength * gap\n                        forces[i] -= force_mag * direction\n                        forces[j] += force_mag * direction\n        \n        # Wall constraints - strong repulsion from walls\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Distance to walls\n            dist_left = x - r\n            dist_right = 1 - r - x\n            dist_bottom = y - r\n            dist_top = 1 - r - y\n            \n            # Apply repulsive forces from walls\n            if dist_left < 0:\n                forces[i, 0] += wall_repulsion * abs(dist_left)\n            if dist_right < 0:\n                forces[i, 0] -= wall_repulsion * abs(dist_right)\n            if dist_bottom < 0:\n                forces[i, 1] += wall_repulsion * abs(dist_bottom)\n            if dist_top < 0:\n                forces[i, 1] -= wall_repulsion * abs(dist_top)\n        \n        # Update velocities and positions\n        velocity = dampening * velocity + forces * dt\n        centers += velocity * dt\n        \n        # Ensure circles stay within bounds\n        for i in range(n):\n            r = radii[i]\n            centers[i, 0] = np.clip(centers[i, 0], r, 1 - r)\n            centers[i, 1] = np.clip(centers[i, 1], r, 1 - r)\n    \n    return centers\n\n\ndef optimize_radii(centers, radii, iterations=100):\n    \"\"\"\n    Optimize circle radii while keeping positions fixed\n    \"\"\"\n    n = len(centers)\n    \n    # Calculate distance matrix between all circles\n    dist_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            dist_matrix[i, j] = dist_matrix[j, i] = dist\n    \n    # Calculate distance to walls for each circle\n    wall_dists = np.zeros((n, 4))  # left, right, bottom, top\n    for i in range(n):\n        x, y = centers[i]\n        wall_dists[i, 0] = x          # left wall\n        wall_dists[i, 1] = 1 - x      # right wall\n        wall_dists[i, 2] = y          # bottom wall\n        wall_dists[i, 3] = 1 - y      # top wall\n    \n    # Iteratively grow all circles\n    for _ in range(iterations):\n        # Calculate maximum possible radius for each circle\n        max_radii = np.ones(n) * float('inf')\n        \n        # Limit by walls\n        for i in range(n):\n            max_radii[i] = min(max_radii[i], np.min(wall_dists[i]))\n        \n        # Limit by other circles\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    max_from_j = dist_matrix[i, j] - radii[j]\n                    max_radii[i] = min(max_radii[i], max_from_j)\n        \n        # Grow each circle to its maximum radius (with a small safety margin)\n        for i in range(n):\n            radii[i] = max_radii[i] - 1e-10\n    \n    return radii\n\n\ndef global_numerical_optimization(centers, radii):\n    \"\"\"\n    Use numerical optimization to fine-tune the packing\n    \"\"\"\n    n = len(centers)\n    \n    # Create parameter vector for optimization\n    params = np.concatenate([centers.flatten(), radii])\n    \n    # Define bounds\n    bounds = []\n    # Position bounds\n    for i in range(n):\n        r = radii[i]\n        bounds.append((r, 1-r))  # x bounds\n        bounds.append((r, 1-r))  # y bounds\n    \n    # Radius bounds - allow them to vary but keep minimum size\n    min_radius = 0.01\n    for i in range(n):\n        bounds.append((min_radius, 0.5))  # radius bounds\n    \n    # Define objective function to maximize sum of radii\n    def objective(params):\n        # Extract positions and radii\n        pos = params[:2*n].reshape(n, 2)\n        rad = params[2*n:]\n        \n        # Penalty for invalid configurations\n        penalty = 0\n        \n        # Check if all circles are within bounds\n        for i in range(n):\n            x, y = pos[i]\n            r = rad[i]\n            \n            if x - r < 0:\n                penalty += (x - r) ** 2 * 1000\n            if x + r > 1:\n                penalty += (x + r - 1) ** 2 * 1000\n            if y - r < 0:\n                penalty += (y - r) ** 2 * 1000\n            if y + r > 1:\n                penalty += (y + r - 1) ** 2 * 1000\n        \n        # Check for overlaps between circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(pos[i] - pos[j])\n                min_dist = rad[i] + rad[j]\n                \n                if dist < min_dist:\n                    penalty += (min_dist - dist) ** 2 * 1000\n        \n        # Return negative sum (for minimization) with penalty\n        return -np.sum(rad) + penalty\n    \n    # Use a constrained optimization method\n    try:\n        result = minimize(\n            objective,\n            params,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 100}\n        )\n        \n        # Extract optimized parameters\n        optimized_params = result.x\n        optimized_centers = optimized_params[:2*n].reshape(n, 2)\n        optimized_radii = optimized_params[2*n:]\n        \n        # Ensure the result is valid\n        if is_valid_configuration(optimized_centers, optimized_radii):\n            centers, radii = optimized_centers, optimized_radii\n        \n    except Exception:\n        # If optimization fails, keep the original configuration\n        pass\n    \n    return centers, radii\n\n\ndef is_valid_configuration(centers, radii):\n    \"\"\"\n    Check if a configuration is valid (no overlaps, all circles within bounds)\n    \"\"\"\n    n = len(centers)\n    \n    # Check if all circles are within bounds\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        \n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n    \n    # Check for overlaps between circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\n\ndef resolve_overlaps(centers, radii, iterations=15):\n    \"\"\"\n    Resolve any overlaps by adjusting positions and radii\n    \"\"\"\n    n = len(centers)\n    \n    for _ in range(iterations):\n        overlap_exists = False\n        \n        # Check and resolve circle-circle overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist - 1e-10:\n                    overlap_exists = True\n                    \n                    # Calculate overlap amount\n                    overlap = min_dist - dist\n                    \n                    # Adjust positions to resolve overlap\n                    direction = (centers[i] - centers[j]) / (dist + 1e-10)\n                    \n                    # Move circles apart proportionally to their radii\n                    weight_i = radii[j] / (radii[i] + radii[j])\n                    weight_j = radii[i] / (radii[i] + radii[j])\n                    \n                    centers[i] += direction * overlap * weight_i * 0.5\n                    centers[j] -= direction * overlap * weight_j * 0.5\n                    \n                    # Also slightly reduce radii to help resolve difficult overlaps\n                    radii[i] -= overlap * 0.1 * weight_i\n                    radii[j] -= overlap * 0.1 * weight_j\n                    \n                    # Ensure minimum radius\n                    radii[i] = max(0.01, radii[i])\n                    radii[j] = max(0.01, radii[j])\n        \n        # Check and resolve circle-wall overlaps\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Left wall\n            if x < r:\n                overlap_exists = True\n                centers[i, 0] = r\n            \n            # Right wall\n            if x > 1 - r:\n                overlap_exists = True\n                centers[i, 0] = 1 - r\n            \n            # Bottom wall\n            if y < r:\n                overlap_exists = True\n                centers[i, 1] = r\n            \n            # Top wall\n            if y > 1 - r:\n                overlap_exists = True\n                centers[i, 1] = 1 - r\n        \n        if not overlap_exists:\n            break\n    \n    return centers, radii\n\n\ndef ensure_valid_packing(centers, radii):\n    \"\"\"\n    Final validation to ensure the packing is valid and maximize radii\n    \"\"\"\n    n = len(centers)\n    \n    # First resolve any remaining overlaps\n    centers, radii = resolve_overlaps(centers, radii, iterations=20)\n    \n    # Calculate distance matrix between all circles\n    dist_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            dist_matrix[i, j] = dist_matrix[j, i] = dist\n    \n    # Calculate distance to walls for each circle\n    wall_dists = np.zeros((n, 4))  # left, right, bottom, top\n    for i in range(n):\n        x, y = centers[i]\n        wall_dists[i, 0] = x          # left wall\n        wall_dists[i, 1] = 1 - x      # right wall\n        wall_dists[i, 2] = y          # bottom wall\n        wall_dists[i, 3] = 1 - y      # top wall\n    \n    # Final radius optimization\n    for i in range(n):\n        # Limit by walls\n        max_r = np.min(wall_dists[i])\n        \n        # Limit by other circles\n        for j in range(n):\n            if i != j:\n                max_from_j = dist_matrix[i, j] - radii[j]\n                max_r = min(max_r, max_from_j)\n        \n        # Set radius to maximum possible value (with a small safety margin)\n        radii[i] = max_r - 1e-10\n    \n    # Apply specialized pattern adjustment for n=26\n    centers, radii = apply_specialized_adjustment(centers, radii)\n    \n    return centers, radii\n\n\ndef apply_specialized_adjustment(centers, radii):\n    \"\"\"\n    Apply specialized adjustments based on mathematical insights for n=26\n    \"\"\"\n    n = len(centers)\n    \n    # Sort circles by distance from center\n    center_point = np.array([0.5, 0.5])\n    distances = np.array([np.linalg.norm(center - center_point) for center in centers])\n    sorted_indices = np.argsort(distances)\n    \n    # Identify circles in different regions\n    center_indices = sorted_indices[:1]  # Center circle\n    inner_ring_indices = sorted_indices[1:9]  # Inner ring (8 circles)\n    middle_ring_indices = sorted_indices[9:17]  # Middle ring (8 circles)\n    outer_indices = sorted_indices[17:]  # Outer circles (9 circles)\n    \n    # Calculate distance matrix between all circles\n    dist_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            dist_matrix[i, j] = dist_matrix[j, i] = dist\n    \n    # Calculate wall distances\n    wall_dists = np.zeros((n, 4))  # left, right, bottom, top\n    for i in range(n):\n        x, y = centers[i]\n        wall_dists[i, 0] = x          # left wall\n        wall_dists[i, 1] = 1 - x      # right wall\n        wall_dists[i, 2] = y          # bottom wall\n        wall_dists[i, 3] = 1 - y      # top wall\n    \n    # Apply specialized adjustments\n    \n    # 1. Optimize corner circles first (they tend to be larger)\n    corner_threshold = 0.3  # Distance from corner to identify corner circles\n    corner_indices = []\n    corners = [(0,0), (0,1), (1,0), (1,1)]\n    \n    for i in range(n):\n        for cx, cy in corners:\n            dist = np.linalg.norm(centers[i] - np.array([cx, cy]))\n            if dist < corner_threshold:\n                corner_indices.append(i)\n                break\n    \n    for idx in corner_indices:\n        # Calculate maximum possible radius\n        max_r = np.min(wall_dists[idx])\n        for j in range(n):\n            if idx != j:\n                max_from_j = dist_matrix[idx, j] - radii[j]\n                max_r = min(max_r, max_from_j)\n        \n        radii[idx] = max_r - 1e-10\n    \n    # 2. Then optimize edge circles\n    edge_threshold = 0.15  # Distance from edge to identify edge circles\n    edge_indices = []\n    \n    for i in range(n):\n        if i in corner_indices:\n            continue\n        \n        x, y = centers[i]\n        min_wall_dist = min(x, y, 1-x, 1-y)\n        if min_wall_dist < edge_threshold:\n            edge_indices.append(i)\n    \n    for idx in edge_indices:\n        # Calculate maximum possible radius\n        max_r = np.min(wall_dists[idx])\n        for j in range(n):\n            if idx != j:\n                max_from_j = dist_matrix[idx, j] - radii[j]\n                max_r = min(max_r, max_from_j)\n        \n        radii[idx] = max_r - 1e-10\n    \n    # 3. Optimize inner circles\n    inner_indices = list(set(range(n)) - set(corner_indices) - set(edge_indices))\n    \n    for idx in inner_indices:\n        # Calculate maximum possible radius\n        max_r = np.min(wall_dists[idx])\n        for j in range(n):\n            if idx != j:\n                max_from_j = dist_matrix[idx, j] - radii[j]\n                max_r = min(max_r, max_from_j)\n        \n        radii[idx] = max_r - 1e-10\n    \n    # Final overlap resolution\n    centers, radii = resolve_overlaps(centers, radii, iterations=5)\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using specialized patterns, multi-stage optimization, and gradient-based refinement\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\nimport math\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Start with multiple different initial configurations and pick the best\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try different initialization strategies\n    strategies = [\n        initialize_hexagonal_pattern,\n        initialize_corner_heavy_pattern,\n        initialize_specialized_pattern\n    ]\n    \n    for init_strategy in strategies:\n        centers, radii = init_strategy(n)\n        centers, radii = optimize_packing(centers, radii)\n        centers, radii = ensure_valid_packing(centers, radii)\n        \n        sum_radii = np.sum(radii)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Final optimization on the best configuration using gradient descent\n    best_centers, best_radii = global_numerical_optimization(best_centers, best_radii)\n    best_centers, best_radii = ensure_valid_packing(best_centers, best_radii)\n    \n    sum_radii = np.sum(best_radii)\n    return best_centers, best_radii, sum_radii\n\n\ndef initialize_hexagonal_pattern(n):\n    \"\"\"\n    Initialize circle positions using a hexagonal packing pattern\n    \"\"\"\n    centers = np.zeros((n, 2))\n    \n    # Hexagonal grid parameters with better aspect ratio handling\n    aspect_ratio = 1.0  # Unit square\n    rows = int(np.floor(np.sqrt(n / aspect_ratio)))\n    cols = int(np.ceil(n / rows))\n\n    dx = 1.0 / cols\n    dy = aspect_ratio / rows\n\n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if count < n:\n                x = (j + 0.5 + (i % 2) * 0.5) * dx\n                y = (i + 0.5) * dy\n                centers[count] = [x, y]\n                count += 1\n    \n    # Initialize all radii equally\n    initial_radius = 0.45 / max(rows, cols) # Dynamically set based on grid size\n    radii = np.ones(n) * initial_radius\n    \n    return centers, radii\n\n\ndef initialize_corner_heavy_pattern(n):\n    \"\"\"\n    Initialize with larger circles in corners and edges\n    \"\"\"\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place 4 large circles in corners\n    corner_positions = np.array([\n        [0.11, 0.11],\n        [0.89, 0.11],\n        [0.11, 0.89],\n        [0.89, 0.89]\n    ])\n    centers[:4] = corner_positions\n    radii[:4] = 0.11\n    \n    # Place 4 medium circles at midpoints of edges\n    edge_positions = np.array([\n        [0.5, 0.11],\n        [0.5, 0.89],\n        [0.11, 0.5],\n        [0.89, 0.5]\n    ])\n    centers[4:8] = edge_positions\n    radii[4:8] = 0.10\n    \n    # Place remaining circles in a more strategic grid\n    remaining = n - 8\n    grid_rows = int(np.floor(np.sqrt(remaining)))\n    grid_cols = int(np.ceil(remaining / grid_rows))\n\n    count = 8\n    for i in range(grid_rows):\n        for j in range(grid_cols):\n            if count < n:\n                x = 0.2 + (0.6 / (grid_cols - 1)) * j if grid_cols > 1 else 0.5\n                y = 0.2 + (0.6 / (grid_rows - 1)) * i if grid_rows > 1 else 0.5\n                centers[count] = [x, y]\n                radii[count] = 0.085\n                count += 1\n    \n    return centers, radii\n\n\ndef initialize_specialized_pattern(n):\n    \"\"\"\n    Initialize with a specialized pattern for n=26 based on mathematical insights\n    \"\"\"\n    # Create a base grid of positions\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Optimized placement for n=26\n    radii[0:1] = 0.086981\n    centers[0] = [0.500000,0.500000]\n\n    radii[1:5] = 0.106889\n    centers[1] = [0.207107,0.207107]\n    centers[2] = [0.792893,0.207107]\n    centers[3] = [0.207107,0.792893]\n    centers[4] = [0.792893,0.792893]\n\n    radii[5:9] = 0.079625\n    centers[5] = [0.500000,0.133975]\n    centers[6] = [0.866025,0.500000]\n    centers[7] = [0.500000,0.866025]\n    centers[8] = [0.133975,0.500000]\n\n    radii[9:17] = 0.067492\n    centers[9] = [0.333333,0.333333]\n    centers[10] = [0.666667,0.333333]\n    centers[11] = [0.333333,0.666667]\n    centers[12] = [0.666667,0.666667]\n    centers[13] = [0.933013,0.266987]\n    centers[14] = [0.933013,0.733013]\n    centers[15] = [0.066987,0.266987]\n    centers[16] = [0.066987,0.733013]\n\n    radii[17:26] = 0.060000\n    centers[17] = [0.500000,0.333333]\n    centers[18] = [0.666667,0.500000]\n    centers[19] = [0.500000,0.666667]\n    centers[20] = [0.333333,0.500000]\n    centers[21] = [0.733013,0.266987]\n    centers[22] = [0.733013,0.733013]\n    centers[23] = [0.266987,0.266987]\n    centers[24] = [0.266987,0.733013]\n    centers[25] = [0.500000,0.566667]\n    \n    return centers, radii\n\n\ndef optimize_packing(centers, radii, iterations=2):\n    \"\"\"\n    Multi-stage optimization to maximize the sum of radii\n    \"\"\"\n    n = len(centers)\n    \n    # Perform several iterations of optimization\n    for _ in range(iterations):\n        # First optimize positions with fixed radii\n        centers = optimize_positions(centers, radii)\n        \n        # Then optimize radii with fixed positions\n        radii = optimize_radii(centers, radii)\n        \n        # Resolve any overlaps\n        centers, radii = resolve_overlaps(centers, radii)\n    \n    return centers, radii\n\n\ndef optimize_positions(centers, radii, iterations=150):\n    \"\"\"\n    Optimize circle positions while keeping radii fixed using a physics-based approach\n    \"\"\"\n    n = len(centers)\n    \n    # Parameters for the physics-based optimization\n    repulsion_strength = 20.0  # Increased repulsion strength\n    attraction_strength = 0.05 # Reduced attraction strength\n    wall_repulsion = 30.0       # Increased wall repulsion\n    \n    # Velocity and dampening for the physics simulation\n    velocity = np.zeros_like(centers)\n    dampening = 0.8  # Increased dampening\n    dt = 0.01\n    \n    for _ in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        # Circle-circle interactions\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist_vec = centers[i] - centers[j]\n                dist = np.linalg.norm(dist_vec)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist:\n                    # Repulsive force when overlapping\n                    overlap = min_dist - dist\n                    direction = dist_vec / (dist + 1e-10)\n                    \n                    # Apply stronger repulsion to resolve overlaps\n                    force_mag = repulsion_strength * overlap\n                    forces[i] += force_mag * direction\n                    forces[j] -= force_mag * direction\n                else:\n                    # Slight attractive force when not overlapping but close\n                    gap = dist - min_dist\n                    if gap < 0.04:  # Reduced attraction range\n                        direction = dist_vec / (dist + 1e-10)\n                        force_mag = attraction_strength * gap\n                        forces[i] -= force_mag * direction\n                        forces[j] += force_mag * direction\n        \n        # Wall constraints - strong repulsion from walls\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Distance to walls\n            dist_left = x - r\n            dist_right = 1 - r - x\n            dist_bottom = y - r\n            dist_top = 1 - r - y\n            \n            # Apply repulsive forces from walls\n            if dist_left < 0:\n                forces[i, 0] += wall_repulsion * abs(dist_left)\n            if dist_right < 0:\n                forces[i, 0] -= wall_repulsion * abs(dist_right)\n            if dist_bottom < 0:\n                forces[i, 1] += wall_repulsion * abs(dist_bottom)\n            if dist_top < 0:\n                forces[i, 1] -= wall_repulsion * abs(dist_top)\n        \n        # Update velocities and positions\n        velocity = dampening * velocity + forces * dt\n        centers += velocity * dt\n        \n        # Ensure circles stay within bounds\n        for i in range(n):\n            r = radii[i]\n            centers[i, 0] = np.clip(centers[i, 0], r, 1 - r)\n            centers[i, 1] = np.clip(centers[i, 1], r, 1 - r)\n    \n    return centers\n\n\ndef optimize_radii(centers, radii, iterations=100):\n    \"\"\"\n    Optimize circle radii while keeping positions fixed\n    \"\"\"\n    n = len(centers)\n    \n    # Calculate distance matrix between all circles\n    dist_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            dist_matrix[i, j] = dist_matrix[j, i] = dist\n    \n    # Calculate distance to walls for each circle\n    wall_dists = np.zeros((n, 4))  # left, right, bottom, top\n    for i in range(n):\n        x, y = centers[i]\n        wall_dists[i, 0] = x          # left wall\n        wall_dists[i, 1] = 1 - x      # right wall\n        wall_dists[i, 2] = y          # bottom wall\n        wall_dists[i, 3] = 1 - y      # top wall\n    \n    # Iteratively grow all circles\n    for _ in range(iterations):\n        # Calculate maximum possible radius for each circle\n        max_radii = np.ones(n) * float('inf')\n        \n        # Limit by walls\n        for i in range(n):\n            max_radii[i] = min(max_radii[i], np.min(wall_dists[i]))\n        \n        # Limit by other circles\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    max_from_j = dist_matrix[i, j] - radii[j]\n                    max_radii[i] = min(max_radii[i], max_from_j)\n        \n        # Grow each circle to its maximum radius (with a small safety margin)\n        for i in range(n):\n            radii[i] = max_radii[i] - 1e-10\n    \n    return radii\n\n\ndef global_numerical_optimization(centers, radii):\n    \"\"\"\n    Use numerical optimization to fine-tune the packing using gradient descent\n    \"\"\"\n    n = len(centers)\n    \n    # Create parameter vector for optimization\n    params = np.concatenate([centers.flatten(), radii])\n    \n    # Define bounds\n    bounds = []\n    # Position bounds\n    for i in range(n):\n        r = radii[i]\n        bounds.append((r, 1-r))  # x bounds\n        bounds.append((r, 1-r))  # y bounds\n    \n    # Radius bounds - allow them to vary but keep minimum size\n    min_radius = 0.01\n    for i in range(n):\n        bounds.append((min_radius, 0.5))  # radius bounds\n    \n    # Define objective function to maximize sum of radii\n    def objective(params):\n        # Extract positions and radii\n        pos = params[:2*n].reshape(n, 2)\n        rad = params[2*n:]\n        \n        # Penalty for invalid configurations\n        penalty = 0\n        \n        # Check if all circles are within bounds\n        for i in range(n):\n            x, y = pos[i]\n            r = rad[i]\n            \n            if x - r < 0:\n                penalty += (x - r) ** 2 * 1000\n            if x + r > 1:\n                penalty += (x + r - 1) ** 2 * 1000\n            if y - r < 0:\n                penalty += (y - r) ** 2 * 1000\n            if y + r > 1:\n                penalty += (y + r - 1) ** 2 * 1000\n        \n        # Check for overlaps between circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(pos[i] - pos[j])\n                min_dist = rad[i] + rad[j]\n                \n                if dist < min_dist:\n                    penalty += (min_dist - dist) ** 2 * 1000\n        \n        # Return negative sum (for minimization) with penalty\n        return -np.sum(rad) + penalty\n    \n    # Use a constrained optimization method (L-BFGS-B)\n    try:\n        result = minimize(\n            objective,\n            params,\n            method='L-BFGS-B',\n            jac=None,  # Let scipy estimate the Jacobian\n            bounds=bounds,\n            options={'maxiter': 200, 'ftol': 1e-6, 'gtol': 1e-6} # Increased iterations and tighter tolerances\n        )\n        \n        # Extract optimized parameters\n        optimized_params = result.x\n        optimized_centers = optimized_params[:2*n].reshape(n, 2)\n        optimized_radii = optimized_params[2*n:]\n        \n        # Ensure the result is valid\n        if is_valid_configuration(optimized_centers, optimized_radii):\n            centers, radii = optimized_centers, optimized_radii\n        \n    except Exception as e:\n        # If optimization fails, keep the original configuration and print the error\n        print(f\"Numerical optimization failed: {e}\")\n        pass\n    \n    return centers, radii\n\n\ndef is_valid_configuration(centers, radii):\n    \"\"\"\n    Check if a configuration is valid (no overlaps, all circles within bounds)\n    \"\"\"\n    n = len(centers)\n    \n    # Check if all circles are within bounds\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        \n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n    \n    # Check for overlaps between circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-9: # Reduced tolerance\n                return False\n    \n    return True\n\n\ndef resolve_overlaps(centers, radii, iterations=15):\n    \"\"\"\n    Resolve any overlaps by adjusting positions and radii\n    \"\"\"\n    n = len(centers)\n    \n    for _ in range(iterations):\n        overlap_exists = False\n        \n        # Check and resolve circle-circle overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist - 1e-10:\n                    overlap_exists = True\n                    \n                    # Calculate overlap amount\n                    overlap = min_dist - dist\n                    \n                    # Adjust positions to resolve overlap\n                    direction = (centers[i] - centers[j]) / (dist + 1e-10)\n                    \n                    # Move circles apart proportionally to their radii\n                    weight_i = radii[j] / (radii[i] + radii[j])\n                    weight_j = radii[i] / (radii[i] + radii[j])\n                    \n                    centers[i] += direction * overlap * weight_i * 0.5\n                    centers[j] -= direction * overlap * weight_j * 0.5\n                    \n                    # Also slightly reduce radii to help resolve difficult overlaps\n                    radii[i] -= overlap * 0.1 * weight_i\n                    radii[j] -= overlap * 0.1 * weight_j\n                    \n                    # Ensure minimum radius\n                    radii[i] = max(0.01, radii[i])\n                    radii[j] = max(0.01, radii[j])\n        \n        # Check and resolve circle-wall overlaps\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Left wall\n            if x < r:\n                overlap_exists = True\n                centers[i, 0] = r\n            \n            # Right wall\n            if x > 1 - r:\n                overlap_exists = True\n                centers[i, 0] = 1 - r\n            \n            # Bottom wall\n            if y < r:\n                overlap_exists = True\n                centers[i, 1] = r\n            \n            # Top wall\n            if y > 1 - r:\n                overlap_exists = True\n                centers[i, 1] = 1 - r\n        \n        if not overlap_exists:\n            break\n    \n    return centers, radii\n\n\ndef ensure_valid_packing(centers, radii):\n    \"\"\"\n    Final validation to ensure the packing is valid and maximize radii\n    \"\"\"\n    n = len(centers)\n    \n    # First resolve any remaining overlaps\n    centers, radii = resolve_overlaps(centers, radii, iterations=20)\n    \n    # Calculate distance matrix between all circles\n    dist_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            dist_matrix[i, j] = dist_matrix[j, i] = dist\n    \n    # Calculate distance to walls for each circle\n    wall_dists = np.zeros((n, 4))  # left, right, bottom, top\n    for i in range(n):\n        x, y = centers[i]\n        wall_dists[i, 0] = x          # left wall\n        wall_dists[i, 1] = 1 - x      # right wall\n        wall_dists[i, 2] = y          # bottom wall\n        wall_dists[i, 3] = 1 - y      # top wall\n    \n    # Final radius optimization\n    for i in range(n):\n        # Limit by walls\n        max_r = np.min(wall_dists[i])\n        \n        # Limit by other circles\n        for j in range(n):\n            if i != j:\n                max_from_j = dist_matrix[i, j] - radii[j]\n                max_r = min(max_r, max_from_j)\n        \n        # Set radius to maximum possible value (with a small safety margin)\n        radii[i] = max_r - 1e-10\n    \n    # Apply specialized pattern adjustment for n=26 - REMOVED as causing issues.\n    # centers, radii = apply_specialized_adjustment(centers, radii)\n    \n    return centers, radii\n\n\ndef apply_specialized_adjustment(centers, radii):\n    \"\"\"\n    Apply specialized adjustments based on mathematical insights for n=26 - REMOVED as causing issues.\n    \"\"\"\n    n = len(centers)\n    \n    # Sort circles by distance from center\n    center_point = np.array([0.5, 0.5])\n    distances = np.array([np.linalg.norm(center - center_point) for center in centers])\n    sorted_indices = np.argsort(distances)\n    \n    # Identify circles in different regions\n    center_indices = sorted_indices[:1]  # Center circle\n    inner_ring_indices = sorted_indices[1:9]  # Inner ring (8 circles)\n    middle_ring_indices = sorted_indices[9:17]  # Middle ring (8 circles)\n    outer_indices = sorted_indices[17:]  # Outer circles (9 circles)\n    \n    # Calculate distance matrix between all circles\n    dist_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            dist_matrix[i, j] = dist_matrix[j, i] = dist\n    \n    # Calculate wall distances\n    wall_dists = np.zeros((n, 4))  # left, right, bottom, top\n    for i in range(n):\n        x, y = centers[i]\n        wall_dists[i, 0] = x          # left wall\n        wall_dists[i, 1] = 1 - x      # right wall\n        wall_dists[i, 2] = y          # bottom wall\n        wall_dists[i, 3] = 1 - y      # top wall\n    \n    # Apply specialized adjustments\n    \n    # 1. Optimize corner circles first (they tend to be larger)\n    corner_threshold = 0.3  # Distance from corner to identify corner circles\n    corner_indices = []\n    corners = [(0,0), (0,1), (1,0), (1,1)]\n    \n    for i in range(n):\n        for cx, cy in corners:\n            dist = np.linalg.norm(centers[i] - np.array([cx, cy]))\n            if dist < corner_threshold:\n                corner_indices.append(i)\n                break\n    \n    for idx in corner_indices:\n        # Calculate maximum possible radius\n        max_r = np.min(wall_dists[idx])\n        for j in range(n):\n            if idx != j:\n                max_from_j = dist_matrix[idx, j] - radii[j]\n                max_r = min(max_r, max_from_j)\n        \n        radii[idx] = max_r - 1e-10\n    \n    # 2. Then optimize edge circles\n    edge_threshold = 0.15  # Distance from edge to identify edge circles\n    edge_indices = []\n    \n    for i in range(n):\n        if i in corner_indices:\n            continue\n        \n        x, y = centers[i]\n        min_wall_dist = min(x, y, 1-x, 1-y)\n        if min_wall_dist < edge_threshold:\n            edge_indices.append(i)\n    \n    for idx in edge_indices:\n        # Calculate maximum possible radius\n        max_r = np.min(wall_dists[idx])\n        for j in range(n):\n            if idx != j:\n                max_from_j = dist_matrix[idx, j] - radii[j]\n                max_r = min(max_r, max_from_j)\n        \n        radii[idx] = max_r - 1e-10\n    \n    # 3. Optimize inner circles\n    inner_indices = list(set(range(n)) - set(corner_indices) - set(edge_indices))\n    \n    for idx in inner_indices:\n        # Calculate maximum possible radius\n        max_r = np.min(wall_dists[idx])\n        for j in range(n):\n            if idx != j:\n                max_from_j = dist_matrix[idx, j] - radii[j]\n                max_r = min(max_r, max_from_j)\n        \n        radii[idx] = max_r - 1e-10\n    \n    # Final overlap resolution\n    centers, radii = resolve_overlaps(centers, radii, iterations=5)\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    # plt.show()\n    plt.savefig(\"circle_packing_s100.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # Uncomment to visualize:\n    visualize(centers, radii)\n# EVOLVE-BLOCK-END\n```"]}}}