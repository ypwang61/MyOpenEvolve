{"id": "6ac48e59-64e7-43b4-954e-f40c02b78db8", "code": "# EVOLVE-BLOCK-START\n\"\"\"Optimized circle packing for n=26 circles using specialized mathematical patterns and multi-stage optimization\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Use multiple strategies with different initial configurations\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try different strategies with various parameters\n    strategies = [\n        # Specialized pattern with variable-sized circles\n        (specialized_pattern_1, {}, 200),\n        (specialized_pattern_2, {}, 200),\n        (specialized_pattern_3, {}, 200),\n        (specialized_pattern_4, {}, 200),\n        (specialized_pattern_5, {}, 200),\n    ]\n    \n    for strategy, params, iterations in strategies:\n        centers = strategy(**params)\n        # Initial radii calculation\n        radii = compute_initial_radii(centers)\n        \n        # Optimize with multiple stages\n        for i in range(3):  # Multiple optimization stages with different parameters\n            centers, radii = optimize_packing(\n                centers, \n                radii, \n                iterations=iterations,\n                repulsion_strength=0.002 * (1.0 - i*0.3),\n                attraction_strength=0.0005 * (1.0 + i*0.5),\n                border_repulsion=0.003 * (1.0 + i*0.2),\n                damping=0.7 - i*0.1\n            )\n            \n            # Fine-tune with local adjustments\n            centers, radii = local_refinement(centers, radii)\n        \n        sum_radii = np.sum(radii)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Final refinement on the best configuration\n    best_centers, best_radii = final_refinement(best_centers, best_radii)\n    best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef specialized_pattern_1():\n    \"\"\"\n    Create a specialized pattern based on mathematical principles\n    for optimal circle packing with variable-sized circles.\n    \n    This pattern places larger circles in the center and corners,\n    with smaller circles filling the gaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Place one large circle in the center\n    centers[0] = [0.5, 0.5]\n    \n    # Place circles in the corners\n    corners = [[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1.0, 1.0]]\n    for i in range(4):\n        centers[i+1] = [corners[i][0] + 0.12, corners[i][1] + 0.12]\n    \n    # Place circles on the edges\n    centers[5] = [0.5, 0.12]  # Bottom\n    centers[6] = [0.5, 0.88]  # Top\n    centers[7] = [0.12, 0.5]  # Left\n    centers[8] = [0.88, 0.5]  # Right\n    \n    # Create inner ring around center\n    inner_ring_count = 6\n    for i in range(inner_ring_count):\n        angle = 2 * np.pi * i / inner_ring_count\n        r = 0.22  # Distance from center\n        centers[9+i] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n    \n    # Create middle ring\n    middle_ring_count = 8\n    for i in range(middle_ring_count):\n        angle = 2 * np.pi * (i + 0.5) / middle_ring_count  # Offset from inner ring\n        r = 0.35  # Distance from center\n        centers[9+inner_ring_count+i] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n    \n    # Fill remaining positions\n    remaining = n - (1 + 4 + 4 + inner_ring_count + middle_ring_count)\n    positions = [\n        [0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75]\n    ]\n    \n    for i in range(remaining):\n        centers[9+inner_ring_count+middle_ring_count+i] = positions[i]\n    \n    return centers\n\ndef specialized_pattern_2():\n    \"\"\"\n    Create a specialized pattern with a hybrid hexagonal-square arrangement.\n    This pattern is designed to efficiently fill the square with 26 circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Create a pattern with 5 rows\n    row_counts = [5, 6, 5, 6, 4]  # Total: 26 circles\n    \n    # Calculate optimal y-positions for rows\n    row_heights = np.array([0.1, 0.3, 0.5, 0.7, 0.9])\n    \n    count = 0\n    for row, num_circles in enumerate(row_counts):\n        y = row_heights[row]\n        \n        # Calculate x-positions for this row\n        if num_circles % 2 == 0:  # Even number of circles\n            x_positions = np.linspace(1/(2*num_circles), 1-1/(2*num_circles), num_circles)\n        else:  # Odd number of circles\n            x_positions = np.linspace(1/(2*(num_circles-1)), 1-1/(2*(num_circles-1)), num_circles)\n        \n        for col in range(num_circles):\n            centers[count] = [x_positions[col], y]\n            count += 1\n    \n    return centers\n\ndef specialized_pattern_3():\n    \"\"\"\n    Create a pattern based on a modified hexagonal packing with variable sizes.\n    This arrangement places larger circles in strategic positions.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Create a hexagonal grid with adjustments\n    hex_rows = 5\n    hex_cols = 6\n    \n    # Calculate optimal spacing\n    dx = 1.0 / (hex_cols + 0.5)\n    dy = 1.0 / (hex_rows + 0.5)\n    \n    # Create hexagonal grid\n    count = 0\n    for i in range(hex_rows):\n        offset = (i % 2) * 0.5\n        cols_in_row = hex_cols - (i % 2)\n        \n        for j in range(cols_in_row):\n            if count < n:\n                x = (j + offset + 0.5) * dx\n                y = (i + 0.5) * dy\n                \n                # Adjust to fit better in the unit square\n                x = 0.05 + x * 0.9\n                y = 0.05 + y * 0.9\n                \n                centers[count] = [x, y]\n                count += 1\n    \n    # If we haven't placed all circles, add remaining ones\n    while count < n:\n        # Place remaining circles near the center\n        angle = 2 * np.pi * (count - (hex_rows * hex_cols)) / (n - (hex_rows * hex_cols))\n        r = 0.15  # Small radius from center\n        centers[count] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n        count += 1\n    \n    return centers\n\ndef specialized_pattern_4():\n    \"\"\"\n    Create a pattern with concentric rings of circles.\n    This pattern is particularly effective for maximizing the sum of radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    \n    # First ring - 8 circles\n    first_ring_count = 8\n    for i in range(first_ring_count):\n        angle = 2 * np.pi * i / first_ring_count\n        r = 0.25  # Distance from center\n        centers[i+1] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n    \n    # Second ring - 12 circles\n    second_ring_count = 12\n    for i in range(second_ring_count):\n        angle = 2 * np.pi * (i + 0.5/second_ring_count) / second_ring_count  # Slight offset\n        r = 0.42  # Distance from center\n        centers[i+1+first_ring_count] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n    \n    # Corner circles - 4 circles\n    corners = [\n        [0.08, 0.08], [0.92, 0.08], [0.08, 0.92], [0.92, 0.92]\n    ]\n    \n    for i in range(4):\n        centers[i+1+first_ring_count+second_ring_count] = corners[i]\n    \n    # Edge circle\n    centers[25] = [0.5, 0.08]  # Bottom edge\n    \n    return centers\n\ndef specialized_pattern_5():\n    \"\"\"\n    Create a pattern with variable-sized circles and strategic positioning.\n    This pattern places larger circles in corners and center, with smaller circles filling gaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Place circles in corners with optimal distance from borders\n    corner_distance = 0.11\n    corners = [\n        [corner_distance, corner_distance], \n        [1-corner_distance, corner_distance], \n        [corner_distance, 1-corner_distance], \n        [1-corner_distance, 1-corner_distance]\n    ]\n    \n    for i in range(4):\n        centers[i] = corners[i]\n    \n    # Place circles on edges\n    edge_distance = 0.11\n    edges = [\n        [0.5, edge_distance],  # Bottom\n        [0.5, 1-edge_distance],  # Top\n        [edge_distance, 0.5],  # Left\n        [1-edge_distance, 0.5]  # Right\n    ]\n    \n    for i in range(4):\n        centers[i+4] = edges[i]\n    \n    # Place one large circle in center\n    centers[8] = [0.5, 0.5]\n    \n    # Place medium circles in inner ring around center\n    inner_ring_count = 6\n    for i in range(inner_ring_count):\n        angle = 2 * np.pi * i / inner_ring_count\n        r = 0.22  # Distance from center\n        centers[9+i] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n    \n    # Place smaller circles in outer positions\n    positions = [\n        # Middle positions\n        [0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75],\n        # Additional positions\n        [0.25, 0.5], [0.75, 0.5], [0.5, 0.25], [0.5, 0.75],\n        # Extra positions to reach 26\n        [0.33, 0.33], [0.67, 0.33], [0.33, 0.67], [0.67, 0.67]\n    ]\n    \n    for i in range(n - (9 + inner_ring_count)):\n        centers[9+inner_ring_count+i] = positions[i]\n    \n    return centers\n\ndef compute_initial_radii(centers):\n    \"\"\"\n    Compute initial radii for all circles, ensuring they are within the square\n    and don't overlap with each other.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n    \n    # Limit by distance to borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    \n    # Limit by distance to other circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    # Iterative refinement to maximize radii\n    for _ in range(5):\n        for i in range(n):\n            # Border constraints\n            x, y = centers[i]\n            border_limit = min(x, y, 1 - x, 1 - y)\n            \n            # Circle-circle constraints\n            circle_limit = float('inf')\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    circle_limit = min(circle_limit, dist - radii[j])\n            \n            # Update radius to maximum possible value\n            radii[i] = min(border_limit, circle_limit)\n    \n    return radii\n\ndef optimize_packing(centers, radii, iterations=200, repulsion_strength=0.002, \n                    attraction_strength=0.0005, border_repulsion=0.003, damping=0.7):\n    \"\"\"\n    Optimize circle packing using a physics-based approach with adaptive parameters.\n    \"\"\"\n    n = centers.shape[0]\n    \n    # Initialize velocities\n    velocities = np.zeros_like(centers)\n    \n    # Track best configuration\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # Optimization loop\n    for iteration in range(iterations):\n        # Adaptive parameters based on iteration progress\n        progress = iteration / iterations\n        current_repulsion = repulsion_strength * (1.0 - 0.5 * progress)\n        current_attraction = attraction_strength * (1.0 - 0.3 * progress)\n        current_border = border_repulsion * (1.0 + 0.5 * progress)\n        \n        forces = np.zeros_like(centers)\n        \n        # Calculate forces between circles\n        for i in range(n):\n            for j in range(i+1, n):\n                dist_vec = centers[i] - centers[j]\n                dist = np.linalg.norm(dist_vec)\n                \n                if dist < 1e-10:  # Avoid division by zero\n                    dist = 1e-10\n                    dist_vec = np.array([1e-10, 1e-10])\n                \n                direction = dist_vec / dist\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist:\n                    # Strong repulsive force for overlapping circles\n                    overlap = min_dist - dist\n                    force = current_repulsion * overlap * direction\n                    forces[i] += force\n                    forces[j] -= force\n                else:\n                    # Weak attractive force for non-overlapping circles\n                    gap = dist - min_dist\n                    force = -current_attraction * gap * direction\n                    forces[i] += force\n                    forces[j] -= force\n        \n        # Border forces - stronger near edges\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Distance from borders\n            dist_left = x\n            dist_right = 1 - x\n            dist_bottom = y\n            dist_top = 1 - y\n            \n            # Apply border forces with increasing strength near edges\n            border_margin = 0.05\n            \n            if dist_left < r + border_margin:\n                forces[i, 0] += current_border * (r + border_margin - dist_left)\n            if dist_right < r + border_margin:\n                forces[i, 0] -= current_border * (r + border_margin - dist_right)\n            if dist_bottom < r + border_margin:\n                forces[i, 1] += current_border * (r + border_margin - dist_bottom)\n            if dist_top < r + border_margin:\n                forces[i, 1] -= current_border * (r + border_margin - dist_top)\n        \n        # Update velocities and positions with damping\n        velocities = damping * velocities + forces\n        centers += velocities\n        \n        # Ensure circles stay within bounds\n        for i in range(n):\n            centers[i, 0] = np.clip(centers[i, 0], 0.001, 0.999)\n            centers[i, 1] = np.clip(centers[i, 1], 0.001, 0.999)\n        \n        # Recalculate radii\n        new_radii = compute_max_radii(centers)\n        sum_radii = np.sum(new_radii)\n        \n        # Save best configuration\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = new_radii.copy()\n        \n        # Update current radii\n        radii = new_radii.copy()\n        \n        # Simulated annealing - occasionally accept worse solutions with decreasing probability\n        if np.random.rand() < 0.1 * (1.0 - progress)**2:\n            # Small random perturbation\n            centers += np.random.normal(0, 0.01 * (1.0 - progress), centers.shape)\n    \n    return best_centers, best_radii\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n    Uses an efficient algorithm with iterative refinement.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n    \n    # Initial estimate - distance to borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n    \n    # Iterative refinement\n    for _ in range(10):\n        # Check circle-circle constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    # Scale both radii proportionally\n                    scale = dist / (radii[i] + radii[j])\n                    radii[i] *= scale\n                    radii[j] *= scale\n        \n        # Check border constraints\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    \n    # Final precise calculation\n    for i in range(n):\n        # Border constraints\n        x, y = centers[i]\n        border_limit = min(x, y, 1 - x, 1 - y)\n        \n        # Circle-circle constraints\n        circle_limit = float('inf')\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                circle_limit = min(circle_limit, dist - radii[j])\n        \n        # Update radius to maximum possible value\n        radii[i] = min(border_limit, circle_limit)\n    \n    return radii\n\ndef local_refinement(centers, radii):\n    \"\"\"\n    Refine the packing by making small local adjustments to maximize radii sum.\n    \"\"\"\n    n = centers.shape[0]\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # Try small perturbations for each circle\n    for i in range(n):\n        original_pos = centers[i].copy()\n        original_radius = radii[i]\n        \n        # Try multiple directions\n        directions = [\n            [0.01, 0], [-0.01, 0], [0, 0.01], [0, -0.01],\n            [0.01, 0.01], [-0.01, 0.01], [0.01, -0.01], [-0.01, -0.01]\n        ]\n        \n        for dx, dy in directions:\n            # Apply small perturbation\n            centers[i] = original_pos + np.array([dx, dy])\n            centers[i] = np.clip(centers[i], 0.001, 0.999)\n            \n            # Recalculate radii\n            new_radii = compute_max_radii(centers)\n            new_sum = np.sum(new_radii)\n            \n            # Keep if better, revert if worse\n            if new_sum > best_sum:\n                best_sum = new_sum\n                best_centers = centers.copy()\n                best_radii = new_radii.copy()\n            else:\n                # Revert position\n                centers[i] = original_pos\n                radii[i] = original_radius\n    \n    # Try adjusting pairs of circles\n    for _ in range(5):\n        # Select a random pair of nearby circles\n        i = np.random.randint(0, n)\n        \n        # Find nearest neighbor\n        min_dist = float('inf')\n        j = -1\n        for k in range(n):\n            if k != i:\n                dist = np.linalg.norm(centers[i] - centers[k])\n                if dist < min_dist:\n                    min_dist = dist\n                    j = k\n        \n        if j >= 0:\n            # Save original positions\n            pos_i = centers[i].copy()\n            pos_j = centers[j].copy()\n            \n            # Try moving circles slightly apart\n            direction = centers[i] - centers[j]\n            if np.linalg.norm(direction) > 1e-10:\n                direction = direction / np.linalg.norm(direction)\n                \n                centers[i] += 0.01 * direction\n                centers[j] -= 0.01 * direction\n                \n                # Ensure within bounds\n                centers[i] = np.clip(centers[i], 0.001, 0.999)\n                centers[j] = np.clip(centers[j], 0.001, 0.999)\n                \n                # Recalculate radii\n                new_radii = compute_max_radii(centers)\n                new_sum = np.sum(new_radii)\n                \n                # Keep if better, revert if worse\n                if new_sum > best_sum:\n                    best_sum = new_sum\n                    best_centers = centers.copy()\n                    best_radii = new_radii.copy()\n                else:\n                    # Revert positions\n                    centers[i] = pos_i\n                    centers[j] = pos_j\n    \n    return best_centers, best_radii\n\ndef final_refinement(centers, radii):\n    \"\"\"\n    Perform final refinement with specialized techniques to maximize the sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # 1. Try variable-sized optimization - allow some circles to grow at the expense of others\n    for _ in range(10):\n        # Select a random circle to prioritize\n        i = np.random.randint(0, n)\n        \n        # Save original positions and radii\n        original_centers = centers.copy()\n        original_radii = radii.copy()\n        \n        # Try to grow this circle by moving others slightly\n        for j in range(n):\n            if j != i:\n                # Move circle j slightly away from circle i\n                direction = centers[j] - centers[i]\n                dist = np.linalg.norm(direction)\n                \n                if dist > 1e-10:\n                    direction = direction / dist\n                    centers[j] += 0.01 * direction\n                    centers[j] = np.clip(centers[j], 0.001, 0.999)\n        \n        # Recalculate radii\n        new_radii = compute_max_radii(centers)\n        new_sum = np.sum(new_radii)\n        \n        # Keep if better, revert if worse\n        if new_sum > best_sum:\n            best_sum = new_sum\n            best_centers = centers.copy()\n            best_radii = new_radii.copy()\n        else:\n            # Revert to original configuration\n            centers = original_centers.copy()\n            radii = original_radii.copy()\n    \n    # 2. Try rearranging small groups of circles\n    for _ in range(5):\n        # Select a random group of nearby circles\n        center_idx = np.random.randint(0, n)\n        group_size = 4  # Size of group to rearrange\n        \n        # Find nearest neighbors\n        distances = []\n        for j in range(n):\n            if j != center_idx:\n                dist = np.linalg.norm(centers[center_idx] - centers[j])\n                distances.append((j, dist))\n        \n        distances.sort(key=lambda x: x[1])\n        group_indices = [center_idx]\n        for j, _ in distances[:group_size-1]:\n            group_indices.append(j)\n        \n        # Save original positions\n        original_positions = centers[group_indices].copy()\n        \n        # Calculate centroid of the group\n        centroid = np.mean(centers[group_indices], axis=0)\n        \n        # Try rearranging in a mini-hexagonal pattern\n        for idx, i in enumerate(group_indices):\n            if idx == 0:\n                centers[i] = centroid\n            else:\n                angle = 2 * np.pi * (idx - 1) / (len(group_indices) - 1)\n                r = 0.08  # Small radius for the arrangement\n                centers[i] = [\n                    centroid[0] + r * np.cos(angle),\n                    centroid[1] + r * np.sin(angle)\n                ]\n                centers[i] = np.clip(centers[i], 0.001, 0.999)\n        \n        # Recalculate radii\n        new_radii = compute_max_radii(centers)\n        new_sum = np.sum(new_radii)\n        \n        # Keep if better, revert if worse\n        if new_sum > best_sum:\n            best_sum = new_sum\n            best_centers = centers.copy()\n            best_radii = new_radii.copy()\n        else:\n            # Revert to original positions\n            centers[group_indices] = original_positions\n    \n    # 3. Fine-tune with gradient-based optimization\n    for _ in range(20):\n        # Save original configuration\n        original_centers = centers.copy()\n        original_radii = radii.copy()\n        \n        # Calculate gradient for each circle\n        gradients = np.zeros_like(centers)\n        step_size = 0.001\n        \n        for i in range(n):\n            for dim in range(2):\n                # Try small step in positive direction\n                centers[i, dim] += step_size\n                radii_pos = compute_max_radii(centers)\n                sum_pos = np.sum(radii_pos)\n                \n                # Try small step in negative direction\n                centers[i, dim] -= 2 * step_size\n                radii_neg = compute_max_radii(centers)\n                sum_neg = np.sum(radii_neg)\n                \n                # Reset position\n                centers[i, dim] += step_size\n                \n                # Calculate gradient\n                gradients[i, dim] = (sum_pos - sum_neg) / (2 * step_size)\n        \n        # Normalize gradients\n        grad_norm = np.linalg.norm(gradients)\n        if grad_norm > 1e-10:\n            gradients = gradients / grad_norm\n        \n        # Move circles in gradient direction\n        centers += 0.005 * gradients\n        \n        # Ensure within bounds\n        for i in range(n):\n            centers[i] = np.clip(centers[i], 0.001, 0.999)\n        \n        # Recalculate radii\n        new_radii = compute_max_radii(centers)\n        new_sum = np.sum(new_radii)\n        \n        # Keep if better, revert if worse\n        if new_sum > best_sum:\n            best_sum = new_sum\n            best_centers = centers.copy()\n            best_radii = new_radii.copy()\n        else:\n            # Revert to original configuration\n            centers = original_centers.copy()\n            radii = original_radii.copy()\n    \n    return best_centers, best_radii\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)", "language": "python", "parent_id": "be1f63ff-b018-4515-a8df-0fee8dfe798e", "generation": 4, "timestamp": 1750753777.7251484, "iteration_found": 100, "metrics": {"stage1_passed": 0.0, "error": 0.0, "timeout": true}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.369663747266415, "target_ratio": 0.8993031298923777, "combined_score": 0.8993031298923777, "eval_time": 51.03829216957092}, "island": 4}, "artifacts_json": "{\"timeout\": true, \"timeout_duration\": 90, \"failure_stage\": \"stage1\", \"error_type\": \"timeout\"}", "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.635 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.377, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - validity: 1.0000\n- sum_radii: 2.3697\n- target_ratio: 0.8993\n- combined_score: 0.8993\n- eval_time: 51.0383\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.3617, target_ratio: 0.8963, combined_score: 0.8963, eval_time: 50.7247\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.3697, target_ratio: 0.8993, combined_score: 0.8993, eval_time: 51.0383\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 0.8986, target_ratio: 0.3410, combined_score: 0.3410, eval_time: 75.0648\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 2.1104)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4124), Performs well on target_ratio (0.9155), Performs well on combined_score (0.9155), Performs well on eval_time (5.3085)\n\n\n### Program 2 (Score: 15.5291)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a physics-based optimization approach with specialized patterns.\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (0.8986), Performs well on target_ratio (0.3410), Performs well on combined_score (0.3410), Performs well on eval_time (75.0648)\n\n\n### Program 3 (Score: 0.8281)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimized circle packing for n=26 circles using a specialized pattern and efficient optimization\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (1.2924), Performs well on target_ratio (0.4905), Performs well on combined_score (0.4905), Performs well on eval_time (0.8671)\n\n\n### Program 4 (Score: 0.9928)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a hybrid approach with improved initialization and physics-based optimization.\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (1.3893), Performs well on target_ratio (0.5272), Performs well on combined_score (0.5272), Performs well on eval_time (1.5204)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.4408)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern with variable-sized circles and multi-stage optimization.\"\"\"\nimport numpy as np\n\ndef construct_packing():\n# ... (truncated)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using variable-sized circles and specialized patterns\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Try multiple different initialization strategies and select the best\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    # Try different strategies\n    strategies = [\n        initialize_corner_centered,\n        initialize_hex_grid,\n        initialize_variable_sized,\n        initialize_hybrid_pattern\n    ]\n    \n    for init_strategy in strategies:\n        centers, radii = init_strategy()\n        centers, radii = optimize_packing(centers, radii)\n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Final refinement\n    best_centers, best_radii = refine_packing(best_centers, best_radii)\n    best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\n\ndef initialize_corner_centered():\n    \"\"\"Initialize with larger circles in corners and smaller ones in the center\"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Place circles in corners and along edges\n    centers[0] = [0.12, 0.12]  # Bottom-left\n    centers[1] = [0.88, 0.12]  # Bottom-right\n    centers[2] = [0.12, 0.88]  # Top-left\n    centers[3] = [0.88, 0.88]  # Top-right\n    \n    # Place circles along edges\n    centers[4] = [0.5, 0.12]   # Bottom edge\n    centers[5] = [0.5, 0.88]   # Top edge\n    centers[6] = [0.12, 0.5]   # Left edge\n    centers[7] = [0.88, 0.5]   # Right edge\n    \n    # Fill the interior with a grid pattern\n    interior_count = n - 8\n    grid_size = int(np.ceil(np.sqrt(interior_count)))\n    \n    count = 8\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count < n:\n                x = 0.25 + (j * 0.5 / (grid_size - 1))\n                y = 0.25 + (i * 0.5 / (grid_size - 1))\n                centers[count] = [x, y]\n                count += 1\n    \n    # Calculate initial radii\n    radii = compute_max_radii(centers)\n    return centers, radii\n\n\ndef initialize_hex_grid():\n    \"\"\"Initialize with a hexagonal grid pattern\"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Hexagonal grid parameters\n    rows = 5\n    cols = 6\n    \n    # Spacing\n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    # Create hexagonal grid\n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if count < n:\n                x = (j + 0.5 + (i % 2) * 0.5) * dx\n                y = (i + 0.5) * dy\n                \n                # Adjust to fit better in the unit square\n                x = 0.05 + x * 0.9\n                y = 0.05 + y * 0.9\n                \n                centers[count] = [x, y]\n                count += 1\n    \n    # Calculate initial radii\n    radii = compute_max_radii(centers)\n    return centers, radii\n\n\ndef initialize_variable_sized():\n    \"\"\"Initialize with variable sized circles - larger in center, smaller at edges\"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Place one large circle in the center\n    centers[0] = [0.5, 0.5]\n    \n    # Place medium circles in a ring around the center\n    ring1_count = 6\n    for i in range(ring1_count):\n        angle = 2 * np.pi * i / ring1_count\n        r = 0.25  # Distance from center\n        centers[i+1] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n    \n    # Place smaller circles in outer rings\n    ring2_count = 12\n    for i in range(ring2_count):\n        angle = 2 * np.pi * i / ring2_count\n        r = 0.38  # Distance from center\n        centers[i+1+ring1_count] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n    \n    # Place the remaining circles near corners and edges\n    remaining = n - (1 + ring1_count + ring2_count)\n    corners = [[0.15, 0.15], [0.85, 0.15], [0.15, 0.85], [0.85, 0.85]]\n    edges = [[0.5, 0.15], [0.5, 0.85], [0.15, 0.5], [0.85, 0.5]]\n    \n    for i in range(remaining):\n        if i < 4:\n            centers[i+1+ring1_count+ring2_count] = corners[i]\n        else:\n            centers[i+1+ring1_count+ring2_count] = edges[i-4]\n    \n    # Calculate initial radii\n    radii = compute_max_radii(centers)\n    return centers, radii\n\n\ndef initialize_hybrid_pattern():\n    \"\"\"Initialize with a hybrid pattern based on mathematical principles\"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Create a pattern with 5 rows\n    # Row 1: 5 circles\n    # Row 2: 6 circles\n    # Row 3: 5 circles\n    # Row 4: 6 circles\n    # Row 5: 4 circles\n    \n    row_counts = [5, 6, 5, 6, 4]\n    row_y = [0.1, 0.3, 0.5, 0.7, 0.9]\n    \n    count = 0\n    for row, num_circles in enumerate(row_counts):\n        y = row_y[row]\n        offset = 0.5 * (1.0 - (num_circles - 1) * 0.2)\n        \n        for col in range(num_circles):\n            x = offset + col * 0.2\n            centers[count] = [x, y]\n            count += 1\n    \n    # Calculate initial radii\n    radii = compute_max_radii(centers)\n    return centers, radii\n\n\ndef optimize_packing(centers, radii, iterations=500):\n    \"\"\"\n    Optimize circle packing using a physics-based approach with adaptive parameters.\n    \"\"\"\n    n = centers.shape[0]\n    \n    # Physics parameters\n    repulsion_strength = 0.001\n    attraction_strength = 0.0005\n    border_repulsion = 0.002\n    damping = 0.8\n    dt = 0.1\n    \n    velocities = np.zeros_like(centers)\n    \n    # Track best configuration\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # Optimization loop\n    for iteration in range(iterations):\n        # Adaptive parameters based on iteration progress\n        progress = iteration / iterations\n        current_repulsion = repulsion_strength * (1.0 - 0.5 * progress)\n        current_border = border_repulsion * (1.0 + progress)\n        \n        forces = np.zeros_like(centers)\n        \n        # Calculate forces between circles\n        for i in range(n):\n            for j in range(i+1, n):\n                dist_vec = centers[i] - centers[j]\n                dist = np.linalg.norm(dist_vec)\n                \n                if dist < 1e-10:  # Avoid division by zero\n                    dist = 1e-10\n                    dist_vec = np.array([1e-10, 1e-10])\n                \n                direction = dist_vec / dist\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist:\n                    # Repulsive force for overlapping circles\n                    overlap = min_dist - dist\n                    force = current_repulsion * overlap * direction\n                    forces[i] += force\n                    forces[j] -= force\n                else:\n                    # Weak attractive force for non-overlapping circles\n                    # This helps create denser packings\n                    gap = dist - min_dist\n                    force = -attraction_strength * gap * direction\n                    forces[i] += force\n                    forces[j] -= force\n        \n        # Border forces\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Repulsion from borders\n            if x < r:\n                forces[i, 0] += current_border * (r - x)\n            if x > 1 - r:\n                forces[i, 0] -= current_border * (x - (1 - r))\n            if y < r:\n                forces[i, 1] += current_border * (r - y)\n            if y > 1 - r:\n                forces[i, 1] -= current_border * (y - (1 - r))\n        \n        # Update velocities and positions\n        velocities = damping * velocities + forces * dt\n        centers += velocities * dt\n        \n        # Keep circles within bounds\n        for i in range(n):\n            centers[i, 0] = np.clip(centers[i, 0], 0.001, 0.999)\n            centers[i, 1] = np.clip(centers[i, 1], 0.001, 0.999)\n        \n        # Recalculate radii\n        radii = compute_max_radii(centers)\n        sum_radii = np.sum(radii)\n        \n        # Save best configuration\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n        \n        # Simulated annealing - occasionally accept worse solutions\n        if np.random.rand() < 0.1 * (1.0 - progress):\n            # Small random perturbation\n            centers += np.random.normal(0, 0.01, centers.shape)\n    \n    return best_centers, best_radii\n\n\ndef refine_packing(centers, radii):\n    \"\"\"\n    Fine-tune the packing by making small adjustments to maximize radii sum.\n    \"\"\"\n    n = centers.shape[0]\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # Try small perturbations for each circle\n    for i in range(n):\n        for _ in range(10):  # Try multiple perturbations per circle\n            # Save original position\n            original_pos = centers[i].copy()\n            \n            # Apply small random perturbation\n            centers[i] += np.random.normal(0, 0.01, 2)\n            centers[i] = np.clip(centers[i], 0.001, 0.999)\n            \n            # Recalculate radii\n            new_radii = compute_max_radii(centers)\n            new_sum = np.sum(new_radii)\n            \n            # Keep if better, revert if worse\n            if new_sum > best_sum:\n                best_sum = new_sum\n                best_centers = centers.copy()\n                best_radii = new_radii.copy()\n            else:\n                # Revert to original position\n                centers[i] = original_pos\n    \n    # Try specialized patterns for small groups of circles\n    # This can help break local optima\n    for _ in range(5):\n        # Select a random group of nearby circles\n        center_idx = np.random.randint(0, n)\n        group_indices = [center_idx]\n        \n        # Find 3-4 nearest neighbors\n        distances = []\n        for j in range(n):\n            if j != center_idx:\n                dist = np.linalg.norm(centers[center_idx] - centers[j])\n                distances.append((j, dist))\n        \n        distances.sort(key=lambda x: x[1])\n        for j, _ in distances[:3]:  # Add 3 nearest neighbors\n            group_indices.append(j)\n        \n        # Save original positions\n        original_positions = centers[group_indices].copy()\n        \n        # Try rearranging this small group in a mini-hexagonal pattern\n        center_point = np.mean(centers[group_indices], axis=0)\n        \n        for idx, i in enumerate(group_indices):\n            if idx == 0:\n                centers[i] = center_point\n            else:\n                angle = 2 * np.pi * (idx - 1) / (len(group_indices) - 1)\n                r = 0.1  # Small radius for the arrangement\n                centers[i] = [\n                    center_point[0] + r * np.cos(angle),\n                    center_point[1] + r * np.sin(angle)\n                ]\n                centers[i] = np.clip(centers[i], 0.001, 0.999)\n        \n        # Recalculate radii\n        new_radii = compute_max_radii(centers)\n        new_sum = np.sum(new_radii)\n        \n        # Keep if better, revert if worse\n        if new_sum > best_sum:\n            best_sum = new_sum\n            best_centers = centers.copy()\n            best_radii = new_radii.copy()\n        else:\n            # Revert to original positions\n            centers[group_indices] = original_positions\n    \n    return best_centers, best_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n    \n    # Limit by distance to borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    \n    # Limit by distance to other circles\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                radii[i] = min(radii[i], dist)\n    \n    # Scale all radii by 0.5 to avoid overlaps\n    radii *= 0.5\n    \n    # Iteratively grow radii until constraints are hit\n    for _ in range(10):\n        for i in range(n):\n            # Border constraints\n            x, y = centers[i]\n            border_limit = min(x, y, 1 - x, 1 - y)\n            \n            # Circle-circle constraints\n            circle_limit = float('inf')\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    circle_limit = min(circle_limit, dist - radii[j])\n            \n            # Update radius to maximum possible value\n            radii[i] = min(border_limit, circle_limit)\n    \n    return radii\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["I'll create a completely new approach to the circle packing problem, focusing on mathematical principles that can help us reach the target sum of 2.635 for 26 circles in a unit square.\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimized circle packing for n=26 circles using specialized mathematical patterns and multi-stage optimization\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Use multiple strategies with different initial configurations\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try different strategies with various parameters\n    strategies = [\n        # Specialized pattern with variable-sized circles\n        (specialized_pattern_1, {}, 200),\n        (specialized_pattern_2, {}, 200),\n        (specialized_pattern_3, {}, 200),\n        (specialized_pattern_4, {}, 200),\n        (specialized_pattern_5, {}, 200),\n    ]\n    \n    for strategy, params, iterations in strategies:\n        centers = strategy(**params)\n        # Initial radii calculation\n        radii = compute_initial_radii(centers)\n        \n        # Optimize with multiple stages\n        for i in range(3):  # Multiple optimization stages with different parameters\n            centers, radii = optimize_packing(\n                centers, \n                radii, \n                iterations=iterations,\n                repulsion_strength=0.002 * (1.0 - i*0.3),\n                attraction_strength=0.0005 * (1.0 + i*0.5),\n                border_repulsion=0.003 * (1.0 + i*0.2),\n                damping=0.7 - i*0.1\n            )\n            \n            # Fine-tune with local adjustments\n            centers, radii = local_refinement(centers, radii)\n        \n        sum_radii = np.sum(radii)\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Final refinement on the best configuration\n    best_centers, best_radii = final_refinement(best_centers, best_radii)\n    best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\ndef specialized_pattern_1():\n    \"\"\"\n    Create a specialized pattern based on mathematical principles\n    for optimal circle packing with variable-sized circles.\n    \n    This pattern places larger circles in the center and corners,\n    with smaller circles filling the gaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Place one large circle in the center\n    centers[0] = [0.5, 0.5]\n    \n    # Place circles in the corners\n    corners = [[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1.0, 1.0]]\n    for i in range(4):\n        centers[i+1] = [corners[i][0] + 0.12, corners[i][1] + 0.12]\n    \n    # Place circles on the edges\n    centers[5] = [0.5, 0.12]  # Bottom\n    centers[6] = [0.5, 0.88]  # Top\n    centers[7] = [0.12, 0.5]  # Left\n    centers[8] = [0.88, 0.5]  # Right\n    \n    # Create inner ring around center\n    inner_ring_count = 6\n    for i in range(inner_ring_count):\n        angle = 2 * np.pi * i / inner_ring_count\n        r = 0.22  # Distance from center\n        centers[9+i] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n    \n    # Create middle ring\n    middle_ring_count = 8\n    for i in range(middle_ring_count):\n        angle = 2 * np.pi * (i + 0.5) / middle_ring_count  # Offset from inner ring\n        r = 0.35  # Distance from center\n        centers[9+inner_ring_count+i] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n    \n    # Fill remaining positions\n    remaining = n - (1 + 4 + 4 + inner_ring_count + middle_ring_count)\n    positions = [\n        [0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75]\n    ]\n    \n    for i in range(remaining):\n        centers[9+inner_ring_count+middle_ring_count+i] = positions[i]\n    \n    return centers\n\ndef specialized_pattern_2():\n    \"\"\"\n    Create a specialized pattern with a hybrid hexagonal-square arrangement.\n    This pattern is designed to efficiently fill the square with 26 circles.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Create a pattern with 5 rows\n    row_counts = [5, 6, 5, 6, 4]  # Total: 26 circles\n    \n    # Calculate optimal y-positions for rows\n    row_heights = np.array([0.1, 0.3, 0.5, 0.7, 0.9])\n    \n    count = 0\n    for row, num_circles in enumerate(row_counts):\n        y = row_heights[row]\n        \n        # Calculate x-positions for this row\n        if num_circles % 2 == 0:  # Even number of circles\n            x_positions = np.linspace(1/(2*num_circles), 1-1/(2*num_circles), num_circles)\n        else:  # Odd number of circles\n            x_positions = np.linspace(1/(2*(num_circles-1)), 1-1/(2*(num_circles-1)), num_circles)\n        \n        for col in range(num_circles):\n            centers[count] = [x_positions[col], y]\n            count += 1\n    \n    return centers\n\ndef specialized_pattern_3():\n    \"\"\"\n    Create a pattern based on a modified hexagonal packing with variable sizes.\n    This arrangement places larger circles in strategic positions.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Create a hexagonal grid with adjustments\n    hex_rows = 5\n    hex_cols = 6\n    \n    # Calculate optimal spacing\n    dx = 1.0 / (hex_cols + 0.5)\n    dy = 1.0 / (hex_rows + 0.5)\n    \n    # Create hexagonal grid\n    count = 0\n    for i in range(hex_rows):\n        offset = (i % 2) * 0.5\n        cols_in_row = hex_cols - (i % 2)\n        \n        for j in range(cols_in_row):\n            if count < n:\n                x = (j + offset + 0.5) * dx\n                y = (i + 0.5) * dy\n                \n                # Adjust to fit better in the unit square\n                x = 0.05 + x * 0.9\n                y = 0.05 + y * 0.9\n                \n                centers[count] = [x, y]\n                count += 1\n    \n    # If we haven't placed all circles, add remaining ones\n    while count < n:\n        # Place remaining circles near the center\n        angle = 2 * np.pi * (count - (hex_rows * hex_cols)) / (n - (hex_rows * hex_cols))\n        r = 0.15  # Small radius from center\n        centers[count] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n        count += 1\n    \n    return centers\n\ndef specialized_pattern_4():\n    \"\"\"\n    Create a pattern with concentric rings of circles.\n    This pattern is particularly effective for maximizing the sum of radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    \n    # First ring - 8 circles\n    first_ring_count = 8\n    for i in range(first_ring_count):\n        angle = 2 * np.pi * i / first_ring_count\n        r = 0.25  # Distance from center\n        centers[i+1] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n    \n    # Second ring - 12 circles\n    second_ring_count = 12\n    for i in range(second_ring_count):\n        angle = 2 * np.pi * (i + 0.5/second_ring_count) / second_ring_count  # Slight offset\n        r = 0.42  # Distance from center\n        centers[i+1+first_ring_count] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n    \n    # Corner circles - 4 circles\n    corners = [\n        [0.08, 0.08], [0.92, 0.08], [0.08, 0.92], [0.92, 0.92]\n    ]\n    \n    for i in range(4):\n        centers[i+1+first_ring_count+second_ring_count] = corners[i]\n    \n    # Edge circle\n    centers[25] = [0.5, 0.08]  # Bottom edge\n    \n    return centers\n\ndef specialized_pattern_5():\n    \"\"\"\n    Create a pattern with variable-sized circles and strategic positioning.\n    This pattern places larger circles in corners and center, with smaller circles filling gaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Place circles in corners with optimal distance from borders\n    corner_distance = 0.11\n    corners = [\n        [corner_distance, corner_distance], \n        [1-corner_distance, corner_distance], \n        [corner_distance, 1-corner_distance], \n        [1-corner_distance, 1-corner_distance]\n    ]\n    \n    for i in range(4):\n        centers[i] = corners[i]\n    \n    # Place circles on edges\n    edge_distance = 0.11\n    edges = [\n        [0.5, edge_distance],  # Bottom\n        [0.5, 1-edge_distance],  # Top\n        [edge_distance, 0.5],  # Left\n        [1-edge_distance, 0.5]  # Right\n    ]\n    \n    for i in range(4):\n        centers[i+4] = edges[i]\n    \n    # Place one large circle in center\n    centers[8] = [0.5, 0.5]\n    \n    # Place medium circles in inner ring around center\n    inner_ring_count = 6\n    for i in range(inner_ring_count):\n        angle = 2 * np.pi * i / inner_ring_count\n        r = 0.22  # Distance from center\n        centers[9+i] = [\n            0.5 + r * np.cos(angle),\n            0.5 + r * np.sin(angle)\n        ]\n    \n    # Place smaller circles in outer positions\n    positions = [\n        # Middle positions\n        [0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75],\n        # Additional positions\n        [0.25, 0.5], [0.75, 0.5], [0.5, 0.25], [0.5, 0.75],\n        # Extra positions to reach 26\n        [0.33, 0.33], [0.67, 0.33], [0.33, 0.67], [0.67, 0.67]\n    ]\n    \n    for i in range(n - (9 + inner_ring_count)):\n        centers[9+inner_ring_count+i] = positions[i]\n    \n    return centers\n\ndef compute_initial_radii(centers):\n    \"\"\"\n    Compute initial radii for all circles, ensuring they are within the square\n    and don't overlap with each other.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n    \n    # Limit by distance to borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    \n    # Limit by distance to other circles\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    # Iterative refinement to maximize radii\n    for _ in range(5):\n        for i in range(n):\n            # Border constraints\n            x, y = centers[i]\n            border_limit = min(x, y, 1 - x, 1 - y)\n            \n            # Circle-circle constraints\n            circle_limit = float('inf')\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    circle_limit = min(circle_limit, dist - radii[j])\n            \n            # Update radius to maximum possible value\n            radii[i] = min(border_limit, circle_limit)\n    \n    return radii\n\ndef optimize_packing(centers, radii, iterations=200, repulsion_strength=0.002, \n                    attraction_strength=0.0005, border_repulsion=0.003, damping=0.7):\n    \"\"\"\n    Optimize circle packing using a physics-based approach with adaptive parameters.\n    \"\"\"\n    n = centers.shape[0]\n    \n    # Initialize velocities\n    velocities = np.zeros_like(centers)\n    \n    # Track best configuration\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # Optimization loop\n    for iteration in range(iterations):\n        # Adaptive parameters based on iteration progress\n        progress = iteration / iterations\n        current_repulsion = repulsion_strength * (1.0 - 0.5 * progress)\n        current_attraction = attraction_strength * (1.0 - 0.3 * progress)\n        current_border = border_repulsion * (1.0 + 0.5 * progress)\n        \n        forces = np.zeros_like(centers)\n        \n        # Calculate forces between circles\n        for i in range(n):\n            for j in range(i+1, n):\n                dist_vec = centers[i] - centers[j]\n                dist = np.linalg.norm(dist_vec)\n                \n                if dist < 1e-10:  # Avoid division by zero\n                    dist = 1e-10\n                    dist_vec = np.array([1e-10, 1e-10])\n                \n                direction = dist_vec / dist\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist:\n                    # Strong repulsive force for overlapping circles\n                    overlap = min_dist - dist\n                    force = current_repulsion * overlap * direction\n                    forces[i] += force\n                    forces[j] -= force\n                else:\n                    # Weak attractive force for non-overlapping circles\n                    gap = dist - min_dist\n                    force = -current_attraction * gap * direction\n                    forces[i] += force\n                    forces[j] -= force\n        \n        # Border forces - stronger near edges\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Distance from borders\n            dist_left = x\n            dist_right = 1 - x\n            dist_bottom = y\n            dist_top = 1 - y\n            \n            # Apply border forces with increasing strength near edges\n            border_margin = 0.05\n            \n            if dist_left < r + border_margin:\n                forces[i, 0] += current_border * (r + border_margin - dist_left)\n            if dist_right < r + border_margin:\n                forces[i, 0] -= current_border * (r + border_margin - dist_right)\n            if dist_bottom < r + border_margin:\n                forces[i, 1] += current_border * (r + border_margin - dist_bottom)\n            if dist_top < r + border_margin:\n                forces[i, 1] -= current_border * (r + border_margin - dist_top)\n        \n        # Update velocities and positions with damping\n        velocities = damping * velocities + forces\n        centers += velocities\n        \n        # Ensure circles stay within bounds\n        for i in range(n):\n            centers[i, 0] = np.clip(centers[i, 0], 0.001, 0.999)\n            centers[i, 1] = np.clip(centers[i, 1], 0.001, 0.999)\n        \n        # Recalculate radii\n        new_radii = compute_max_radii(centers)\n        sum_radii = np.sum(new_radii)\n        \n        # Save best configuration\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = new_radii.copy()\n        \n        # Update current radii\n        radii = new_radii.copy()\n        \n        # Simulated annealing - occasionally accept worse solutions with decreasing probability\n        if np.random.rand() < 0.1 * (1.0 - progress)**2:\n            # Small random perturbation\n            centers += np.random.normal(0, 0.01 * (1.0 - progress), centers.shape)\n    \n    return best_centers, best_radii\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n    Uses an efficient algorithm with iterative refinement.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n    \n    # Initial estimate - distance to borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n    \n    # Iterative refinement\n    for _ in range(10):\n        # Check circle-circle constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    # Scale both radii proportionally\n                    scale = dist / (radii[i] + radii[j])\n                    radii[i] *= scale\n                    radii[j] *= scale\n        \n        # Check border constraints\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    \n    # Final precise calculation\n    for i in range(n):\n        # Border constraints\n        x, y = centers[i]\n        border_limit = min(x, y, 1 - x, 1 - y)\n        \n        # Circle-circle constraints\n        circle_limit = float('inf')\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                circle_limit = min(circle_limit, dist - radii[j])\n        \n        # Update radius to maximum possible value\n        radii[i] = min(border_limit, circle_limit)\n    \n    return radii\n\ndef local_refinement(centers, radii):\n    \"\"\"\n    Refine the packing by making small local adjustments to maximize radii sum.\n    \"\"\"\n    n = centers.shape[0]\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # Try small perturbations for each circle\n    for i in range(n):\n        original_pos = centers[i].copy()\n        original_radius = radii[i]\n        \n        # Try multiple directions\n        directions = [\n            [0.01, 0], [-0.01, 0], [0, 0.01], [0, -0.01],\n            [0.01, 0.01], [-0.01, 0.01], [0.01, -0.01], [-0.01, -0.01]\n        ]\n        \n        for dx, dy in directions:\n            # Apply small perturbation\n            centers[i] = original_pos + np.array([dx, dy])\n            centers[i] = np.clip(centers[i], 0.001, 0.999)\n            \n            # Recalculate radii\n            new_radii = compute_max_radii(centers)\n            new_sum = np.sum(new_radii)\n            \n            # Keep if better, revert if worse\n            if new_sum > best_sum:\n                best_sum = new_sum\n                best_centers = centers.copy()\n                best_radii = new_radii.copy()\n            else:\n                # Revert position\n                centers[i] = original_pos\n                radii[i] = original_radius\n    \n    # Try adjusting pairs of circles\n    for _ in range(5):\n        # Select a random pair of nearby circles\n        i = np.random.randint(0, n)\n        \n        # Find nearest neighbor\n        min_dist = float('inf')\n        j = -1\n        for k in range(n):\n            if k != i:\n                dist = np.linalg.norm(centers[i] - centers[k])\n                if dist < min_dist:\n                    min_dist = dist\n                    j = k\n        \n        if j >= 0:\n            # Save original positions\n            pos_i = centers[i].copy()\n            pos_j = centers[j].copy()\n            \n            # Try moving circles slightly apart\n            direction = centers[i] - centers[j]\n            if np.linalg.norm(direction) > 1e-10:\n                direction = direction / np.linalg.norm(direction)\n                \n                centers[i] += 0.01 * direction\n                centers[j] -= 0.01 * direction\n                \n                # Ensure within bounds\n                centers[i] = np.clip(centers[i], 0.001, 0.999)\n                centers[j] = np.clip(centers[j], 0.001, 0.999)\n                \n                # Recalculate radii\n                new_radii = compute_max_radii(centers)\n                new_sum = np.sum(new_radii)\n                \n                # Keep if better, revert if worse\n                if new_sum > best_sum:\n                    best_sum = new_sum\n                    best_centers = centers.copy()\n                    best_radii = new_radii.copy()\n                else:\n                    # Revert positions\n                    centers[i] = pos_i\n                    centers[j] = pos_j\n    \n    return best_centers, best_radii\n\ndef final_refinement(centers, radii):\n    \"\"\"\n    Perform final refinement with specialized techniques to maximize the sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    # 1. Try variable-sized optimization - allow some circles to grow at the expense of others\n    for _ in range(10):\n        # Select a random circle to prioritize\n        i = np.random.randint(0, n)\n        \n        # Save original positions and radii\n        original_centers = centers.copy()\n        original_radii = radii.copy()\n        \n        # Try to grow this circle by moving others slightly\n        for j in range(n):\n            if j != i:\n                # Move circle j slightly away from circle i\n                direction = centers[j] - centers[i]\n                dist = np.linalg.norm(direction)\n                \n                if dist > 1e-10:\n                    direction = direction / dist\n                    centers[j] += 0.01 * direction\n                    centers[j] = np.clip(centers[j], 0.001, 0.999)\n        \n        # Recalculate radii\n        new_radii = compute_max_radii(centers)\n        new_sum = np.sum(new_radii)\n        \n        # Keep if better, revert if worse\n        if new_sum > best_sum:\n            best_sum = new_sum\n            best_centers = centers.copy()\n            best_radii = new_radii.copy()\n        else:\n            # Revert to original configuration\n            centers = original_centers.copy()\n            radii = original_radii.copy()\n    \n    # 2. Try rearranging small groups of circles\n    for _ in range(5):\n        # Select a random group of nearby circles\n        center_idx = np.random.randint(0, n)\n        group_size = 4  # Size of group to rearrange\n        \n        # Find nearest neighbors\n        distances = []\n        for j in range(n):\n            if j != center_idx:\n                dist = np.linalg.norm(centers[center_idx] - centers[j])\n                distances.append((j, dist))\n        \n        distances.sort(key=lambda x: x[1])\n        group_indices = [center_idx]\n        for j, _ in distances[:group_size-1]:\n            group_indices.append(j)\n        \n        # Save original positions\n        original_positions = centers[group_indices].copy()\n        \n        # Calculate centroid of the group\n        centroid = np.mean(centers[group_indices], axis=0)\n        \n        # Try rearranging in a mini-hexagonal pattern\n        for idx, i in enumerate(group_indices):\n            if idx == 0:\n                centers[i] = centroid\n            else:\n                angle = 2 * np.pi * (idx - 1) / (len(group_indices) - 1)\n                r = 0.08  # Small radius for the arrangement\n                centers[i] = [\n                    centroid[0] + r * np.cos(angle),\n                    centroid[1] + r * np.sin(angle)\n                ]\n                centers[i] = np.clip(centers[i], 0.001, 0.999)\n        \n        # Recalculate radii\n        new_radii = compute_max_radii(centers)\n        new_sum = np.sum(new_radii)\n        \n        # Keep if better, revert if worse\n        if new_sum > best_sum:\n            best_sum = new_sum\n            best_centers = centers.copy()\n            best_radii = new_radii.copy()\n        else:\n            # Revert to original positions\n            centers[group_indices] = original_positions\n    \n    # 3. Fine-tune with gradient-based optimization\n    for _ in range(20):\n        # Save original configuration\n        original_centers = centers.copy()\n        original_radii = radii.copy()\n        \n        # Calculate gradient for each circle\n        gradients = np.zeros_like(centers)\n        step_size = 0.001\n        \n        for i in range(n):\n            for dim in range(2):\n                # Try small step in positive direction\n                centers[i, dim] += step_size\n                radii_pos = compute_max_radii(centers)\n                sum_pos = np.sum(radii_pos)\n                \n                # Try small step in negative direction\n                centers[i, dim] -= 2 * step_size\n                radii_neg = compute_max_radii(centers)\n                sum_neg = np.sum(radii_neg)\n                \n                # Reset position\n                centers[i, dim] += step_size\n                \n                # Calculate gradient\n                gradients[i, dim] = (sum_pos - sum_neg) / (2 * step_size)\n        \n        # Normalize gradients\n        grad_norm = np.linalg.norm(gradients)\n        if grad_norm > 1e-10:\n            gradients = gradients / grad_norm\n        \n        # Move circles in gradient direction\n        centers += 0.005 * gradients\n        \n        # Ensure within bounds\n        for i in range(n):\n            centers[i] = np.clip(centers[i], 0.001, 0.999)\n        \n        # Recalculate radii\n        new_radii = compute_max_radii(centers)\n        new_sum = np.sum(new_radii)\n        \n        # Keep if better, revert if worse\n        if new_sum > best_sum:\n            best_sum = new_sum\n            best_centers = centers.copy()\n            best_radii = new_radii.copy()\n        else:\n            # Revert to original configuration\n            centers = original_centers.copy()\n            radii = original_radii.copy()\n    \n    return best_centers, best_radii\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```"]}}}