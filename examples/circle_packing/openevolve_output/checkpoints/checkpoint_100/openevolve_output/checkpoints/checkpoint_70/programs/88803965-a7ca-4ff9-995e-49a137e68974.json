{"id": "88803965-a7ca-4ff9-995e-49a137e68974", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern with variable-sized circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Start with a specialized pattern based on mathematical principles\n    centers, radii = initialize_specialized_pattern()\n    \n    # Apply optimization to refine the pattern\n    centers, radii = optimize_packing(centers, radii)\n    \n    # Final validation and adjustment\n    radii = compute_max_radii(centers)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef initialize_specialized_pattern():\n    \"\"\"\n    Initialize with a specialized pattern that combines:\n    1. A central large circle\n    2. A ring of medium-sized circles\n    3. Smaller circles in the corners and along edges\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Place a ring of 8 circles around the central one\n    angles = np.linspace(0, 2*np.pi, 9)[:-1]  # 8 angles\n    ring_radius = 0.25\n    for i in range(1, 9):\n        centers[i] = [\n            0.5 + ring_radius * np.cos(angles[i-1]),\n            0.5 + ring_radius * np.sin(angles[i-1])\n        ]\n    \n    # Place 4 circles in the corners\n    corners = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n    for i in range(9, 13):\n        centers[i] = corners[i-9]\n    \n    # Place 12 circles along the edges\n    edge_positions = [\n        # Bottom edge\n        [0.25, 0.1], [0.5, 0.1], [0.75, 0.1],\n        # Top edge\n        [0.25, 0.9], [0.5, 0.9], [0.75, 0.9],\n        # Left edge\n        [0.1, 0.25], [0.1, 0.5], [0.1, 0.75],\n        # Right edge\n        [0.9, 0.25], [0.9, 0.5], [0.9, 0.75]\n    ]\n    for i in range(13, 25):\n        centers[i] = edge_positions[i-13]\n    \n    # Place one more circle in a less crowded area\n    centers[25] = [0.5, 0.3]\n    \n    # Initial radii\n    radii = compute_max_radii(centers)\n    \n    return centers, radii\n\n\ndef optimize_packing(centers, radii):\n    \"\"\"\n    Multi-stage optimization to maximize the sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    \n    # Stage 1: Simulated annealing to explore the configuration space\n    temperature = 0.05\n    cooling_rate = 0.95\n    iterations_per_temp = 100\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_sum = np.sum(radii)\n    \n    for temp_step in range(15):  # Temperature steps\n        temperature *= cooling_rate\n        \n        for _ in range(iterations_per_temp):\n            # Choose a random circle to move\n            i = np.random.randint(0, n)\n            \n            # Save current position\n            old_pos = current_centers[i].copy()\n            \n            # Move in a random direction\n            angle = np.random.uniform(0, 2*np.pi)\n            distance = np.random.uniform(0, 0.05)\n            \n            current_centers[i, 0] += distance * np.cos(angle)\n            current_centers[i, 1] += distance * np.sin(angle)\n            \n            # Keep within bounds\n            if (current_centers[i, 0] < 0 or current_centers[i, 0] > 1 or\n                current_centers[i, 1] < 0 or current_centers[i, 1] > 1):\n                current_centers[i] = old_pos\n                continue\n            \n            # Recompute radii and sum\n            new_radii = compute_max_radii(current_centers)\n            new_sum = np.sum(new_radii)\n            \n            # Accept or reject based on simulated annealing criteria\n            delta = new_sum - current_sum\n            if delta > 0 or np.random.random() < np.exp(delta / temperature):\n                current_radii = new_radii\n                current_sum = new_sum\n                \n                # Update best if improved\n                if current_sum > best_sum:\n                    best_centers = current_centers.copy()\n                    best_radii = current_radii.copy()\n                    best_sum = current_sum\n            else:\n                # Reject move\n                current_centers[i] = old_pos\n    \n    # Stage 2: Fine-tuning with gradient ascent\n    centers = best_centers.copy()\n    radii = best_radii.copy()\n    \n    learning_rate = 0.001\n    for _ in range(50):\n        gradients = compute_gradients(centers, radii)\n        centers += learning_rate * gradients\n        centers = np.clip(centers, 0.001, 0.999)\n        radii = compute_max_radii(centers)\n    \n    return centers, radii\n\n\ndef compute_gradients(centers, radii):\n    \"\"\"\n    Compute numerical gradients for each circle position to maximize sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    gradients = np.zeros_like(centers)\n    \n    base_sum = np.sum(radii)\n    delta = 0.0001\n    \n    for i in range(n):\n        for dim in range(2):\n            # Try moving slightly in positive direction\n            centers[i, dim] += delta\n            pos_radii = compute_max_radii(centers)\n            pos_sum = np.sum(pos_radii)\n            \n            # Try moving slightly in negative direction\n            centers[i, dim] -= 2*delta\n            neg_radii = compute_max_radii(centers)\n            neg_sum = np.sum(neg_radii)\n            \n            # Reset position\n            centers[i, dim] += delta\n            \n            # Central difference gradient\n            gradients[i, dim] = (pos_sum - neg_sum) / (2*delta)\n    \n    return gradients\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n    \n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1-x, 1-y)\n    \n    # Then, limit by distances to other circles\n    for _ in range(3):  # Multiple iterations for better convergence\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    if dist < radii[i] + radii[j]:\n                        # Adjust both radii proportionally to their current sizes\n                        total = radii[i] + radii[j]\n                        if total > 0:  # Avoid division by zero\n                            ratio_i = radii[i] / total\n                            ratio_j = radii[j] / total\n                            radii[i] = ratio_i * dist\n                            radii[j] = ratio_j * dist\n    \n    # Final pass to ensure no overlaps\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                max_r_i = dist - radii[j]\n                if max_r_i < radii[i]:\n                    radii[i] = max(0.0, max_r_i)\n    \n    return radii\n\n\ndef optimize_specific_patterns():\n    \"\"\"\n    Try several specific patterns known to work well for circle packing\n    and return the best one.\n    \"\"\"\n    # Pattern 1: Hexagonal-based arrangement\n    def hexagonal_pattern():\n        n = 26\n        centers = np.zeros((n, 2))\n        \n        # Central circle\n        centers[0] = [0.5, 0.5]\n        \n        # First hexagonal ring (6 circles)\n        angles = np.linspace(0, 2*np.pi, 7)[:-1]\n        ring_radius = 0.2\n        for i in range(1, 7):\n            centers[i] = [\n                0.5 + ring_radius * np.cos(angles[i-1]),\n                0.5 + ring_radius * np.sin(angles[i-1])\n            ]\n        \n        # Second partial ring (12 circles)\n        angles = np.linspace(0, 2*np.pi, 13)[:-1]\n        ring_radius = 0.4\n        for i in range(7, 19):\n            centers[i] = [\n                0.5 + ring_radius * np.cos(angles[i-7]),\n                0.5 + ring_radius * np.sin(angles[i-7])\n            ]\n        \n        # Corner circles (4)\n        corners = [[0.08, 0.08], [0.08, 0.92], [0.92, 0.08], [0.92, 0.92]]\n        for i in range(19, 23):\n            centers[i] = corners[i-19]\n        \n        # Edge circles (3)\n        edges = [[0.5, 0.08], [0.08, 0.5], [0.92, 0.5]]\n        for i in range(23, 26):\n            centers[i] = edges[i-23]\n        \n        return centers\n    \n    # Pattern 2: Square grid with variable sizes\n    def square_grid_pattern():\n        n = 26\n        centers = np.zeros((n, 2))\n        \n        # 5x5 grid with one extra\n        grid_size = 5\n        spacing = 1.0 / (grid_size + 1)\n        \n        idx = 0\n        for i in range(1, grid_size+1):\n            for j in range(1, grid_size+1):\n                if idx < n:\n                    centers[idx] = [i * spacing, j * spacing]\n                    idx += 1\n        \n        # Add the last circle at the center\n        if idx < n:\n            centers[idx] = [0.5, 0.5]\n        \n        return centers\n    \n    # Pattern 3: Concentric rings\n    def concentric_rings_pattern():\n        n = 26\n        centers = np.zeros((n, 2))\n        \n        # Center circle\n        centers[0] = [0.5, 0.5]\n        \n        # Inner ring (8 circles)\n        angles = np.linspace(0, 2*np.pi, 9)[:-1]\n        ring_radius = 0.22\n        for i in range(1, 9):\n            centers[i] = [\n                0.5 + ring_radius * np.cos(angles[i-1]),\n                0.5 + ring_radius * np.sin(angles[i-1])\n            ]\n        \n        # Outer ring (16 circles)\n        angles = np.linspace(0, 2*np.pi, 17)[:-1]\n        ring_radius = 0.42\n        for i in range(9, 25):\n            centers[i] = [\n                0.5 + ring_radius * np.cos(angles[i-9]),\n                0.5 + ring_radius * np.sin(angles[i-9])\n            ]\n        \n        # One more at a strategic position\n        centers[25] = [0.5, 0.8]\n        \n        return centers\n    \n    # Try all patterns and optimize each\n    patterns = [\n        hexagonal_pattern(),\n        square_grid_pattern(),\n        concentric_rings_pattern()\n    ]\n    \n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    for pattern_centers in patterns:\n        radii = compute_max_radii(pattern_centers)\n        centers, radii = optimize_packing(pattern_centers, radii)\n        radii = compute_max_radii(centers)\n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers\n            best_radii = radii\n    \n    return best_centers, best_radii\n\n\ndef try_known_good_solution():\n    \"\"\"\n    Implement a known good solution based on mathematical principles\n    for circle packing with n=26.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central large circle\n    centers[0] = [0.5, 0.5]\n    \n    # First ring - 6 circles in hexagonal pattern\n    for i in range(6):\n        angle = i * np.pi / 3\n        centers[i+1] = [\n            0.5 + 0.2 * np.cos(angle),\n            0.5 + 0.2 * np.sin(angle)\n        ]\n    \n    # Second ring - 12 circles\n    for i in range(12):\n        angle = i * np.pi / 6\n        centers[i+7] = [\n            0.5 + 0.38 * np.cos(angle),\n            0.5 + 0.38 * np.sin(angle)\n        ]\n    \n    # Corner circles - 4 circles\n    corners = [[0.09, 0.09], [0.09, 0.91], [0.91, 0.09], [0.91, 0.91]]\n    for i in range(4):\n        centers[i+19] = corners[i]\n    \n    # Additional circles at strategic positions\n    centers[23] = [0.5, 0.09]\n    centers[24] = [0.09, 0.5]\n    centers[25] = [0.91, 0.5]\n    \n    # Compute radii and optimize\n    radii = compute_max_radii(centers)\n    centers, radii = optimize_packing(centers, radii)\n    \n    return centers, radii\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n    \"\"\"\n    # Try multiple approaches and take the best result\n    \n    # Approach 1: Start with specialized pattern\n    centers1, radii1 = initialize_specialized_pattern()\n    centers1, radii1 = optimize_packing(centers1, radii1)\n    radii1 = compute_max_radii(centers1)\n    sum1 = np.sum(radii1)\n    \n    # Approach 2: Try specific patterns\n    centers2, radii2 = optimize_specific_patterns()\n    sum2 = np.sum(radii2)\n    \n    # Approach 3: Known good solution\n    centers3, radii3 = try_known_good_solution()\n    radii3 = compute_max_radii(centers3)\n    sum3 = np.sum(radii3)\n    \n    # Select the best result\n    if sum1 >= sum2 and sum1 >= sum3:\n        return centers1, radii1, sum1\n    elif sum2 >= sum1 and sum2 >= sum3:\n        return centers2, radii2, sum2\n    else:\n        return centers3, radii3, sum3\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)", "language": "python", "parent_id": "2fc5e7cc-0cf7-44e4-9669-27ddc161cb6f", "generation": 3, "timestamp": 1750751622.2534873, "iteration_found": 45, "metrics": {"stage1_passed": 0.0, "error": 0.0, "timeout": true}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"stage1_passed": 0.0, "error": 0.0, "timeout": true}, "island": 2}, "artifacts_json": "{\"timeout\": true, \"timeout_duration\": 90, \"failure_stage\": \"stage1\", \"error_type\": \"timeout\"}", "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.635 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.377, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - stage1_passed: 0.0000\n- error: 0.0000\n- timeout: 1.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n## Last Execution Output\n\n### timeout\n```\nTrue\n```\n\n### timeout_duration\n```\n90\n```\n\n### failure_stage\n```\nstage1\n```\n\n### error_type\n```\ntimeout\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 1.8125, target_ratio: 0.6879, combined_score: 0.6879, eval_time: 16.3053\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.0707, target_ratio: 0.7858, combined_score: 0.7858, eval_time: 31.6651\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.3617, target_ratio: 0.8963, combined_score: 0.8963, eval_time: 50.7247\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 2.1104)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4124), Performs well on target_ratio (0.9155), Performs well on combined_score (0.9155), Performs well on eval_time (5.3085)\n\n\n### Program 2 (Score: 11.1758)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using variable-sized circles and specialized optimization\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.3617), Performs well on target_ratio (0.8963), Performs well on combined_score (0.8963), Performs well on eval_time (50.7247)\n\n\n### Program 3 (Score: 7.2615)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a hybrid optimization approach with improved initialization and physics.\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.0707), Performs well on target_ratio (0.7858), Performs well on combined_score (0.7858), Performs well on eval_time (31.6651)\n\n\n### Program 4 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a Voronoi-based initialization,\n   force-directed optimization, and adaptive radius adjustment.\"\"\"\nimport numpy as np\nfrom scipy.spatial import Voronoi, voronoi_plot_2d\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on error (Program execution failed: No module named 'scipy')\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a hybrid optimization approach with improved initialization, physics, and local search.\"\"\"\nimport numpy as np\n\ndef construct_packing():\n# ... (truncated)\n```\nKey features: Alternative approach to stage1_passed, Alternative approach to error\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a hybrid optimization approach\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize with a known good pattern\n    centers, radii = initialize_advanced_pattern()\n    \n    # Apply multi-stage optimization\n    centers, radii = optimize_packing(centers, radii)\n    \n    # Final validation and adjustment\n    radii = compute_max_radii(centers)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef initialize_advanced_pattern():\n    \"\"\"\n    Initialize with a carefully designed pattern based on mathematical principles\n    for efficient circle packing.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Start with a somewhat random, but relatively spaced out configuration\n    for i in range(n):\n        centers[i] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n        radii[i] = 0.05  # Initial radius\n\n    return centers, radii\n\n\ndef optimize_packing(centers, radii):\n    \"\"\"\n    Multi-stage optimization to maximize the sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n\n    # Stage 1: Physics-based repulsion and attraction\n    repulsion_strength = 0.005\n    attraction_strength = 0.0001\n    border_repulsion = 0.002\n    num_iterations = 200\n\n    for iteration in range(num_iterations):\n        forces = np.zeros_like(centers)\n\n        # Circle-circle repulsion\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n                    if dist < (radii[i] + radii[j]):\n                        direction = (centers[i] - centers[j]) / dist\n                        forces[i] += repulsion_strength * direction / (dist + 0.001)\n\n        # Circle-center attraction (to keep them somewhat centered)\n        for i in range(n):\n            direction = (0.5, 0.5) - centers[i]\n            forces[i] += attraction_strength * direction\n\n        # Border repulsion\n        for i in range(n):\n            x, y = centers[i]\n            forces[i, 0] += border_repulsion / (x + 0.001)**2 - border_repulsion / ((1 - x) + 0.001)**2\n            forces[i, 1] += border_repulsion / (y + 0.001)**2 - border_repulsion / ((1 - y) + 0.001)**2\n\n        # Update positions\n        centers += forces\n        centers = np.clip(centers, 0.001, 0.999)  # Stay within bounds\n\n        # Adjust radii - ensure no overlaps\n        radii = compute_max_radii(centers)\n        \n    # Stage 2: Gradient Ascent (fine tuning)\n    learning_rate = 0.0005\n    num_gradient_iterations = 100\n\n    for _ in range(num_gradient_iterations):\n        radii = compute_max_radii(centers)\n        gradients = np.zeros_like(centers)\n\n        for i in range(n):\n            for dim in range(2):\n                delta = 0.0001\n                perturbed_centers = centers.copy()\n                perturbed_centers[i, dim] += delta\n                perturbed_radii = compute_max_radii(perturbed_centers)\n                gradient = (np.sum(perturbed_radii) - np.sum(radii)) / delta\n                gradients[i, dim] = gradient\n\n        centers += learning_rate * gradients\n        centers = np.clip(centers, 0.001, 0.999)\n        radii = compute_max_radii(centers)\n\n    return centers, radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, iteratively adjust radii to avoid overlaps\n    for _ in range(20):  # Multiple iterations for better convergence\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n                    max_allowed = max(0.0, (dist - radii[j]) / 2.0) # Divide by 2 to distribute the space\n                    radii[i] = min(radii[i], max_allowed)\n\n    return radii\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["I'll create a completely new approach for the circle packing problem that aims to reach the target of 2.635 for the sum of radii. I'll focus on using a more sophisticated optimization strategy with variable-sized circles and specialized patterns.\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern with variable-sized circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Start with a specialized pattern based on mathematical principles\n    centers, radii = initialize_specialized_pattern()\n    \n    # Apply optimization to refine the pattern\n    centers, radii = optimize_packing(centers, radii)\n    \n    # Final validation and adjustment\n    radii = compute_max_radii(centers)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef initialize_specialized_pattern():\n    \"\"\"\n    Initialize with a specialized pattern that combines:\n    1. A central large circle\n    2. A ring of medium-sized circles\n    3. Smaller circles in the corners and along edges\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Place a ring of 8 circles around the central one\n    angles = np.linspace(0, 2*np.pi, 9)[:-1]  # 8 angles\n    ring_radius = 0.25\n    for i in range(1, 9):\n        centers[i] = [\n            0.5 + ring_radius * np.cos(angles[i-1]),\n            0.5 + ring_radius * np.sin(angles[i-1])\n        ]\n    \n    # Place 4 circles in the corners\n    corners = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n    for i in range(9, 13):\n        centers[i] = corners[i-9]\n    \n    # Place 12 circles along the edges\n    edge_positions = [\n        # Bottom edge\n        [0.25, 0.1], [0.5, 0.1], [0.75, 0.1],\n        # Top edge\n        [0.25, 0.9], [0.5, 0.9], [0.75, 0.9],\n        # Left edge\n        [0.1, 0.25], [0.1, 0.5], [0.1, 0.75],\n        # Right edge\n        [0.9, 0.25], [0.9, 0.5], [0.9, 0.75]\n    ]\n    for i in range(13, 25):\n        centers[i] = edge_positions[i-13]\n    \n    # Place one more circle in a less crowded area\n    centers[25] = [0.5, 0.3]\n    \n    # Initial radii\n    radii = compute_max_radii(centers)\n    \n    return centers, radii\n\n\ndef optimize_packing(centers, radii):\n    \"\"\"\n    Multi-stage optimization to maximize the sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    \n    # Stage 1: Simulated annealing to explore the configuration space\n    temperature = 0.05\n    cooling_rate = 0.95\n    iterations_per_temp = 100\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_sum = np.sum(radii)\n    \n    for temp_step in range(15):  # Temperature steps\n        temperature *= cooling_rate\n        \n        for _ in range(iterations_per_temp):\n            # Choose a random circle to move\n            i = np.random.randint(0, n)\n            \n            # Save current position\n            old_pos = current_centers[i].copy()\n            \n            # Move in a random direction\n            angle = np.random.uniform(0, 2*np.pi)\n            distance = np.random.uniform(0, 0.05)\n            \n            current_centers[i, 0] += distance * np.cos(angle)\n            current_centers[i, 1] += distance * np.sin(angle)\n            \n            # Keep within bounds\n            if (current_centers[i, 0] < 0 or current_centers[i, 0] > 1 or\n                current_centers[i, 1] < 0 or current_centers[i, 1] > 1):\n                current_centers[i] = old_pos\n                continue\n            \n            # Recompute radii and sum\n            new_radii = compute_max_radii(current_centers)\n            new_sum = np.sum(new_radii)\n            \n            # Accept or reject based on simulated annealing criteria\n            delta = new_sum - current_sum\n            if delta > 0 or np.random.random() < np.exp(delta / temperature):\n                current_radii = new_radii\n                current_sum = new_sum\n                \n                # Update best if improved\n                if current_sum > best_sum:\n                    best_centers = current_centers.copy()\n                    best_radii = current_radii.copy()\n                    best_sum = current_sum\n            else:\n                # Reject move\n                current_centers[i] = old_pos\n    \n    # Stage 2: Fine-tuning with gradient ascent\n    centers = best_centers.copy()\n    radii = best_radii.copy()\n    \n    learning_rate = 0.001\n    for _ in range(50):\n        gradients = compute_gradients(centers, radii)\n        centers += learning_rate * gradients\n        centers = np.clip(centers, 0.001, 0.999)\n        radii = compute_max_radii(centers)\n    \n    return centers, radii\n\n\ndef compute_gradients(centers, radii):\n    \"\"\"\n    Compute numerical gradients for each circle position to maximize sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    gradients = np.zeros_like(centers)\n    \n    base_sum = np.sum(radii)\n    delta = 0.0001\n    \n    for i in range(n):\n        for dim in range(2):\n            # Try moving slightly in positive direction\n            centers[i, dim] += delta\n            pos_radii = compute_max_radii(centers)\n            pos_sum = np.sum(pos_radii)\n            \n            # Try moving slightly in negative direction\n            centers[i, dim] -= 2*delta\n            neg_radii = compute_max_radii(centers)\n            neg_sum = np.sum(neg_radii)\n            \n            # Reset position\n            centers[i, dim] += delta\n            \n            # Central difference gradient\n            gradients[i, dim] = (pos_sum - neg_sum) / (2*delta)\n    \n    return gradients\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n    \n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1-x, 1-y)\n    \n    # Then, limit by distances to other circles\n    for _ in range(3):  # Multiple iterations for better convergence\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    if dist < radii[i] + radii[j]:\n                        # Adjust both radii proportionally to their current sizes\n                        total = radii[i] + radii[j]\n                        if total > 0:  # Avoid division by zero\n                            ratio_i = radii[i] / total\n                            ratio_j = radii[j] / total\n                            radii[i] = ratio_i * dist\n                            radii[j] = ratio_j * dist\n    \n    # Final pass to ensure no overlaps\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                max_r_i = dist - radii[j]\n                if max_r_i < radii[i]:\n                    radii[i] = max(0.0, max_r_i)\n    \n    return radii\n\n\ndef optimize_specific_patterns():\n    \"\"\"\n    Try several specific patterns known to work well for circle packing\n    and return the best one.\n    \"\"\"\n    # Pattern 1: Hexagonal-based arrangement\n    def hexagonal_pattern():\n        n = 26\n        centers = np.zeros((n, 2))\n        \n        # Central circle\n        centers[0] = [0.5, 0.5]\n        \n        # First hexagonal ring (6 circles)\n        angles = np.linspace(0, 2*np.pi, 7)[:-1]\n        ring_radius = 0.2\n        for i in range(1, 7):\n            centers[i] = [\n                0.5 + ring_radius * np.cos(angles[i-1]),\n                0.5 + ring_radius * np.sin(angles[i-1])\n            ]\n        \n        # Second partial ring (12 circles)\n        angles = np.linspace(0, 2*np.pi, 13)[:-1]\n        ring_radius = 0.4\n        for i in range(7, 19):\n            centers[i] = [\n                0.5 + ring_radius * np.cos(angles[i-7]),\n                0.5 + ring_radius * np.sin(angles[i-7])\n            ]\n        \n        # Corner circles (4)\n        corners = [[0.08, 0.08], [0.08, 0.92], [0.92, 0.08], [0.92, 0.92]]\n        for i in range(19, 23):\n            centers[i] = corners[i-19]\n        \n        # Edge circles (3)\n        edges = [[0.5, 0.08], [0.08, 0.5], [0.92, 0.5]]\n        for i in range(23, 26):\n            centers[i] = edges[i-23]\n        \n        return centers\n    \n    # Pattern 2: Square grid with variable sizes\n    def square_grid_pattern():\n        n = 26\n        centers = np.zeros((n, 2))\n        \n        # 5x5 grid with one extra\n        grid_size = 5\n        spacing = 1.0 / (grid_size + 1)\n        \n        idx = 0\n        for i in range(1, grid_size+1):\n            for j in range(1, grid_size+1):\n                if idx < n:\n                    centers[idx] = [i * spacing, j * spacing]\n                    idx += 1\n        \n        # Add the last circle at the center\n        if idx < n:\n            centers[idx] = [0.5, 0.5]\n        \n        return centers\n    \n    # Pattern 3: Concentric rings\n    def concentric_rings_pattern():\n        n = 26\n        centers = np.zeros((n, 2))\n        \n        # Center circle\n        centers[0] = [0.5, 0.5]\n        \n        # Inner ring (8 circles)\n        angles = np.linspace(0, 2*np.pi, 9)[:-1]\n        ring_radius = 0.22\n        for i in range(1, 9):\n            centers[i] = [\n                0.5 + ring_radius * np.cos(angles[i-1]),\n                0.5 + ring_radius * np.sin(angles[i-1])\n            ]\n        \n        # Outer ring (16 circles)\n        angles = np.linspace(0, 2*np.pi, 17)[:-1]\n        ring_radius = 0.42\n        for i in range(9, 25):\n            centers[i] = [\n                0.5 + ring_radius * np.cos(angles[i-9]),\n                0.5 + ring_radius * np.sin(angles[i-9])\n            ]\n        \n        # One more at a strategic position\n        centers[25] = [0.5, 0.8]\n        \n        return centers\n    \n    # Try all patterns and optimize each\n    patterns = [\n        hexagonal_pattern(),\n        square_grid_pattern(),\n        concentric_rings_pattern()\n    ]\n    \n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    for pattern_centers in patterns:\n        radii = compute_max_radii(pattern_centers)\n        centers, radii = optimize_packing(pattern_centers, radii)\n        radii = compute_max_radii(centers)\n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers\n            best_radii = radii\n    \n    return best_centers, best_radii\n\n\ndef try_known_good_solution():\n    \"\"\"\n    Implement a known good solution based on mathematical principles\n    for circle packing with n=26.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central large circle\n    centers[0] = [0.5, 0.5]\n    \n    # First ring - 6 circles in hexagonal pattern\n    for i in range(6):\n        angle = i * np.pi / 3\n        centers[i+1] = [\n            0.5 + 0.2 * np.cos(angle),\n            0.5 + 0.2 * np.sin(angle)\n        ]\n    \n    # Second ring - 12 circles\n    for i in range(12):\n        angle = i * np.pi / 6\n        centers[i+7] = [\n            0.5 + 0.38 * np.cos(angle),\n            0.5 + 0.38 * np.sin(angle)\n        ]\n    \n    # Corner circles - 4 circles\n    corners = [[0.09, 0.09], [0.09, 0.91], [0.91, 0.09], [0.91, 0.91]]\n    for i in range(4):\n        centers[i+19] = corners[i]\n    \n    # Additional circles at strategic positions\n    centers[23] = [0.5, 0.09]\n    centers[24] = [0.09, 0.5]\n    centers[25] = [0.91, 0.5]\n    \n    # Compute radii and optimize\n    radii = compute_max_radii(centers)\n    centers, radii = optimize_packing(centers, radii)\n    \n    return centers, radii\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n    \"\"\"\n    # Try multiple approaches and take the best result\n    \n    # Approach 1: Start with specialized pattern\n    centers1, radii1 = initialize_specialized_pattern()\n    centers1, radii1 = optimize_packing(centers1, radii1)\n    radii1 = compute_max_radii(centers1)\n    sum1 = np.sum(radii1)\n    \n    # Approach 2: Try specific patterns\n    centers2, radii2 = optimize_specific_patterns()\n    sum2 = np.sum(radii2)\n    \n    # Approach 3: Known good solution\n    centers3, radii3 = try_known_good_solution()\n    radii3 = compute_max_radii(centers3)\n    sum3 = np.sum(radii3)\n    \n    # Select the best result\n    if sum1 >= sum2 and sum1 >= sum3:\n        return centers1, radii1, sum1\n    elif sum2 >= sum1 and sum2 >= sum3:\n        return centers2, radii2, sum2\n    else:\n        return centers3, radii3, sum3\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```"]}}}