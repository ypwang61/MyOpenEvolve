{"id": "978182d0-ac9c-47ff-8584-74f4bb54fe0d", "code": "# EVOLVE-BLOCK-START\n\"\"\"Optimized circle packing for n=26 circles using a specialized pattern and efficient optimization\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize with a specialized pattern based on mathematical principles\n    centers, radii = initialize_specialized_pattern()\n    \n    # Apply efficient optimization\n    centers, radii = optimize_packing(centers, radii)\n    \n    # Final validation and adjustment\n    radii = compute_max_radii(centers)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef initialize_specialized_pattern():\n    \"\"\"\n    Initialize with a specialized pattern that combines:\n    - Corner circles\n    - Edge circles\n    - Interior grid with variable sizes\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place circles in corners (4)\n    corner_positions = [(0.09, 0.09), (0.91, 0.09), (0.09, 0.91), (0.91, 0.91)]\n    for i in range(4):\n        centers[i] = corner_positions[i]\n        radii[i] = 0.09  # Initial estimate\n    \n    # Place circles along edges (8)\n    edge_positions = [\n        (0.25, 0.09), (0.5, 0.09), (0.75, 0.09),  # Bottom edge\n        (0.09, 0.5),                              # Left edge\n        (0.91, 0.5),                              # Right edge\n        (0.25, 0.91), (0.5, 0.91), (0.75, 0.91)   # Top edge\n    ]\n    for i in range(8):\n        centers[i+4] = edge_positions[i]\n        radii[i+4] = 0.09  # Initial estimate\n    \n    # Place interior circles (14) in a modified hexagonal pattern\n    interior_count = n - 12\n    interior_centers = []\n    \n    # Create a grid pattern for the interior\n    rows, cols = 3, 5\n    for row in range(rows):\n        for col in range(cols):\n            # Skip some positions to get exactly 14 interior circles\n            if (row == 0 and col == 0) or (row == 2 and col == 4):\n                continue\n                \n            x = 0.25 + col * 0.125\n            y = 0.25 + row * 0.25\n            # Add slight offset to odd rows for better packing\n            if row % 2 == 1:\n                x += 0.0625\n            interior_centers.append((x, y))\n    \n    for i in range(interior_count):\n        centers[i+12] = interior_centers[i]\n        radii[i+12] = 0.09  # Initial estimate\n    \n    return centers, radii\n\n\ndef optimize_packing(centers, radii):\n    \"\"\"\n    Efficient optimization to maximize the sum of radii.\n    Uses a combination of force-directed placement and local adjustments.\n    \"\"\"\n    n = centers.shape[0]\n    \n    # Stage 1: Force-directed optimization\n    repulsion_strength = 0.003\n    attraction_strength = 0.0002\n    border_strength = 0.005\n    \n    for iteration in range(100):  # Reduced iterations for speed\n        # Calculate forces\n        forces = np.zeros_like(centers)\n        \n        # Circle-circle repulsion (more efficient implementation)\n        for i in range(n):\n            # Calculate all distances at once\n            diff = centers - centers[i]\n            dist_sq = np.sum(diff**2, axis=1)\n            dist = np.sqrt(dist_sq)\n            \n            # Avoid self-comparison\n            dist[i] = 1.0  # Arbitrary non-zero value\n            \n            # Calculate repulsion force\n            mask = dist < (radii + radii[i]) * 1.1  # Slightly larger than exact overlap\n            mask[i] = False  # Exclude self\n            \n            if np.any(mask):\n                # Normalize directions\n                directions = diff[mask] / dist[mask, np.newaxis]\n                # Calculate force magnitudes\n                magnitudes = repulsion_strength / (dist[mask] + 0.001)\n                # Apply forces\n                forces[i] += np.sum(directions * magnitudes[:, np.newaxis], axis=0)\n        \n        # Center attraction\n        center_diff = np.array([0.5, 0.5]) - centers\n        center_dist = np.sqrt(np.sum(center_diff**2, axis=1))\n        forces += attraction_strength * center_diff / center_dist[:, np.newaxis]\n        \n        # Border repulsion (more efficient)\n        x_forces = border_strength * (1.0 / (centers[:, 0] + 0.001) - 1.0 / (1.0 - centers[:, 0] + 0.001))\n        y_forces = border_strength * (1.0 / (centers[:, 1] + 0.001) - 1.0 / (1.0 - centers[:, 1] + 0.001))\n        forces[:, 0] += x_forces\n        forces[:, 1] += y_forces\n        \n        # Update positions with decreasing step size\n        step_size = 0.01 * (1.0 - iteration / 100)\n        centers += forces * step_size\n        \n        # Ensure circles stay within bounds\n        centers = np.clip(centers, 0.001, 0.999)\n        \n        # Update radii\n        if iteration % 5 == 0:  # Only update occasionally for speed\n            radii = compute_max_radii(centers)\n    \n    # Stage 2: Local optimization for specific circle arrangements\n    # Focus on key circles that can be adjusted for better overall packing\n    key_indices = [0, 1, 2, 3]  # Corner circles\n    \n    for _ in range(50):\n        for idx in key_indices:\n            # Try small movements in different directions\n            best_sum = np.sum(radii)\n            best_pos = centers[idx].copy()\n            \n            for dx, dy in [(0.005, 0), (-0.005, 0), (0, 0.005), (0, -0.005)]:\n                centers[idx, 0] += dx\n                centers[idx, 1] += dy\n                \n                # Keep within bounds\n                centers[idx] = np.clip(centers[idx], 0.001, 0.999)\n                \n                # Compute new radii\n                new_radii = compute_max_radii(centers)\n                new_sum = np.sum(new_radii)\n                \n                if new_sum > best_sum:\n                    best_sum = new_sum\n                    best_pos = centers[idx].copy()\n                else:\n                    # Revert\n                    centers[idx, 0] -= dx\n                    centers[idx, 1] -= dy\n            \n            # Set to best position\n            centers[idx] = best_pos\n        \n        # Update radii\n        radii = compute_max_radii(centers)\n    \n    return centers, radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Efficiently compute the maximum possible radii for each circle position.\n    Uses a more optimized algorithm to avoid excessive iterations.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n    \n    # Distance to borders\n    radii = np.minimum(centers[:, 0], centers[:, 1])\n    radii = np.minimum(radii, 1.0 - centers[:, 0])\n    radii = np.minimum(radii, 1.0 - centers[:, 1])\n    \n    # Adjust for circle-circle overlaps\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                # For each pair, the sum of radii must be <= distance\n                # We use a binary search approach to find optimal radii\n                \n                if dist < radii[i] + radii[j]:\n                    # Distribute the overlap reduction proportionally to current radii\n                    if radii[i] + radii[j] > 0:\n                        ratio_i = radii[i] / (radii[i] + radii[j])\n                        reduction_i = ratio_i * (radii[i] + radii[j] - dist)\n                        radii[i] = max(0.001, radii[i] - reduction_i)\n    \n    # Final adjustment pass to ensure no overlaps\n    for _ in range(3):  # Fewer iterations for speed\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    max_allowed = max(0.0, dist - radii[j])\n                    radii[i] = min(radii[i], max_allowed)\n    \n    return radii\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)", "language": "python", "parent_id": "2fc5e7cc-0cf7-44e4-9669-27ddc161cb6f", "generation": 3, "timestamp": 1750750502.579838, "iteration_found": 16, "metrics": {"validity": 0.0, "combined_score": 0.0, "error": "Program execution failed: list index out of range"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"stage1_passed": 0.0, "error": 0.0, "timeout": true}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.635 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.377, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - stage1_passed: 0.0000\n- error: 0.0000\n- timeout: 1.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n## Last Execution Output\n\n### timeout\n```\nTrue\n```\n\n### timeout_duration\n```\n90\n```\n\n### failure_stage\n```\nstage1\n```\n\n### error_type\n```\ntimeout\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.4124, target_ratio: 0.9155, combined_score: 0.9155, eval_time: 5.3085\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 1.8125, target_ratio: 0.6879, combined_score: 0.6879, eval_time: 16.3053\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.0707, target_ratio: 0.7858, combined_score: 0.7858, eval_time: 31.6651\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 2.1104)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4124), Performs well on target_ratio (0.9155), Performs well on combined_score (0.9155), Performs well on eval_time (5.3085)\n\n\n### Program 2 (Score: 7.2615)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a hybrid optimization approach with improved initialization and physics.\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.0707), Performs well on target_ratio (0.7858), Performs well on combined_score (0.7858), Performs well on eval_time (31.6651)\n\n\n### Program 3 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a hybrid optimization approach\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n\n### Program 4 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a refined hybrid optimization approach\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on error (Program execution failed: No module named 'scipy')\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 1.0732)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Efficient circle packing for n=26 circles using deterministic construction and fast optimization\"\"\"\nimport numpy as np\n\n\n# ... (truncated)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a hybrid optimization approach\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize with a known good pattern\n    centers, radii = initialize_advanced_pattern()\n    \n    # Apply multi-stage optimization\n    centers, radii = optimize_packing(centers, radii)\n    \n    # Final validation and adjustment\n    radii = compute_max_radii(centers)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef initialize_advanced_pattern():\n    \"\"\"\n    Initialize with a carefully designed pattern based on mathematical principles\n    for efficient circle packing.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Start with a somewhat random, but relatively spaced out configuration\n    for i in range(n):\n        centers[i] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n        radii[i] = 0.05  # Initial radius\n\n    return centers, radii\n\n\ndef optimize_packing(centers, radii):\n    \"\"\"\n    Multi-stage optimization to maximize the sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n\n    # Stage 1: Physics-based repulsion and attraction\n    repulsion_strength = 0.005\n    attraction_strength = 0.0001\n    border_repulsion = 0.002\n    num_iterations = 200\n\n    for iteration in range(num_iterations):\n        forces = np.zeros_like(centers)\n\n        # Circle-circle repulsion\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n                    if dist < (radii[i] + radii[j]):\n                        direction = (centers[i] - centers[j]) / dist\n                        forces[i] += repulsion_strength * direction / (dist + 0.001)\n\n        # Circle-center attraction (to keep them somewhat centered)\n        for i in range(n):\n            direction = (0.5, 0.5) - centers[i]\n            forces[i] += attraction_strength * direction\n\n        # Border repulsion\n        for i in range(n):\n            x, y = centers[i]\n            forces[i, 0] += border_repulsion / (x + 0.001)**2 - border_repulsion / ((1 - x) + 0.001)**2\n            forces[i, 1] += border_repulsion / (y + 0.001)**2 - border_repulsion / ((1 - y) + 0.001)**2\n\n        # Update positions\n        centers += forces\n        centers = np.clip(centers, 0.001, 0.999)  # Stay within bounds\n\n        # Adjust radii - ensure no overlaps\n        radii = compute_max_radii(centers)\n        \n    # Stage 2: Gradient Ascent (fine tuning)\n    learning_rate = 0.0005\n    num_gradient_iterations = 100\n\n    for _ in range(num_gradient_iterations):\n        radii = compute_max_radii(centers)\n        gradients = np.zeros_like(centers)\n\n        for i in range(n):\n            for dim in range(2):\n                delta = 0.0001\n                perturbed_centers = centers.copy()\n                perturbed_centers[i, dim] += delta\n                perturbed_radii = compute_max_radii(perturbed_centers)\n                gradient = (np.sum(perturbed_radii) - np.sum(radii)) / delta\n                gradients[i, dim] = gradient\n\n        centers += learning_rate * gradients\n        centers = np.clip(centers, 0.001, 0.999)\n        radii = compute_max_radii(centers)\n\n    return centers, radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, iteratively adjust radii to avoid overlaps\n    for _ in range(20):  # Multiple iterations for better convergence\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n                    max_allowed = max(0.0, (dist - radii[j]) / 2.0) # Divide by 2 to distribute the space\n                    radii[i] = min(radii[i], max_allowed)\n\n    return radii\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["I'll rewrite the program to significantly improve its performance for packing 26 circles in a unit square. The key improvements will include:\n\n1. Using a specialized pattern for initialization based on mathematical principles\n2. Implementing a more efficient optimization strategy\n3. Utilizing a hybrid approach with both structured and variable-sized circles\n4. Avoiding computationally expensive operations that lead to timeouts\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimized circle packing for n=26 circles using a specialized pattern and efficient optimization\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize with a specialized pattern based on mathematical principles\n    centers, radii = initialize_specialized_pattern()\n    \n    # Apply efficient optimization\n    centers, radii = optimize_packing(centers, radii)\n    \n    # Final validation and adjustment\n    radii = compute_max_radii(centers)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef initialize_specialized_pattern():\n    \"\"\"\n    Initialize with a specialized pattern that combines:\n    - Corner circles\n    - Edge circles\n    - Interior grid with variable sizes\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place circles in corners (4)\n    corner_positions = [(0.09, 0.09), (0.91, 0.09), (0.09, 0.91), (0.91, 0.91)]\n    for i in range(4):\n        centers[i] = corner_positions[i]\n        radii[i] = 0.09  # Initial estimate\n    \n    # Place circles along edges (8)\n    edge_positions = [\n        (0.25, 0.09), (0.5, 0.09), (0.75, 0.09),  # Bottom edge\n        (0.09, 0.5),                              # Left edge\n        (0.91, 0.5),                              # Right edge\n        (0.25, 0.91), (0.5, 0.91), (0.75, 0.91)   # Top edge\n    ]\n    for i in range(8):\n        centers[i+4] = edge_positions[i]\n        radii[i+4] = 0.09  # Initial estimate\n    \n    # Place interior circles (14) in a modified hexagonal pattern\n    interior_count = n - 12\n    interior_centers = []\n    \n    # Create a grid pattern for the interior\n    rows, cols = 3, 5\n    for row in range(rows):\n        for col in range(cols):\n            # Skip some positions to get exactly 14 interior circles\n            if (row == 0 and col == 0) or (row == 2 and col == 4):\n                continue\n                \n            x = 0.25 + col * 0.125\n            y = 0.25 + row * 0.25\n            # Add slight offset to odd rows for better packing\n            if row % 2 == 1:\n                x += 0.0625\n            interior_centers.append((x, y))\n    \n    for i in range(interior_count):\n        centers[i+12] = interior_centers[i]\n        radii[i+12] = 0.09  # Initial estimate\n    \n    return centers, radii\n\n\ndef optimize_packing(centers, radii):\n    \"\"\"\n    Efficient optimization to maximize the sum of radii.\n    Uses a combination of force-directed placement and local adjustments.\n    \"\"\"\n    n = centers.shape[0]\n    \n    # Stage 1: Force-directed optimization\n    repulsion_strength = 0.003\n    attraction_strength = 0.0002\n    border_strength = 0.005\n    \n    for iteration in range(100):  # Reduced iterations for speed\n        # Calculate forces\n        forces = np.zeros_like(centers)\n        \n        # Circle-circle repulsion (more efficient implementation)\n        for i in range(n):\n            # Calculate all distances at once\n            diff = centers - centers[i]\n            dist_sq = np.sum(diff**2, axis=1)\n            dist = np.sqrt(dist_sq)\n            \n            # Avoid self-comparison\n            dist[i] = 1.0  # Arbitrary non-zero value\n            \n            # Calculate repulsion force\n            mask = dist < (radii + radii[i]) * 1.1  # Slightly larger than exact overlap\n            mask[i] = False  # Exclude self\n            \n            if np.any(mask):\n                # Normalize directions\n                directions = diff[mask] / dist[mask, np.newaxis]\n                # Calculate force magnitudes\n                magnitudes = repulsion_strength / (dist[mask] + 0.001)\n                # Apply forces\n                forces[i] += np.sum(directions * magnitudes[:, np.newaxis], axis=0)\n        \n        # Center attraction\n        center_diff = np.array([0.5, 0.5]) - centers\n        center_dist = np.sqrt(np.sum(center_diff**2, axis=1))\n        forces += attraction_strength * center_diff / center_dist[:, np.newaxis]\n        \n        # Border repulsion (more efficient)\n        x_forces = border_strength * (1.0 / (centers[:, 0] + 0.001) - 1.0 / (1.0 - centers[:, 0] + 0.001))\n        y_forces = border_strength * (1.0 / (centers[:, 1] + 0.001) - 1.0 / (1.0 - centers[:, 1] + 0.001))\n        forces[:, 0] += x_forces\n        forces[:, 1] += y_forces\n        \n        # Update positions with decreasing step size\n        step_size = 0.01 * (1.0 - iteration / 100)\n        centers += forces * step_size\n        \n        # Ensure circles stay within bounds\n        centers = np.clip(centers, 0.001, 0.999)\n        \n        # Update radii\n        if iteration % 5 == 0:  # Only update occasionally for speed\n            radii = compute_max_radii(centers)\n    \n    # Stage 2: Local optimization for specific circle arrangements\n    # Focus on key circles that can be adjusted for better overall packing\n    key_indices = [0, 1, 2, 3]  # Corner circles\n    \n    for _ in range(50):\n        for idx in key_indices:\n            # Try small movements in different directions\n            best_sum = np.sum(radii)\n            best_pos = centers[idx].copy()\n            \n            for dx, dy in [(0.005, 0), (-0.005, 0), (0, 0.005), (0, -0.005)]:\n                centers[idx, 0] += dx\n                centers[idx, 1] += dy\n                \n                # Keep within bounds\n                centers[idx] = np.clip(centers[idx], 0.001, 0.999)\n                \n                # Compute new radii\n                new_radii = compute_max_radii(centers)\n                new_sum = np.sum(new_radii)\n                \n                if new_sum > best_sum:\n                    best_sum = new_sum\n                    best_pos = centers[idx].copy()\n                else:\n                    # Revert\n                    centers[idx, 0] -= dx\n                    centers[idx, 1] -= dy\n            \n            # Set to best position\n            centers[idx] = best_pos\n        \n        # Update radii\n        radii = compute_max_radii(centers)\n    \n    return centers, radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Efficiently compute the maximum possible radii for each circle position.\n    Uses a more optimized algorithm to avoid excessive iterations.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n    \n    # Distance to borders\n    radii = np.minimum(centers[:, 0], centers[:, 1])\n    radii = np.minimum(radii, 1.0 - centers[:, 0])\n    radii = np.minimum(radii, 1.0 - centers[:, 1])\n    \n    # Adjust for circle-circle overlaps\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                # For each pair, the sum of radii must be <= distance\n                # We use a binary search approach to find optimal radii\n                \n                if dist < radii[i] + radii[j]:\n                    # Distribute the overlap reduction proportionally to current radii\n                    if radii[i] + radii[j] > 0:\n                        ratio_i = radii[i] / (radii[i] + radii[j])\n                        reduction_i = ratio_i * (radii[i] + radii[j] - dist)\n                        radii[i] = max(0.001, radii[i] - reduction_i)\n    \n    # Final adjustment pass to ensure no overlaps\n    for _ in range(3):  # Fewer iterations for speed\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    max_allowed = max(0.0, dist - radii[j])\n                    radii[i] = min(radii[i], max_allowed)\n    \n    return radii\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\n\nThe key improvements in this rewritten program include:\n\n1. **Specialized initialization pattern**: I've created a carefully designed pattern with circles in corners, along edges, and in the interior using a modified hexagonal grid. This provides a much better starting point than random initialization.\n\n2. **Efficient optimization**: The optimization process has been streamlined to avoid expensive operations:\n   - More efficient force calculation using vectorized operations\n   - Reduced number of iterations while maintaining effectiveness\n   - Staged optimization focusing on high-impact adjustments\n   - Adaptive step sizes that decrease over time\n\n3. **Improved radii computation**: The algorithm for computing maximum radii has been optimized:\n   - Vectorized border distance calculations\n   - Proportional overlap reduction based on current radii\n   - Fewer iterations in the final adjustment pass\n\n4. **Strategic circle placement**: The program now places circles of different sizes in strategic locations:\n   - Corner circles to maximize space utilization\n   - Edge circles to create a boundary pattern\n   - Interior circles in a modified hexagonal pattern for dense packing\n\nThese changes should significantly improve both the sum of radii and the execution time, helping to avoid timeouts while approaching the target value of 2.635."]}}}