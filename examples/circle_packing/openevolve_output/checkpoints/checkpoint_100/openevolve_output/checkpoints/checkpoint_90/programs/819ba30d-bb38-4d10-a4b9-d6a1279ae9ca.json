{"id": "819ba30d-bb38-4d10-a4b9-d6a1279ae9ca", "code": "# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a hybrid optimization approach with improved initialization and physics-based refinement.\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialization: Start with a good initial guess using a combined hexagonal and grid pattern\n    centers, radii = initialize_packing()\n\n    # Optimization: Refine the arrangement using a physics-based simulation\n    centers, radii = refine_packing(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef initialize_packing():\n    \"\"\"\n    Initialize the circle packing with a combination of hexagonal and grid arrangements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.15  # Larger radius for central circle\n\n    # Hexagonal ring around the center (6 circles)\n    angles = np.linspace(0, 2 * np.pi, 7)[:-1]\n    ring_radius = 0.25\n    for i in range(1, 7):\n        centers[i] = [0.5 + ring_radius * np.cos(angles[i - 1]),\n                      0.5 + ring_radius * np.sin(angles[i - 1])]\n        radii[i] = 0.12\n\n    # Grid-like arrangement for the remaining circles (19 circles)\n    grid_size = 4\n    spacing = 0.8 / (grid_size - 1)  # Adjust spacing to fit within the square\n    count = 7\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count < n:\n                centers[count] = [0.1 + i * spacing, 0.1 + j * spacing]\n                radii[count] = 0.08 + np.random.rand() * 0.03  # Introduce some variation\n                count += 1\n\n    # Adjust radii based on environment\n    radii = compute_max_radii(centers)\n    return centers, radii\n\ndef refine_packing(centers, radii, iterations=500, repulsion_strength=0.01, step_size=0.005):\n    \"\"\"\n    Refine the circle packing using a physics-based simulation with repulsion forces.\n    \"\"\"\n    n = centers.shape[0]\n\n    for _ in range(iterations):\n        # Calculate repulsion forces between circles\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    distance = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    overlap = radii[i] + radii[j] - distance\n                    if overlap > 0:\n                        # Repulsion force proportional to overlap and inverse square of distance\n                        direction = (centers[i] - centers[j]) / distance\n                        forces[i] += repulsion_strength * overlap * direction\n\n        # Move circles based on forces, but keep them within the unit square\n        centers += forces * step_size\n\n        # Reflect circles off the walls\n        for i in range(n):\n            if centers[i, 0] - radii[i] < 0:\n                centers[i, 0] = radii[i]\n            if centers[i, 0] + radii[i] > 1:\n                centers[i, 0] = 1 - radii[i]\n            if centers[i, 1] - radii[i] < 0:\n                centers[i, 1] = radii[i]\n            if centers[i, 1] + radii[i] > 1:\n                centers[i, 1] = 1 - radii[i]\n\n        # Adjust radii to avoid overlaps\n        radii = compute_max_radii(centers)\n\n    return centers, radii\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distances to other circles\n    for _ in range(3):  # Multiple iterations for better convergence\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    if dist < radii[i] + radii[j]:\n                        # Adjust both radii proportionally to their current sizes\n                        total = radii[i] + radii[j]\n                        if total > 0:  # Avoid division by zero\n                            ratio_i = radii[i] / total\n                            ratio_j = radii[j] / total\n                            radii[i] = ratio_i * dist\n                            radii[j] = ratio_j * dist\n\n    # Final pass to ensure no overlaps\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                max_r_i = (dist - radii[j]) / 2.0\n                if max_r_i < radii[i]:\n                    radii[i] = max(0.0, max_r_i)\n                max_r_j = (dist - radii[i]) / 2.0\n                if max_r_j < radii[j]:\n                    radii[j] = max(0.0, max_r_j)\n\n    return radii\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)", "language": "python", "parent_id": "88803965-a7ca-4ff9-995e-49a137e68974", "generation": 4, "timestamp": 1750752059.4692109, "iteration_found": 56, "metrics": {"validity": 1.0, "sum_radii": 1.2645356296976709, "target_ratio": 0.4798996697144861, "combined_score": 0.4798996697144861, "eval_time": 7.59053635597229}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"stage1_passed": 0.0, "error": 0.0, "timeout": true}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.635 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.377, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Current performance metrics: - stage1_passed: 0.0000\n- error: 0.0000\n- timeout: 1.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n## Last Execution Output\n\n### timeout\n```\nTrue\n```\n\n### timeout_duration\n```\n90\n```\n\n### failure_stage\n```\nstage1\n```\n\n### error_type\n```\ntimeout\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 1.8125, target_ratio: 0.6879, combined_score: 0.6879, eval_time: 16.3053\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.0707, target_ratio: 0.7858, combined_score: 0.7858, eval_time: 31.6651\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: validity: 1.0000, sum_radii: 2.3617, target_ratio: 0.8963, combined_score: 0.8963, eval_time: 50.7247\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 2.1104)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern and multi-stage optimization\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using specialized patterns.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4124), Performs well on target_ratio (0.9155), Performs well on combined_score (0.9155), Performs well on eval_time (5.3085)\n\n\n### Program 2 (Score: 11.1758)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using variable-sized circles and specialized optimization\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.3617), Performs well on target_ratio (0.8963), Performs well on combined_score (0.8963), Performs well on eval_time (50.7247)\n\n\n### Program 3 (Score: 0.3333)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a hybrid optimization approach\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n\n### Program 4 (Score: 7.2615)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a hybrid optimization approach with improved initialization and physics.\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n# ... (truncated for brevity)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.0707), Performs well on target_ratio (0.7858), Performs well on combined_score (0.7858), Performs well on eval_time (31.6651)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimized circle packing for n=26 circles using a specialized pattern and efficient optimization\"\"\"\nimport numpy as np\n\n\n# ... (truncated)\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a specialized pattern with variable-sized circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Start with a specialized pattern based on mathematical principles\n    centers, radii = initialize_specialized_pattern()\n    \n    # Apply optimization to refine the pattern\n    centers, radii = optimize_packing(centers, radii)\n    \n    # Final validation and adjustment\n    radii = compute_max_radii(centers)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef initialize_specialized_pattern():\n    \"\"\"\n    Initialize with a specialized pattern that combines:\n    1. A central large circle\n    2. A ring of medium-sized circles\n    3. Smaller circles in the corners and along edges\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    \n    # Place central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Place a ring of 8 circles around the central one\n    angles = np.linspace(0, 2*np.pi, 9)[:-1]  # 8 angles\n    ring_radius = 0.25\n    for i in range(1, 9):\n        centers[i] = [\n            0.5 + ring_radius * np.cos(angles[i-1]),\n            0.5 + ring_radius * np.sin(angles[i-1])\n        ]\n    \n    # Place 4 circles in the corners\n    corners = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n    for i in range(9, 13):\n        centers[i] = corners[i-9]\n    \n    # Place 12 circles along the edges\n    edge_positions = [\n        # Bottom edge\n        [0.25, 0.1], [0.5, 0.1], [0.75, 0.1],\n        # Top edge\n        [0.25, 0.9], [0.5, 0.9], [0.75, 0.9],\n        # Left edge\n        [0.1, 0.25], [0.1, 0.5], [0.1, 0.75],\n        # Right edge\n        [0.9, 0.25], [0.9, 0.5], [0.9, 0.75]\n    ]\n    for i in range(13, 25):\n        centers[i] = edge_positions[i-13]\n    \n    # Place one more circle in a less crowded area\n    centers[25] = [0.5, 0.3]\n    \n    # Initial radii\n    radii = compute_max_radii(centers)\n    \n    return centers, radii\n\n\ndef optimize_packing(centers, radii):\n    \"\"\"\n    Multi-stage optimization to maximize the sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    \n    # Stage 1: Simulated annealing to explore the configuration space\n    temperature = 0.05\n    cooling_rate = 0.95\n    iterations_per_temp = 100\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_sum = np.sum(radii)\n    \n    for temp_step in range(15):  # Temperature steps\n        temperature *= cooling_rate\n        \n        for _ in range(iterations_per_temp):\n            # Choose a random circle to move\n            i = np.random.randint(0, n)\n            \n            # Save current position\n            old_pos = current_centers[i].copy()\n            \n            # Move in a random direction\n            angle = np.random.uniform(0, 2*np.pi)\n            distance = np.random.uniform(0, 0.05)\n            \n            current_centers[i, 0] += distance * np.cos(angle)\n            current_centers[i, 1] += distance * np.sin(angle)\n            \n            # Keep within bounds\n            if (current_centers[i, 0] < 0 or current_centers[i, 0] > 1 or\n                current_centers[i, 1] < 0 or current_centers[i, 1] > 1):\n                current_centers[i] = old_pos\n                continue\n            \n            # Recompute radii and sum\n            new_radii = compute_max_radii(current_centers)\n            new_sum = np.sum(new_radii)\n            \n            # Accept or reject based on simulated annealing criteria\n            delta = new_sum - current_sum\n            if delta > 0 or np.random.random() < np.exp(delta / temperature):\n                current_radii = new_radii\n                current_sum = new_sum\n                \n                # Update best if improved\n                if current_sum > best_sum:\n                    best_centers = current_centers.copy()\n                    best_radii = current_radii.copy()\n                    best_sum = current_sum\n            else:\n                # Reject move\n                current_centers[i] = old_pos\n    \n    # Stage 2: Fine-tuning with gradient ascent\n    centers = best_centers.copy()\n    radii = best_radii.copy()\n    \n    learning_rate = 0.001\n    for _ in range(50):\n        gradients = compute_gradients(centers, radii)\n        centers += learning_rate * gradients\n        centers = np.clip(centers, 0.001, 0.999)\n        radii = compute_max_radii(centers)\n    \n    return centers, radii\n\n\ndef compute_gradients(centers, radii):\n    \"\"\"\n    Compute numerical gradients for each circle position to maximize sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    gradients = np.zeros_like(centers)\n    \n    base_sum = np.sum(radii)\n    delta = 0.0001\n    \n    for i in range(n):\n        for dim in range(2):\n            # Try moving slightly in positive direction\n            centers[i, dim] += delta\n            pos_radii = compute_max_radii(centers)\n            pos_sum = np.sum(pos_radii)\n            \n            # Try moving slightly in negative direction\n            centers[i, dim] -= 2*delta\n            neg_radii = compute_max_radii(centers)\n            neg_sum = np.sum(neg_radii)\n            \n            # Reset position\n            centers[i, dim] += delta\n            \n            # Central difference gradient\n            gradients[i, dim] = (pos_sum - neg_sum) / (2*delta)\n    \n    return gradients\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n    \n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1-x, 1-y)\n    \n    # Then, limit by distances to other circles\n    for _ in range(3):  # Multiple iterations for better convergence\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    if dist < radii[i] + radii[j]:\n                        # Adjust both radii proportionally to their current sizes\n                        total = radii[i] + radii[j]\n                        if total > 0:  # Avoid division by zero\n                            ratio_i = radii[i] / total\n                            ratio_j = radii[j] / total\n                            radii[i] = ratio_i * dist\n                            radii[j] = ratio_j * dist\n    \n    # Final pass to ensure no overlaps\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                max_r_i = dist - radii[j]\n                if max_r_i < radii[i]:\n                    radii[i] = max(0.0, max_r_i)\n    \n    return radii\n\n\ndef optimize_specific_patterns():\n    \"\"\"\n    Try several specific patterns known to work well for circle packing\n    and return the best one.\n    \"\"\"\n    # Pattern 1: Hexagonal-based arrangement\n    def hexagonal_pattern():\n        n = 26\n        centers = np.zeros((n, 2))\n        \n        # Central circle\n        centers[0] = [0.5, 0.5]\n        \n        # First hexagonal ring (6 circles)\n        angles = np.linspace(0, 2*np.pi, 7)[:-1]\n        ring_radius = 0.2\n        for i in range(1, 7):\n            centers[i] = [\n                0.5 + ring_radius * np.cos(angles[i-1]),\n                0.5 + ring_radius * np.sin(angles[i-1])\n            ]\n        \n        # Second partial ring (12 circles)\n        angles = np.linspace(0, 2*np.pi, 13)[:-1]\n        ring_radius = 0.4\n        for i in range(7, 19):\n            centers[i] = [\n                0.5 + ring_radius * np.cos(angles[i-7]),\n                0.5 + ring_radius * np.sin(angles[i-7])\n            ]\n        \n        # Corner circles (4)\n        corners = [[0.08, 0.08], [0.08, 0.92], [0.92, 0.08], [0.92, 0.92]]\n        for i in range(19, 23):\n            centers[i] = corners[i-19]\n        \n        # Edge circles (3)\n        edges = [[0.5, 0.08], [0.08, 0.5], [0.92, 0.5]]\n        for i in range(23, 26):\n            centers[i] = edges[i-23]\n        \n        return centers\n    \n    # Pattern 2: Square grid with variable sizes\n    def square_grid_pattern():\n        n = 26\n        centers = np.zeros((n, 2))\n        \n        # 5x5 grid with one extra\n        grid_size = 5\n        spacing = 1.0 / (grid_size + 1)\n        \n        idx = 0\n        for i in range(1, grid_size+1):\n            for j in range(1, grid_size+1):\n                if idx < n:\n                    centers[idx] = [i * spacing, j * spacing]\n                    idx += 1\n        \n        # Add the last circle at the center\n        if idx < n:\n            centers[idx] = [0.5, 0.5]\n        \n        return centers\n    \n    # Pattern 3: Concentric rings\n    def concentric_rings_pattern():\n        n = 26\n        centers = np.zeros((n, 2))\n        \n        # Center circle\n        centers[0] = [0.5, 0.5]\n        \n        # Inner ring (8 circles)\n        angles = np.linspace(0, 2*np.pi, 9)[:-1]\n        ring_radius = 0.22\n        for i in range(1, 9):\n            centers[i] = [\n                0.5 + ring_radius * np.cos(angles[i-1]),\n                0.5 + ring_radius * np.sin(angles[i-1])\n            ]\n        \n        # Outer ring (16 circles)\n        angles = np.linspace(0, 2*np.pi, 17)[:-1]\n        ring_radius = 0.42\n        for i in range(9, 25):\n            centers[i] = [\n                0.5 + ring_radius * np.cos(angles[i-9]),\n                0.5 + ring_radius * np.sin(angles[i-9])\n            ]\n        \n        # One more at a strategic position\n        centers[25] = [0.5, 0.8]\n        \n        return centers\n    \n    # Try all patterns and optimize each\n    patterns = [\n        hexagonal_pattern(),\n        square_grid_pattern(),\n        concentric_rings_pattern()\n    ]\n    \n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    for pattern_centers in patterns:\n        radii = compute_max_radii(pattern_centers)\n        centers, radii = optimize_packing(pattern_centers, radii)\n        radii = compute_max_radii(centers)\n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers\n            best_radii = radii\n    \n    return best_centers, best_radii\n\n\ndef try_known_good_solution():\n    \"\"\"\n    Implement a known good solution based on mathematical principles\n    for circle packing with n=26.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central large circle\n    centers[0] = [0.5, 0.5]\n    \n    # First ring - 6 circles in hexagonal pattern\n    for i in range(6):\n        angle = i * np.pi / 3\n        centers[i+1] = [\n            0.5 + 0.2 * np.cos(angle),\n            0.5 + 0.2 * np.sin(angle)\n        ]\n    \n    # Second ring - 12 circles\n    for i in range(12):\n        angle = i * np.pi / 6\n        centers[i+7] = [\n            0.5 + 0.38 * np.cos(angle),\n            0.5 + 0.38 * np.sin(angle)\n        ]\n    \n    # Corner circles - 4 circles\n    corners = [[0.09, 0.09], [0.09, 0.91], [0.91, 0.09], [0.91, 0.91]]\n    for i in range(4):\n        centers[i+19] = corners[i]\n    \n    # Additional circles at strategic positions\n    centers[23] = [0.5, 0.09]\n    centers[24] = [0.09, 0.5]\n    centers[25] = [0.91, 0.5]\n    \n    # Compute radii and optimize\n    radii = compute_max_radii(centers)\n    centers, radii = optimize_packing(centers, radii)\n    \n    return centers, radii\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n    \"\"\"\n    # Try multiple approaches and take the best result\n    \n    # Approach 1: Start with specialized pattern\n    centers1, radii1 = initialize_specialized_pattern()\n    centers1, radii1 = optimize_packing(centers1, radii1)\n    radii1 = compute_max_radii(centers1)\n    sum1 = np.sum(radii1)\n    \n    # Approach 2: Try specific patterns\n    centers2, radii2 = optimize_specific_patterns()\n    sum2 = np.sum(radii2)\n    \n    # Approach 3: Known good solution\n    centers3, radii3 = try_known_good_solution()\n    radii3 = compute_max_radii(centers3)\n    sum3 = np.sum(radii3)\n    \n    # Select the best result\n    if sum1 >= sum2 and sum1 >= sum3:\n        return centers1, radii1, sum1\n    elif sum2 >= sum1 and sum2 >= sum3:\n        return centers2, radii2, sum2\n    else:\n        return centers3, radii3, sum3\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Advanced circle packing for n=26 circles using a hybrid optimization approach with improved initialization and physics-based refinement.\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialization: Start with a good initial guess using a combined hexagonal and grid pattern\n    centers, radii = initialize_packing()\n\n    # Optimization: Refine the arrangement using a physics-based simulation\n    centers, radii = refine_packing(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef initialize_packing():\n    \"\"\"\n    Initialize the circle packing with a combination of hexagonal and grid arrangements.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n    radii[0] = 0.15  # Larger radius for central circle\n\n    # Hexagonal ring around the center (6 circles)\n    angles = np.linspace(0, 2 * np.pi, 7)[:-1]\n    ring_radius = 0.25\n    for i in range(1, 7):\n        centers[i] = [0.5 + ring_radius * np.cos(angles[i - 1]),\n                      0.5 + ring_radius * np.sin(angles[i - 1])]\n        radii[i] = 0.12\n\n    # Grid-like arrangement for the remaining circles (19 circles)\n    grid_size = 4\n    spacing = 0.8 / (grid_size - 1)  # Adjust spacing to fit within the square\n    count = 7\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count < n:\n                centers[count] = [0.1 + i * spacing, 0.1 + j * spacing]\n                radii[count] = 0.08 + np.random.rand() * 0.03  # Introduce some variation\n                count += 1\n\n    # Adjust radii based on environment\n    radii = compute_max_radii(centers)\n    return centers, radii\n\ndef refine_packing(centers, radii, iterations=500, repulsion_strength=0.01, step_size=0.005):\n    \"\"\"\n    Refine the circle packing using a physics-based simulation with repulsion forces.\n    \"\"\"\n    n = centers.shape[0]\n\n    for _ in range(iterations):\n        # Calculate repulsion forces between circles\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    distance = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    overlap = radii[i] + radii[j] - distance\n                    if overlap > 0:\n                        # Repulsion force proportional to overlap and inverse square of distance\n                        direction = (centers[i] - centers[j]) / distance\n                        forces[i] += repulsion_strength * overlap * direction\n\n        # Move circles based on forces, but keep them within the unit square\n        centers += forces * step_size\n\n        # Reflect circles off the walls\n        for i in range(n):\n            if centers[i, 0] - radii[i] < 0:\n                centers[i, 0] = radii[i]\n            if centers[i, 0] + radii[i] > 1:\n                centers[i, 0] = 1 - radii[i]\n            if centers[i, 1] - radii[i] < 0:\n                centers[i, 1] = radii[i]\n            if centers[i, 1] + radii[i] > 1:\n                centers[i, 1] = 1 - radii[i]\n\n        # Adjust radii to avoid overlaps\n        radii = compute_max_radii(centers)\n\n    return centers, radii\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distances to other circles\n    for _ in range(3):  # Multiple iterations for better convergence\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    if dist < radii[i] + radii[j]:\n                        # Adjust both radii proportionally to their current sizes\n                        total = radii[i] + radii[j]\n                        if total > 0:  # Avoid division by zero\n                            ratio_i = radii[i] / total\n                            ratio_j = radii[j] / total\n                            radii[i] = ratio_i * dist\n                            radii[j] = ratio_j * dist\n\n    # Final pass to ensure no overlaps\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                max_r_i = (dist - radii[j]) / 2.0\n                if max_r_i < radii[i]:\n                    radii[i] = max(0.0, max_r_i)\n                max_r_j = (dist - radii[i]) / 2.0\n                if max_r_j < radii[j]:\n                    radii[j] = max(0.0, max_r_j)\n\n    return radii\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```"]}}}